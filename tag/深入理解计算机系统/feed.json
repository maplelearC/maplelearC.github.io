{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"深入理解计算机系统\" tag",
    "description": "Maple的编程学习",
    "home_page_url": "https://maplelearc.github.io",
    "items": [
        {
            "id": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/",
            "url": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/",
            "title": "CSAPP:第一章",
            "date_published": "2022-10-05T07:50:37.000Z",
            "content_html": "<h1 id=\"csapp第一章\"><a class=\"anchor\" href=\"#csapp第一章\">#</a> 《CSAPP：第一章》</h1>\n<h2 id=\"11-信息就是位上下文\"><a class=\"anchor\" href=\"#11-信息就是位上下文\">#</a> 1.1 信息就是位 + 上下文</h2>\n<p>程序的生命周期从源程序 (源文件) 开始。源程序实际上就是由 0 和 1 组成的位序列。</p>\n<p>一般 ASCII 标准来表示文本字符，实际上是用一个字节的整数值来表示一种字符。</p>\n<p>源文件中每个文本行都是以看不见的 '\\n' 结束的。</p>\n<p>只由 ASCII 字符组成的文件成为<strong>文本文件</strong>，其他都是<strong>二进制文件</strong>。.cpp 文件就是文本文件。</p>\n<p>系统中的所有信息都是由一串比特（bit：位）表示的，区分不同数据对象的<strong>唯一方法</strong>就是根据上下文。</p>\n<p><strong>C 语言的特点</strong></p>\n<ol>\n<li>C 语言小而简单</li>\n<li>C 语言是为了实现 unix 而设计的</li>\n<li>C 语言与 unix 关系密切</li>\n</ol>\n<p>C 语言是系统级编程的首选，也非常适用于应用级程序。</p>\n<h2 id=\"12-程序被其他程序翻译成不同的格式\"><a class=\"anchor\" href=\"#12-程序被其他程序翻译成不同的格式\">#</a> <strong>1.2</strong> 程序被其他程序翻译成不同的格式</h2>\n<p>从源程序到目标程序要经历<strong>四个步骤：</strong></p>\n<ol>\n<li>源程序被<strong>预处理器</strong>处理得到<strong>修改了的源程序</strong>（文本文件，hello.i）</li>\n<li>再由<strong>编译器</strong>处理得到<strong>汇编程序</strong>（文本文件，hello.s）</li>\n<li>汇编程序由<strong>汇编器</strong>处理得到<strong>可重定位目标程序</strong>（二进制文件，hello.o）</li>\n<li>最后由<strong>链接器</strong>链接得到<strong>可执行目标程序</strong>（二进制文件，hello）</li>\n</ol>\n<p><strong>预处理阶段</strong></p>\n<p>预处理器根据 # 开头的命令修改原始的 c 程序。比如根据 #include 命令把头文件 stdio.h 的内容直接插入到程序文件中</p>\n<p><strong>编译阶段</strong></p>\n<p><strong>汇编阶段</strong></p>\n<p><strong>链接阶段</strong></p>\n<p>比如 printf 函数是一个标准 C 库函数，存在于 printf.o 中，这是一个单独的预编译好了的目标文件。链接器将其与汇编得到的二进制文件合并得到可执行目标文件。</p>\n<h2 id=\"13-了解编译系统如何工作是大有用处的\"><a class=\"anchor\" href=\"#13-了解编译系统如何工作是大有用处的\">#</a> 1.3 了解编译系统如何工作是大有用处的</h2>\n<p>用处：</p>\n<ol>\n<li>优化程序性能</li>\n<li>理解链接时出现的错误</li>\n<li>避免安全漏洞</li>\n</ol>\n<h2 id=\"14-处理器读并解释储存在内存中的指令\"><a class=\"anchor\" href=\"#14-处理器读并解释储存在内存中的指令\">#</a> 1.4 处理器读并解释储存在内存中的指令</h2>\n<p>shell 是一个命令行解释器，它输出一个提示符（&gt;&gt;），等待输入一个命令行，然后执行命令。如果输入的是可执行文件的名字，就运行该文件。</p>\n<h3 id=\"141-系统的硬件组成\"><a class=\"anchor\" href=\"#141-系统的硬件组成\">#</a> 1.4.1 系统的硬件组成</h3>\n<p>主要包括<strong>总线、I/O 设备、处理器、主存储器 **** 四个部分</strong></p>\n<ol>\n<li>\n<p><strong>总线</strong></p>\n<p>总线一次可以传输一个定长的字节块，称为字。64 位系统即总线一次可以传输 64 位（8 字节），这里一个字就是 8 字节</p>\n</li>\n<li>\n<p><strong>I/O 设备</strong></p>\n<p>每个 I/O 设备通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I/O 总线相连。</p>\n<p><strong>控制器</strong>是 I/O 设备本身或主板上的芯片组，<strong>适配器</strong>则是一块插在主板上的卡。</p>\n</li>\n<li>\n<p><strong>主存</strong></p>\n<p>主存是由一组 ** 动态随机存取内存（DRAM）** 组成的。</p>\n<p>从逻辑上看，存储器是一个线性的字节数组，每个字节都有唯一的地址。</p>\n</li>\n<li>\n<p><strong>处理器</strong></p>\n<p>处理器是<strong>解释存储在主存中指令</strong>的引擎。</p>\n<p>处理器的<strong>核心</strong>是一个<strong>程序计数器（PC)</strong></p>\n<p>程序计数器是一个大小为<strong>一个字</strong>的存储设备，存储 CPU 即将执行的<strong>下一条指令的地址</strong>。</p>\n<p>处理器就是在不断执行程序计数器指向的指令。每执行一条，程序计数器更新一次，指向下一条指令。</p>\n<p>处理器会按照 ** 指令执行模型（指令集架构）** 解释指令中的位并执行相应操作。</p>\n<p>每条指令的操作是围绕 ** 主存、寄存器文件、算数 / 逻辑单元（ALU）** 进行的。</p>\n</li>\n<li>\n<p><strong>寄存器文件</strong>：单个字长，有唯一的名字。</p>\n</li>\n<li>\n<p>**ALU：** 计算新的数据和地址值。</p>\n</li>\n<li>\n<p>几个简单指令的操作：</p>\n<ul>\n<li><em>加载</em> *：从主存复制一个字或字节到寄存器，覆盖原来内容 **</li>\n<li>存储 **：从寄存器复制一个字或字节到主存，覆盖原来内容 **</li>\n<li>操作 **：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并把结果存到一个寄存器中 **</li>\n<li>跳转 **：从指令中抽取一个字复制到程序计数器中，覆盖原来内容。</li>\n</ul>\n</li>\n</ol>\n<p>区分处理器指令集架构和微体系架构：</p>\n<ul>\n<li>** 指令集架构：** 每条机器指令的效果</li>\n<li>** 微体系架构：** 处理器实际上是如何实现的</li>\n</ul>\n<h3 id=\"142-运行-hello-程序\"><a class=\"anchor\" href=\"#142-运行-hello-程序\">#</a> <strong>1.4.2 运行 hello 程序</strong></h3>\n<p>执行目标文件时，shell 程序将位于磁盘目标文件中的字符逐个读入寄存器，然后放到主存中。之后处理器就开始执行目标文件的机器语言指令，从 main 程序开始。</p>\n<p>利用 ** 直接存储器存取（DMA）** 可以不通过寄存器，直接将数据从磁盘到达内存。</p>\n<p>以输出打印 hello world 为例，处理器将 hello world 的字节复制到寄存器，然后再复制到显示器，最后显示在屏幕上。</p>\n<p>** 整个流程：**<strong> 读取文件字符到寄存器 → 存储到主存  → 执行指令</strong>  →  <strong>加载 helloworld 到寄存器 → 复制到显示器 → 显示</strong></p>\n<h2 id=\"15-高速缓存至关重要\"><a class=\"anchor\" href=\"#15-高速缓存至关重要\">#</a> <strong>1.5 高速缓存至关重要</strong></h2>\n<p>从主存读取一个字比磁盘快 <strong>1000 万</strong>倍。</p>\n<p>从寄存器文件读取比主存块 <strong>100 倍</strong>，并且差距还在加大。</p>\n<p>高速缓存（cache）用来解决处理器与主存间的差异。</p>\n<p><strong>L1 高速缓存</strong>位于 <strong>CPU</strong> 上，容量为数万字节（<strong>几十 MB</strong>）。L1 比 L2 快 <strong>5</strong> 倍。</p>\n<p><strong>L2 高速缓存</strong>通过<strong>一条特殊的总线</strong>与 CPU 连接，容量为数十万到数百万字节（<strong>几百 MB 到 几 GB</strong>）。L2 比 主存快 <strong>5~10</strong> 倍</p>\n<p>新的系统还有 L3。</p>\n<p>通过让高速缓存里存放可能经常访问的数据，让大部分的内存操作都在高速缓存中完成。</p>\n<h2 id=\"16-存储设备形成层次结构\"><a class=\"anchor\" href=\"#16-存储设备形成层次结构\">#</a> <strong>1.6 存储设备形成层次结构</strong></h2>\n<p>存储器层次结构共 7 层，<strong>主要思想</strong>是上一层的存储器作为低一层的高速缓存。</p>\n<p>从上到下，容量更大，运行更慢，每字节价格更便宜。</p>\n<ul>\n<li>0 层：寄存器</li>\n<li>1 层：L1 高速缓存 (SRAM)</li>\n<li>2 层：L2 高速缓存 (SRAM)</li>\n<li>3 层：L3 高速缓存（SRAM）</li>\n<li>4 层：主存（DRAM）</li>\n<li>5 层：本地二级存储（本地磁盘）</li>\n<li>6 层：远程二级存储（分布式文件系统，Web 服务器）</li>\n</ul>\n<h2 id=\"17-操作系统管理硬件\"><a class=\"anchor\" href=\"#17-操作系统管理硬件\">#</a> <strong>1.7 操作系统管理硬件</strong></h2>\n<p>操作系统的<strong>两个基本功能：</strong></p>\n<ol>\n<li>防止硬件被失控的应用程序滥用</li>\n<li>向应用程序提供简单一致的机制来控制复杂的低级硬件设备</li>\n</ol>\n<p>操作系统所应用的<strong>三个基本的抽象概念：</strong></p>\n<ol>\n<li><strong>进程</strong>：对处理器、主存和 I/O 设备的抽象表示</li>\n<li><strong>虚拟内存</strong>：对主存和磁盘的抽象表示</li>\n<li><strong>文件</strong>：对 I/O 设备的抽象表示</li>\n</ol>\n<h3 id=\"171-进程\"><a class=\"anchor\" href=\"#171-进程\">#</a> <strong>1.7.1 进程</strong></h3>\n<p>** 进程：** 对操作系统正在运行的程序的一种抽象。</p>\n<p>** 并发运行：** 一个进程的指令和另一个进程的指令是交错执行的。</p>\n<p>一个系统可以同时运行多个进程，实际上这些进程是并发运行的。</p>\n<p>操作系统通过<strong>上下文切换</strong>来实现并发运行。上下文是跟踪进程运行所需的所有<strong>状态信息</strong>，可能存在于 PC、寄存器文件、主存等地方。</p>\n<p><strong>任何时刻，单处理器只能执行一个进程的代码。</strong></p>\n<p>操作系统<strong>内核</strong>是操作系统代码常驻主存的部分，从一个进程到另一个进程的转换是由内核管理的。</p>\n<p>内核不是一个独立的进程，是一系列代码和数据结构的集合。</p>\n<p>当应用程序需要操作系统的某些操作时，就把控制权传递给内核，内核执行完操作后返回应用程序。</p>\n<h3 id=\"172-线程\"><a class=\"anchor\" href=\"#172-线程\">#</a> <strong>1.7.2 线程</strong></h3>\n<p><strong>一个进程由多个线程组成</strong>，每个线程都运行在进程的上下文中，共享同样的代码和全局数据。</p>\n<p>多线程之间比多进程之间更容易共享数据，且线程一般来说比进程更高效。</p>\n<h3 id=\"173-虚拟内存\"><a class=\"anchor\" href=\"#173-虚拟内存\">#</a> <strong>1.7.3 虚拟内存</strong></h3>\n<p>机器级程序将内存视为一个庞大的字节数组，称为<strong>虚拟内存</strong>。</p>\n<p>内存的每个字节由地址来标识，所有可能地址的集合就是<strong>虚拟地址空间。</strong></p>\n<p>虚拟内存使每个进程都以为自己独占了主存。每个进程看到的内存都是<strong>一致的</strong>，即<strong>虚拟地址空间</strong>。</p>\n<p>在 linux 中，每个进程看到的虚拟地址空间由以下几个部分组成：</p>\n<ol>\n<li><strong>程序代码和数据</strong></li>\n<li><strong>堆（运行时堆）</strong></li>\n<li><strong>共享库</strong></li>\n<li><strong>栈（用户栈）</strong></li>\n<li><strong>内核虚拟内存</strong></li>\n</ol>\n<p>地址从低到高，最高层的<strong>内核虚拟内存</strong>保存的是操作系统中的代码和数据，这部分每个进程都一样。</p>\n<p><em>程序代码和数据</em> *</p>\n<p>对所有进程来说，代码都是从同一个固定地址开始，紧接着是与全局变量对应的数据区。代码和数据区都是按照可执行文件的内容初始化的。代码和数据区在进程开始运行时就被指定了大小。</p>\n<p><strong>堆</strong></p>\n<p>而运行时堆是根据 malloc 和 free 函数的调用在运行时<strong>动态地</strong>扩展和收缩的。</p>\n<p><strong>共享库</strong></p>\n<p>地址空间的中间部分用来存放共享库的代码和数据。如 C 标准库、数学库等都属于共享库</p>\n<p><strong>栈</strong></p>\n<p>用户栈和堆一样，在程序执行期间可以<strong>动态的扩展和收缩</strong>，编译器用它来<strong>实现函数调用</strong>。当调用函数时，栈增长，从函数返回时，栈收缩</p>\n<h3 id=\"174-文件\"><a class=\"anchor\" href=\"#174-文件\">#</a> <strong>1.7.4 文件</strong></h3>\n<p>文件就是<strong>字节序列</strong>，仅此而已。</p>\n<p>每个 I/O 设备，包括磁盘、键盘、显示器、网络，都可以看成是文件。</p>\n<h2 id=\"18-系统之间利用网络通信\"><a class=\"anchor\" href=\"#18-系统之间利用网络通信\">#</a> <strong>1.8 系统之间利用网络通信</strong></h2>\n<p>从一个单独的系统而言，网络可以视为一个 I/O 设备。</p>\n<p>以在一个远端服务器运行程序为例，在本地输入，在远端执行，执行结果发送回本地输出。</p>\n<h2 id=\"19-重要主题\"><a class=\"anchor\" href=\"#19-重要主题\">#</a> <strong>1.9 重要主题</strong></h2>\n<h3 id=\"191-amdahl-定律\"><a class=\"anchor\" href=\"#191-amdahl-定律\">#</a> <strong>1.9.1 Amdahl 定律</strong></h3>\n<p>Amdahl 定律的主要观点：要加速整个系统，必须提升全系统中相当大的部分。</p>\n<h3 id=\"192-并发和并行\"><a class=\"anchor\" href=\"#192-并发和并行\">#</a> <strong>1.9.2 并发和并行</strong></h3>\n<p>区分并发与并行：</p>\n<ul>\n<li>** 并发：** 一个通用的概念，指一个同时具有多个活动的系统</li>\n<li>** 并行：** 用并发来使系统运行得更快</li>\n</ul>\n<p>并行可以在多个抽象层次上运用。从高到低有以下三个层次</p>\n<p><strong>1. 线程级并行</strong></p>\n<p>传统意义上的并发执行是通过单处理器在进程间快速切换<strong>模拟</strong>出来的。</p>\n<p>多处理器系统由一个操作系统控制多个 CPU。结构如下</p>\n<p>​    <img data-src=\"http://lgqimg.changzer.cn/image-20221005160155790.png\" alt=\"image-20221005160155790\" /></p>\n<p>L1 高速缓存被分为两个部分：一个保存最近取到的指令，一个存放数据。</p>\n<p><strong>超线程</strong>又称<strong>同时多线程</strong>，它允许一个 CPU 执行多个控制流。 CPU 有的硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件只有一份，比如浮点算术运算单元。常规 CPU 需要约 <strong>20000</strong> 个时钟周期来切换线程，超线程 CPU 可以在<strong>单个周期</strong>的基础上切换线程，比如一个线程在等待数据装在到高速缓存，CPU 就可以去执行另一个线程。</p>\n<p>i7 处理器每个核执行两个线程，所以是 <strong>4 核 8 线程</strong>，8 个线程都并行执行。</p>\n<p><strong>2. 指令级并行</strong></p>\n<p>每条指令从开始到结束一般需要 20 个或更多的时钟周期，通过指令级并行，可以实现每个周期 2~4 条指令的执行速率。</p>\n<p>如果比一个周期一条指令更快，就称为<strong>超标量处理器</strong>，现在一般都是超标量。</p>\n<p><strong>3. 单指令、多数据并行</strong></p>\n<p>在最低层次上，现代处理器允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行，即 SIMD 并行。</p>\n<h3 id=\"193-计算机系统中抽象的重要性\"><a class=\"anchor\" href=\"#193-计算机系统中抽象的重要性\">#</a> <strong>1.9.3 计算机系统中抽象的重要性</strong></h3>\n<p>​    <img data-src=\"http://lgqimg.changzer.cn/image-20221005160217657.png\" alt=\"image-20221005160217657\" /></p>\n<p><strong>指令集架构</strong>是对 CPU 硬件的抽象，使用这个抽象，CPU 看起来好像一次只执行机器代码程序的一条指令，实际上底层硬件并行地执行多条指令。</p>\n<p><strong>虚拟机</strong>是对整个计算机系统的抽象，包括操作系统、处理器和程序。<strong>1.4.1 系统的硬件组成</strong></p>\n<p>主要包括<strong>总线、I/O 设备、处理器、主存储器 **** 四个部分</strong></p>\n",
            "tags": [
                "深入理解计算机系统",
                "CSAPP"
            ]
        },
        {
            "id": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/",
            "url": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/",
            "title": "CSAPP:第二章",
            "date_published": "2022-10-05T07:50:37.000Z",
            "content_html": "<h1 id=\"csapp第二章\"><a class=\"anchor\" href=\"#csapp第二章\">#</a> CSAPP: 第二章</h1>\n<h2 id=\"2-信息的表示和处理\"><a class=\"anchor\" href=\"#2-信息的表示和处理\">#</a> <strong>2、信息的表示和处理</strong></h2>\n<p>计算机使用二值信号存储和表示信息</p>\n<p>当计算结果太大以至于不能表示时，就会产生<strong>溢出</strong>。</p>\n<p>浮点数表示的精度有限，因而浮点运算是不可结合的。</p>\n<p>整数的表示范围小但是精确，浮点数表示的范围大但是是近似的。</p>\n<p>许多安全漏洞是由算术运算的微妙细节导致的。</p>\n<h2 id=\"21-信息存储\"><a class=\"anchor\" href=\"#21-信息存储\">#</a> <strong>2.1 信息存储</strong></h2>\n<p>计算机一般使用字节作为最小的可寻址的内存单位。</p>\n<p>在机器级程序中不包含关于数据类型的信息。</p>\n<p>指针的值是某个存储块的第一个字节的<strong>虚拟地址</strong>。</p>\n<p><strong>每个程序对象可以视为一个字节块。</strong></p>\n<h3 id=\"211-十六进制表示法\"><a class=\"anchor\" href=\"#211-十六进制表示法\">#</a> <strong>2.1.1 十六进制表示法</strong></h3>\n<p>十六进制以 0x 开头。</p>\n<p>A：10；C:12；F：15</p>\n<h3 id=\"212-字数据大小\"><a class=\"anchor\" href=\"#212-字数据大小\">#</a> <strong>2.1.2 字数据大小</strong></h3>\n<p>每个计算机有对应的字长，虚拟地址用一个字来编码，所以<strong>字长决定了虚拟地址空间的大小</strong>。<strong>64 位机器的指针类型长度为 8 字节</strong></p>\n<p>32 位机器的虚拟地址空间为 <strong>4GB</strong>，64 位字长的虚拟地址空间位 16 EB。</p>\n<p><strong>int32_t</strong> 和 <strong>int64_t</strong> 类型分别为 4 字节和 8 字节，不受机器影响。使用确定大小的整数类型很有用。</p>\n<p>对 32 位和 64 位机器而言，char、short、int、long long 长度都是一样的，为  1，2，4，8。long 的长度不一样。</p>\n<p>float 和 double 的长度一样，分别为 4，8</p>\n<p>程序对 char 有无符号一般不敏感。</p>\n<h3 id=\"213-寻址和字节顺序\"><a class=\"anchor\" href=\"#213-寻址和字节顺序\">#</a> <strong>2.1.3 寻址和字节顺序</strong></h3>\n<p>对于跨越多字节的对象，它的地址是它所用字节中的<strong>最小地址</strong>。</p>\n<p><strong>两种字节存储法：</strong></p>\n<ul>\n<li><strong>小端法</strong>：数字的低位在前（前就是最小地址）</li>\n<li><strong>大端法</strong>：数字的高位在前</li>\n</ul>\n<p>大多数 Intel 都是小端法，不是所有。</p>\n<h3 id=\"214-表示字符串\"><a class=\"anchor\" href=\"#214-表示字符串\">#</a> <strong>2.1.4 表示字符串</strong></h3>\n<p>C 语言字符串是以 null 字符结尾的字符数组，即 '\\0'</p>\n<p>ASCII 字符适合编码英文文档。</p>\n<p>Unicode（UTF-8）使用 <strong>4 字节</strong>表示字符，一些常用的字符只需要 1 或 2 个字节。所有 ASCII 字符在 UTF-8 中是一样的。</p>\n<p>JAVA 使用 UTF-8 来编码字符串。</p>\n<h3 id=\"215-表示代码\"><a class=\"anchor\" href=\"#215-表示代码\">#</a> <strong>2.1.5 表示代码</strong></h3>\n<p>二进制代码是<strong>不兼容</strong>的，一般无法在不同机器间移植。</p>\n<p>从机器的角度看，<strong>程序就是一个字节序列</strong>。</p>\n<h3 id=\"216-布尔代数\"><a class=\"anchor\" href=\"#216-布尔代数\">#</a> <strong>2.1.6 布尔代数</strong></h3>\n<p><strong>布尔代数</strong>是在 0 和 1 基础上的定义</p>\n<p>可以把字节看作是一个长为 8 的<strong>位向量</strong>。</p>\n<p>位向量的一个应用是表示有限集合。如位向量 [0110 1001] 表示集合 A = {0,3,5,6}。</p>\n<h3 id=\"217-c-语言中的位级运算\"><a class=\"anchor\" href=\"#217-c-语言中的位级运算\">#</a> <strong>2.1.7 C 语言中的位级运算</strong></h3>\n<p>位运算的常见应用是实现<strong>掩码</strong>。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8 位。</p>\n<p>表达式 <strong>~0</strong> 可以生成一个全 1 的掩码，不管机器的字大小是多少。</p>\n<h3 id=\"218-c-语言中的逻辑运算\"><a class=\"anchor\" href=\"#218-c-语言中的逻辑运算\">#</a> <strong>2.1.8 C 语言中的逻辑运算</strong></h3>\n<p>逻辑运算符 &amp;&amp; 和 || 如果第一个参数就能确定结果，就不再计算第二个参数</p>\n<h3 id=\"219-c-语言中的移位运算\"><a class=\"anchor\" href=\"#219-c-语言中的移位运算\">#</a> <strong>2.1.9 C 语言中的移位运算</strong></h3>\n<p>左移 k 位丢掉最高的 k 位，并在右端补 k 个 0。</p>\n<p>右移分为<strong>逻辑右移</strong>和<strong>算术右移</strong>。<strong>逻辑右移左端补 0，算术右移左端补最高有效位的值。</strong></p>\n<p>一般都对有符号数使用算术右移，即补符号位的值。无符号数，<strong>只能是逻辑右移</strong>，即补 0</p>\n<h2 id=\"22-整数表示\"><a class=\"anchor\" href=\"#22-整数表示\">#</a> <strong>2.2 整数表示</strong></h2>\n<p>无符号表示与补码表示</p>\n<p>有符号数到无符号数的转换会产生漏洞，<strong>避免错误的方法之一是绝不使用无符号数</strong>。</p>\n<p>除了 C 以外<strong>很少有语言支持无符号整数</strong>，Java 就只支持有符号数</p>\n<h3 id=\"221-整数数据类型\"><a class=\"anchor\" href=\"#221-整数数据类型\">#</a> <strong>2.2.1 整数数据类型</strong></h3>\n<p>在 64 位系统上</p>\n<ul>\n<li>i<strong>nt</strong>：4 字节，可表示十进制数字位数：<strong>10 位（-20~20 亿以内）</strong></li>\n<li><strong>long long</strong>：8 字节，可表示十进制数字位数：<strong>19 位（千亿亿级）</strong></li>\n<li>long：8 字节</li>\n<li><strong>double</strong>：8 字节，<strong>精度 15 位</strong>，可表示十进制数字位数<strong> 308 位</strong></li>\n<li><strong>float</strong>：4 字节，<strong>精度 6 位</strong>，可表示十进制数字<strong> 38 位</strong></li>\n<li><strong>char</strong>：<strong>-128~127</strong></li>\n</ul>\n<p>java 只支持有符号数。</p>\n<h3 id=\"222-无符号数的编码\"><a class=\"anchor\" href=\"#222-无符号数的编码\">#</a> <strong>2.2.2 无符号数的编码</strong></h3>\n<p>无符号表示、补码表示与数据的映射都是双射，即一一对应。</p>\n<h3 id=\"223-补码编码\"><a class=\"anchor\" href=\"#223-补码编码\">#</a> <strong>2.2.3 补码编码</strong></h3>\n<p>补码的定义实际就是<strong>将符号位解释为负权</strong>。</p>\n<p>C 库头文件  定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、UINT_MAX</p>\n<p>C 库头文件 中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数。</p>\n<p><strong>### 2.2.4 有符号数和无符号数之间的转换</strong></p>\n<p>在有符号数与无符号数之间进行强制类型转换的结果是<strong>保持位值不变，只改变解释位的方式。</strong></p>\n<p><strong>补码 x 转无符号数</strong></p>\n<ul>\n<li>x &gt;= 0，值不变</li>\n<li>x &lt; 0，转换后的值为 2^w + x</li>\n</ul>\n<p><strong>无符号数 x 转补码</strong></p>\n<ul>\n<li>x &lt;2^(w-1)，值不变</li>\n<li>x &gt;= 2^(w-1)，转换后的值为 x - 2^w</li>\n</ul>\n<h3 id=\"225-c-语言中的有符号数和无符号数\"><a class=\"anchor\" href=\"#225-c-语言中的有符号数和无符号数\">#</a> <strong>2.2.5 C 语言中的有符号数和无符号数</strong></h3>\n<p>C 语言中有符号数和无符号数相加减，有符号被转换成无符号。</p>\n<p><strong>### 2.2.6 扩展一个数字的位表示</strong></p>\n<p>扩展无符号数使用零扩展，即在最高位前加 0</p>\n<p>扩展有符号数使用符号扩展，即在最高位前加最高有效位的值</p>\n<p><strong>### 2.2.7 截断数字</strong></p>\n<p>对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。</p>\n<p>对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。</p>\n<h2 id=\"23-整数运算\"><a class=\"anchor\" href=\"#23-整数运算\">#</a> <strong>2.3 整数运算</strong></h2>\n<h3 id=\"231-无符号加法\"><a class=\"anchor\" href=\"#231-无符号加法\">#</a> <strong>2.3.1 无符号加法</strong></h3>\n<p>考虑溢出，C 语言不会将溢出作为错误发出信号</p>\n<p>当 x+y &gt;= 2^w，实际结果为 s = x+y-2^w</p>\n<p>对任意的 x+y，<strong>s = (x+y) % 2^w</strong></p>\n<p>** 溢出的结果：** 和小于两个加数</p>\n<p>** 检验溢出的方式：** 如果 <strong>s，说明溢出</strong></p>\n<p><strong>无符号数的非</strong>：~x = 2^w - x (x&gt;0)</p>\n<p><strong>### 2.3.2 补码加法</strong></p>\n<p>当 x+y &gt;= 2^(w-1)， s = x+y-2^w</p>\n<p>当 x+y &lt;-2^(w-1)，s = x+y+2^w</p>\n<p><strong>正溢出的结果是负数，负溢出的结果是正数。</strong></p>\n<p>** 检验溢出的方式：** 当 x,y&gt;0 而 s&lt;=0 是正溢出；当 x,y&lt;0 而 s&gt;=0 是负溢出</p>\n<p><strong>### 2.3.3 补码的非</strong></p>\n<p>当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x</p>\n<p>** 补码非的位级表示：**<strong> 对每一位求补，结果再加 1</strong></p>\n<p>** 计算补码非的第二种方法：** 假设 k 是最右边的 1 的位置，对 k 左边的所有位取反</p>\n<p><strong>### 2.3.4 无符号乘法</strong></p>\n<p><strong>无符号乘法的积</strong> <strong>m = (x*y) % 2^w</strong></p>\n<h3 id=\"235-补码乘法\"><a class=\"anchor\" href=\"#235-补码乘法\">#</a> <strong>2.3.5 补码乘法</strong></h3>\n<p>可以认为补码乘法和无符号乘法的<strong>位级表示</strong>是一样的</p>\n<p>C 语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释</p>\n<p><strong>补码乘法的积</strong> <strong>m = (x*y) % 2^w</strong></p>\n<p><strong>### 2.3.6 乘以常数</strong></p>\n<p>大多数机器上，整数乘法需要 <strong>10 个或更多</strong>的时钟周期，而加法、减法、位级运算和移位只需要 1 个时钟周期</p>\n<p><strong>编译器对整数乘法进行优化的方式</strong>：用<strong>移位和加法或减法</strong>运算的组合来代替常数因子的乘法。</p>\n<p>左移 k 位等于乘以 2^k</p>\n<p>如 x * 14  =  (x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)   =   (x&lt;&lt;4)-(x&lt;&lt;2)</p>\n<p><strong>判断如何移动的方式</strong>很简单：14 的位级表示为 1110，所以分别左移 3，2，1</p>\n<p><strong>### 2.3.7 除以 2 的幂</strong></p>\n<p>大多数机器上，整数除法更慢，需要 <strong>30 个或更多</strong>的始终周期。</p>\n<p>（只有）除以 2 的幂可以用移位运算来代替，<strong>无符号采用<strong><strong>逻辑右移</strong></strong>，补码采用 **** 算术右移</strong></p>\n<p>对于有符号数而言，算术右移的结果相当于进行除法运算后<strong>向下舍入</strong></p>\n<p>使用 <strong>(x+(1&lt;&gt;k</strong> 的结果相当于进行除法运算然后<strong>向零舍入</strong></p>\n<p>代码实现</p>\n<p>​                (x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k;</p>\n<h3 id=\"238-关于整数运算的最后思考\"><a class=\"anchor\" href=\"#238-关于整数运算的最后思考\">#</a> <strong>2.3.8 关于整数运算的最后思考</strong></h3>\n<p><strong>补码使用了与无符号算术运算相同的位级实现</strong>，包括加法、减法、乘法甚至除法。都有完全一样或非常类似的位级行为。</p>\n<h2 id=\"24-浮点数\"><a class=\"anchor\" href=\"#24-浮点数\">#</a> <strong>2.4 浮点数</strong></h2>\n<p>浮点数对于非常大，非常接近零，近似值计算都很有用</p>\n<h3 id=\"241-二进制小数\"><a class=\"anchor\" href=\"#241-二进制小数\">#</a> <strong>2.4.1 二进制小数</strong></h3>\n<p>小数的二进制表示法只能表示那些能够写为 <strong>x * 2^w</strong> 的数，<strong>其他的数都是近似表示。x 必须可以由形如 2^i + 2^j + ... + 2^n 的多项式表示</strong></p>\n<p>浮点运算的不精确性可能产生严重后果</p>\n<p><strong>### 2.4.2 IEEE 浮点表示</strong></p>\n<p><strong>IEEE 浮点标准</strong>的表示形式为：<strong>V = (-1)^S * M * 2^E</strong>，它分为三部分：</p>\n<ol>\n<li><strong>符号</strong>：<strong>S</strong> 决定是负数还是正数</li>\n<li><strong>阶码</strong>：<strong>E</strong> 的作用是对浮点数加权</li>\n<li><strong>尾数</strong>：<strong>M</strong> 是一个二进制小数，范围是 1~2-ε 或 0~1-ε</li>\n</ol>\n<p><strong>在对浮点数的位编码</strong>时：</p>\n<ol>\n<li>一个单独的符号位编码直接编码 S</li>\n<li>k 位的<strong>阶码字段 e</strong> 编码 E；float 中 k=8，double 中 <strong>k=11</strong></li>\n<li>n 位的<strong>小数字段 f</strong> 编码 M；float 中 n=23，double 中 <strong>n=52</strong></li>\n</ol>\n<p>E 和 M 的编码方式分为<strong>三种情况</strong>：</p>\n<ol>\n<li>\n<p>** 规格化的值：** 阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）</p>\n</li>\n<li>\n<ol>\n<li>阶码字段解释方式：<strong>E = e - (2^(k-1)-1)</strong>；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127</li>\n<li>小数字段解释方式：<strong>M = 1 + f</strong></li>\n</ol>\n</li>\n<li>\n<p><strong>非规格化的值</strong>：阶码字段全为 0 时属于非规格化形式</p>\n</li>\n<li>\n<ol>\n<li>阶码字段解释方式：<strong>E = 1 - (2^(k-1)-1)</strong>；<strong>与规格化值中 e = 1 时的 E 相同</strong></li>\n<li>小数字段解释方式：<strong>M = f</strong></li>\n</ol>\n</li>\n<li>\n<p>** 特殊值：** 阶码字段全为 1 时，分两种情况：</p>\n</li>\n<li>\n<ol>\n<li><strong>小数字段全为 0：表示无穷</strong></li>\n<li>** 小数字段非零：表示 NaN。** 比如 ∞-∞ 的结果就返回 NaN</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"243-数字示例\"><a class=\"anchor\" href=\"#243-数字示例\">#</a> <strong>2.4.3 数字示例</strong></h3>\n<p>0 有 +0.0 和 -0.0 两种表示方式</p>\n<p>最大非规格化数到最小规格化数的过渡是平滑的。</p>\n<p>浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升序负数降序）。</p>\n<p>浮点数可表示的数的分布是不均匀的，越接近零时越稠密</p>\n<p><strong>几个特殊的值的位级表示：</strong></p>\n<ol>\n<li>+0.0 全为 0</li>\n<li>** 最小的正非规格化值：** 最低有效位为 1，其他为 0</li>\n<li>** 最大的非规格化值：** 小数字段全为 1，其他为 0</li>\n<li>** 最小的正规格化值：** 阶码字段最低位为 1，其他为 0</li>\n<li>** 最大的规格化值：** 阶码字段最低位为 0，符号位为 0，其他为 1</li>\n</ol>\n<h3 id=\"244-舍入\"><a class=\"anchor\" href=\"#244-舍入\">#</a> <strong>2.4.4 舍入</strong></h3>\n<p>因为范围和精度有限，浮点运算只能近似表示实数运算。</p>\n<p>在浮点数的近似匹配上，IEEE 浮点格式定义了<strong>四种舍入方式（默认第一种）：</strong></p>\n<ol>\n<li><strong>向偶数舍入（向最接近的值舍入）</strong>：非中间值 (0.5) 四舍五入，中间值向偶数舍入。</li>\n<li>向零舍入</li>\n<li>向下舍入</li>\n<li>向上舍入</li>\n</ol>\n<p>向偶数舍入可以计算一组数的平均数时避免统计偏差。</p>\n<p>实际上这种舍入是发生在二进制小数上的。</p>\n<h3 id=\"245-浮点运算\"><a class=\"anchor\" href=\"#245-浮点运算\">#</a> <strong>2.4.5 浮点运算</strong></h3>\n<p>IEEE 标准定义 1/-0 = -∞，1/+0 = +∞</p>\n<p>浮点运算是<strong>可交换不可结合也不可分配</strong>的。</p>\n<p>浮点加法满足<strong>加法和乘法上的单调性</strong>。如果 a&gt;=b，则 x+a &gt;= x+b</p>\n<p>缺乏结合性和分配性会使一些简单问题变得很复杂</p>\n<h3 id=\"246-c-语言中的浮点数\"><a class=\"anchor\" href=\"#246-c-语言中的浮点数\">#</a> <strong>2.4.6 C 语言中的浮点数</strong></h3>\n<p>在 int、float、double 间进行<strong>强制类型转换时的几种情况：</strong></p>\n<ol>\n<li>int 到 float：不会溢出，可能舍入</li>\n<li>int 或 float 到 double：不会溢出也不会舍入</li>\n<li>double 到 float：可能溢出和舍入</li>\n<li>**float 或 double 到 int：** 向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，转变结果都为 [1000]，因此一个正浮点可能得到一个负整数</li>\n</ol>\n<p><strong>把大的浮点数转换为整数是一种常见的错误。</strong></p>\n<p><strong>要小心地使用浮点运算。</strong></p>\n",
            "tags": [
                "深入理解计算机系统",
                "CSAPP"
            ]
        }
    ]
}