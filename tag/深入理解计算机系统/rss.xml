<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;深入理解计算机系统&#34; tag</title>
        <link>https://maplelearc.github.io</link>
        <description>Maple的编程学习</description>
        <language>zh-CN</language>
        <pubDate>Wed, 05 Oct 2022 15:50:37 +0800</pubDate>
        <lastBuildDate>Wed, 05 Oct 2022 15:50:37 +0800</lastBuildDate>
        <category>MySQL</category>
        <category>数据库</category>
        <category>Lua</category>
        <category>算法</category>
        <category>数据结构</category>
        <category>深入理解计算机系统</category>
        <category>CSAPP</category>
        <category>计算机网络</category>
        <category>C#</category>
        <item>
            <guid isPermalink="true">https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/</guid>
            <title>CSAPP:第一章</title>
            <link>https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/</link>
            <category>深入理解计算机系统</category>
            <category>CSAPP</category>
            <pubDate>Wed, 05 Oct 2022 15:50:37 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;csapp第一章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#csapp第一章&#34;&gt;#&lt;/a&gt; 《CSAPP：第一章》&lt;/h1&gt;
&lt;h2 id=&#34;11-信息就是位上下文&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-信息就是位上下文&#34;&gt;#&lt;/a&gt; 1.1 信息就是位 + 上下文&lt;/h2&gt;
&lt;p&gt;程序的生命周期从源程序 (源文件) 开始。源程序实际上就是由 0 和 1 组成的位序列。&lt;/p&gt;
&lt;p&gt;一般 ASCII 标准来表示文本字符，实际上是用一个字节的整数值来表示一种字符。&lt;/p&gt;
&lt;p&gt;源文件中每个文本行都是以看不见的 &#39;\n&#39; 结束的。&lt;/p&gt;
&lt;p&gt;只由 ASCII 字符组成的文件成为&lt;strong&gt;文本文件&lt;/strong&gt;，其他都是&lt;strong&gt;二进制文件&lt;/strong&gt;。.cpp 文件就是文本文件。&lt;/p&gt;
&lt;p&gt;系统中的所有信息都是由一串比特（bit：位）表示的，区分不同数据对象的&lt;strong&gt;唯一方法&lt;/strong&gt;就是根据上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C 语言的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C 语言小而简单&lt;/li&gt;
&lt;li&gt;C 语言是为了实现 unix 而设计的&lt;/li&gt;
&lt;li&gt;C 语言与 unix 关系密切&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C 语言是系统级编程的首选，也非常适用于应用级程序。&lt;/p&gt;
&lt;h2 id=&#34;12-程序被其他程序翻译成不同的格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-程序被其他程序翻译成不同的格式&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.2&lt;/strong&gt; 程序被其他程序翻译成不同的格式&lt;/h2&gt;
&lt;p&gt;从源程序到目标程序要经历&lt;strong&gt;四个步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源程序被&lt;strong&gt;预处理器&lt;/strong&gt;处理得到&lt;strong&gt;修改了的源程序&lt;/strong&gt;（文本文件，hello.i）&lt;/li&gt;
&lt;li&gt;再由&lt;strong&gt;编译器&lt;/strong&gt;处理得到&lt;strong&gt;汇编程序&lt;/strong&gt;（文本文件，hello.s）&lt;/li&gt;
&lt;li&gt;汇编程序由&lt;strong&gt;汇编器&lt;/strong&gt;处理得到&lt;strong&gt;可重定位目标程序&lt;/strong&gt;（二进制文件，hello.o）&lt;/li&gt;
&lt;li&gt;最后由&lt;strong&gt;链接器&lt;/strong&gt;链接得到&lt;strong&gt;可执行目标程序&lt;/strong&gt;（二进制文件，hello）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;预处理阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预处理器根据 # 开头的命令修改原始的 c 程序。比如根据 #include 命令把头文件 stdio.h 的内容直接插入到程序文件中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如 printf 函数是一个标准 C 库函数，存在于 printf.o 中，这是一个单独的预编译好了的目标文件。链接器将其与汇编得到的二进制文件合并得到可执行目标文件。&lt;/p&gt;
&lt;h2 id=&#34;13-了解编译系统如何工作是大有用处的&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-了解编译系统如何工作是大有用处的&#34;&gt;#&lt;/a&gt; 1.3 了解编译系统如何工作是大有用处的&lt;/h2&gt;
&lt;p&gt;用处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化程序性能&lt;/li&gt;
&lt;li&gt;理解链接时出现的错误&lt;/li&gt;
&lt;li&gt;避免安全漏洞&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;14-处理器读并解释储存在内存中的指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#14-处理器读并解释储存在内存中的指令&#34;&gt;#&lt;/a&gt; 1.4 处理器读并解释储存在内存中的指令&lt;/h2&gt;
&lt;p&gt;shell 是一个命令行解释器，它输出一个提示符（&amp;gt;&amp;gt;），等待输入一个命令行，然后执行命令。如果输入的是可执行文件的名字，就运行该文件。&lt;/p&gt;
&lt;h3 id=&#34;141-系统的硬件组成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#141-系统的硬件组成&#34;&gt;#&lt;/a&gt; 1.4.1 系统的硬件组成&lt;/h3&gt;
&lt;p&gt;主要包括&lt;strong&gt;总线、I/O 设备、处理器、主存储器 **** 四个部分&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总线一次可以传输一个定长的字节块，称为字。64 位系统即总线一次可以传输 64 位（8 字节），这里一个字就是 8 字节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;I/O 设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个 I/O 设备通过一个&lt;strong&gt;控制器&lt;/strong&gt;或&lt;strong&gt;适配器&lt;/strong&gt;与 I/O 总线相连。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制器&lt;/strong&gt;是 I/O 设备本身或主板上的芯片组，&lt;strong&gt;适配器&lt;/strong&gt;则是一块插在主板上的卡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主存是由一组 ** 动态随机存取内存（DRAM）** 组成的。&lt;/p&gt;
&lt;p&gt;从逻辑上看，存储器是一个线性的字节数组，每个字节都有唯一的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;处理器是&lt;strong&gt;解释存储在主存中指令&lt;/strong&gt;的引擎。&lt;/p&gt;
&lt;p&gt;处理器的&lt;strong&gt;核心&lt;/strong&gt;是一个&lt;strong&gt;程序计数器（PC)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序计数器是一个大小为&lt;strong&gt;一个字&lt;/strong&gt;的存储设备，存储 CPU 即将执行的&lt;strong&gt;下一条指令的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;处理器就是在不断执行程序计数器指向的指令。每执行一条，程序计数器更新一次，指向下一条指令。&lt;/p&gt;
&lt;p&gt;处理器会按照 ** 指令执行模型（指令集架构）** 解释指令中的位并执行相应操作。&lt;/p&gt;
&lt;p&gt;每条指令的操作是围绕 ** 主存、寄存器文件、算数 / 逻辑单元（ALU）** 进行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寄存器文件&lt;/strong&gt;：单个字长，有唯一的名字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**ALU：** 计算新的数据和地址值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几个简单指令的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;加载&lt;/em&gt; *：从主存复制一个字或字节到寄存器，覆盖原来内容 **&lt;/li&gt;
&lt;li&gt;存储 **：从寄存器复制一个字或字节到主存，覆盖原来内容 **&lt;/li&gt;
&lt;li&gt;操作 **：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并把结果存到一个寄存器中 **&lt;/li&gt;
&lt;li&gt;跳转 **：从指令中抽取一个字复制到程序计数器中，覆盖原来内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区分处理器指令集架构和微体系架构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 指令集架构：** 每条机器指令的效果&lt;/li&gt;
&lt;li&gt;** 微体系架构：** 处理器实际上是如何实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;142-运行-hello-程序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#142-运行-hello-程序&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.4.2 运行 hello 程序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;执行目标文件时，shell 程序将位于磁盘目标文件中的字符逐个读入寄存器，然后放到主存中。之后处理器就开始执行目标文件的机器语言指令，从 main 程序开始。&lt;/p&gt;
&lt;p&gt;利用 ** 直接存储器存取（DMA）** 可以不通过寄存器，直接将数据从磁盘到达内存。&lt;/p&gt;
&lt;p&gt;以输出打印 hello world 为例，处理器将 hello world 的字节复制到寄存器，然后再复制到显示器，最后显示在屏幕上。&lt;/p&gt;
&lt;p&gt;** 整个流程：**&lt;strong&gt; 读取文件字符到寄存器 → 存储到主存  → 执行指令&lt;/strong&gt;  →  &lt;strong&gt;加载 helloworld 到寄存器 → 复制到显示器 → 显示&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;15-高速缓存至关重要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#15-高速缓存至关重要&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.5 高速缓存至关重要&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从主存读取一个字比磁盘快 &lt;strong&gt;1000 万&lt;/strong&gt;倍。&lt;/p&gt;
&lt;p&gt;从寄存器文件读取比主存块 &lt;strong&gt;100 倍&lt;/strong&gt;，并且差距还在加大。&lt;/p&gt;
&lt;p&gt;高速缓存（cache）用来解决处理器与主存间的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L1 高速缓存&lt;/strong&gt;位于 &lt;strong&gt;CPU&lt;/strong&gt; 上，容量为数万字节（&lt;strong&gt;几十 MB&lt;/strong&gt;）。L1 比 L2 快 &lt;strong&gt;5&lt;/strong&gt; 倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L2 高速缓存&lt;/strong&gt;通过&lt;strong&gt;一条特殊的总线&lt;/strong&gt;与 CPU 连接，容量为数十万到数百万字节（&lt;strong&gt;几百 MB 到 几 GB&lt;/strong&gt;）。L2 比 主存快 &lt;strong&gt;5~10&lt;/strong&gt; 倍&lt;/p&gt;
&lt;p&gt;新的系统还有 L3。&lt;/p&gt;
&lt;p&gt;通过让高速缓存里存放可能经常访问的数据，让大部分的内存操作都在高速缓存中完成。&lt;/p&gt;
&lt;h2 id=&#34;16-存储设备形成层次结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#16-存储设备形成层次结构&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.6 存储设备形成层次结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;存储器层次结构共 7 层，&lt;strong&gt;主要思想&lt;/strong&gt;是上一层的存储器作为低一层的高速缓存。&lt;/p&gt;
&lt;p&gt;从上到下，容量更大，运行更慢，每字节价格更便宜。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 层：寄存器&lt;/li&gt;
&lt;li&gt;1 层：L1 高速缓存 (SRAM)&lt;/li&gt;
&lt;li&gt;2 层：L2 高速缓存 (SRAM)&lt;/li&gt;
&lt;li&gt;3 层：L3 高速缓存（SRAM）&lt;/li&gt;
&lt;li&gt;4 层：主存（DRAM）&lt;/li&gt;
&lt;li&gt;5 层：本地二级存储（本地磁盘）&lt;/li&gt;
&lt;li&gt;6 层：远程二级存储（分布式文件系统，Web 服务器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;17-操作系统管理硬件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#17-操作系统管理硬件&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.7 操作系统管理硬件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;操作系统的&lt;strong&gt;两个基本功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;
&lt;li&gt;向应用程序提供简单一致的机制来控制复杂的低级硬件设备&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统所应用的&lt;strong&gt;三个基本的抽象概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：对处理器、主存和 I/O 设备的抽象表示&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt;：对主存和磁盘的抽象表示&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件&lt;/strong&gt;：对 I/O 设备的抽象表示&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;171-进程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#171-进程&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.7.1 进程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;** 进程：** 对操作系统正在运行的程序的一种抽象。&lt;/p&gt;
&lt;p&gt;** 并发运行：** 一个进程的指令和另一个进程的指令是交错执行的。&lt;/p&gt;
&lt;p&gt;一个系统可以同时运行多个进程，实际上这些进程是并发运行的。&lt;/p&gt;
&lt;p&gt;操作系统通过&lt;strong&gt;上下文切换&lt;/strong&gt;来实现并发运行。上下文是跟踪进程运行所需的所有&lt;strong&gt;状态信息&lt;/strong&gt;，可能存在于 PC、寄存器文件、主存等地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任何时刻，单处理器只能执行一个进程的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统&lt;strong&gt;内核&lt;/strong&gt;是操作系统代码常驻主存的部分，从一个进程到另一个进程的转换是由内核管理的。&lt;/p&gt;
&lt;p&gt;内核不是一个独立的进程，是一系列代码和数据结构的集合。&lt;/p&gt;
&lt;p&gt;当应用程序需要操作系统的某些操作时，就把控制权传递给内核，内核执行完操作后返回应用程序。&lt;/p&gt;
&lt;h3 id=&#34;172-线程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#172-线程&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.7.2 线程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一个进程由多个线程组成&lt;/strong&gt;，每个线程都运行在进程的上下文中，共享同样的代码和全局数据。&lt;/p&gt;
&lt;p&gt;多线程之间比多进程之间更容易共享数据，且线程一般来说比进程更高效。&lt;/p&gt;
&lt;h3 id=&#34;173-虚拟内存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#173-虚拟内存&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.7.3 虚拟内存&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;机器级程序将内存视为一个庞大的字节数组，称为&lt;strong&gt;虚拟内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内存的每个字节由地址来标识，所有可能地址的集合就是&lt;strong&gt;虚拟地址空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟内存使每个进程都以为自己独占了主存。每个进程看到的内存都是&lt;strong&gt;一致的&lt;/strong&gt;，即&lt;strong&gt;虚拟地址空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 linux 中，每个进程看到的虚拟地址空间由以下几个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序代码和数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆（运行时堆）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈（用户栈）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核虚拟内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址从低到高，最高层的&lt;strong&gt;内核虚拟内存&lt;/strong&gt;保存的是操作系统中的代码和数据，这部分每个进程都一样。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;程序代码和数据&lt;/em&gt; *&lt;/p&gt;
&lt;p&gt;对所有进程来说，代码都是从同一个固定地址开始，紧接着是与全局变量对应的数据区。代码和数据区都是按照可执行文件的内容初始化的。代码和数据区在进程开始运行时就被指定了大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而运行时堆是根据 malloc 和 free 函数的调用在运行时&lt;strong&gt;动态地&lt;/strong&gt;扩展和收缩的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址空间的中间部分用来存放共享库的代码和数据。如 C 标准库、数学库等都属于共享库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户栈和堆一样，在程序执行期间可以&lt;strong&gt;动态的扩展和收缩&lt;/strong&gt;，编译器用它来&lt;strong&gt;实现函数调用&lt;/strong&gt;。当调用函数时，栈增长，从函数返回时，栈收缩&lt;/p&gt;
&lt;h3 id=&#34;174-文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#174-文件&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.7.4 文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;文件就是&lt;strong&gt;字节序列&lt;/strong&gt;，仅此而已。&lt;/p&gt;
&lt;p&gt;每个 I/O 设备，包括磁盘、键盘、显示器、网络，都可以看成是文件。&lt;/p&gt;
&lt;h2 id=&#34;18-系统之间利用网络通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#18-系统之间利用网络通信&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.8 系统之间利用网络通信&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从一个单独的系统而言，网络可以视为一个 I/O 设备。&lt;/p&gt;
&lt;p&gt;以在一个远端服务器运行程序为例，在本地输入，在远端执行，执行结果发送回本地输出。&lt;/p&gt;
&lt;h2 id=&#34;19-重要主题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#19-重要主题&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.9 重要主题&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;191-amdahl-定律&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#191-amdahl-定律&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.9.1 Amdahl 定律&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Amdahl 定律的主要观点：要加速整个系统，必须提升全系统中相当大的部分。&lt;/p&gt;
&lt;h3 id=&#34;192-并发和并行&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#192-并发和并行&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.9.2 并发和并行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;区分并发与并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 并发：** 一个通用的概念，指一个同时具有多个活动的系统&lt;/li&gt;
&lt;li&gt;** 并行：** 用并发来使系统运行得更快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并行可以在多个抽象层次上运用。从高到低有以下三个层次&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 线程级并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统意义上的并发执行是通过单处理器在进程间快速切换&lt;strong&gt;模拟&lt;/strong&gt;出来的。&lt;/p&gt;
&lt;p&gt;多处理器系统由一个操作系统控制多个 CPU。结构如下&lt;/p&gt;
&lt;p&gt;​    &lt;img data-src=&#34;http://lgqimg.changzer.cn/image-20221005160155790.png&#34; alt=&#34;image-20221005160155790&#34; /&gt;&lt;/p&gt;
&lt;p&gt;L1 高速缓存被分为两个部分：一个保存最近取到的指令，一个存放数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超线程&lt;/strong&gt;又称&lt;strong&gt;同时多线程&lt;/strong&gt;，它允许一个 CPU 执行多个控制流。 CPU 有的硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件只有一份，比如浮点算术运算单元。常规 CPU 需要约 &lt;strong&gt;20000&lt;/strong&gt; 个时钟周期来切换线程，超线程 CPU 可以在&lt;strong&gt;单个周期&lt;/strong&gt;的基础上切换线程，比如一个线程在等待数据装在到高速缓存，CPU 就可以去执行另一个线程。&lt;/p&gt;
&lt;p&gt;i7 处理器每个核执行两个线程，所以是 &lt;strong&gt;4 核 8 线程&lt;/strong&gt;，8 个线程都并行执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 指令级并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每条指令从开始到结束一般需要 20 个或更多的时钟周期，通过指令级并行，可以实现每个周期 2~4 条指令的执行速率。&lt;/p&gt;
&lt;p&gt;如果比一个周期一条指令更快，就称为&lt;strong&gt;超标量处理器&lt;/strong&gt;，现在一般都是超标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 单指令、多数据并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最低层次上，现代处理器允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行，即 SIMD 并行。&lt;/p&gt;
&lt;h3 id=&#34;193-计算机系统中抽象的重要性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#193-计算机系统中抽象的重要性&#34;&gt;#&lt;/a&gt; &lt;strong&gt;1.9.3 计算机系统中抽象的重要性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​    &lt;img data-src=&#34;http://lgqimg.changzer.cn/image-20221005160217657.png&#34; alt=&#34;image-20221005160217657&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令集架构&lt;/strong&gt;是对 CPU 硬件的抽象，使用这个抽象，CPU 看起来好像一次只执行机器代码程序的一条指令，实际上底层硬件并行地执行多条指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;是对整个计算机系统的抽象，包括操作系统、处理器和程序。&lt;strong&gt;1.4.1 系统的硬件组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要包括&lt;strong&gt;总线、I/O 设备、处理器、主存储器 **** 四个部分&lt;/strong&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/</guid>
            <title>CSAPP:第二章</title>
            <link>https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/</link>
            <category>深入理解计算机系统</category>
            <category>CSAPP</category>
            <pubDate>Wed, 05 Oct 2022 15:50:37 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;csapp第二章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#csapp第二章&#34;&gt;#&lt;/a&gt; CSAPP: 第二章&lt;/h1&gt;
&lt;h2 id=&#34;2-信息的表示和处理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-信息的表示和处理&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2、信息的表示和处理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;计算机使用二值信号存储和表示信息&lt;/p&gt;
&lt;p&gt;当计算结果太大以至于不能表示时，就会产生&lt;strong&gt;溢出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;浮点数表示的精度有限，因而浮点运算是不可结合的。&lt;/p&gt;
&lt;p&gt;整数的表示范围小但是精确，浮点数表示的范围大但是是近似的。&lt;/p&gt;
&lt;p&gt;许多安全漏洞是由算术运算的微妙细节导致的。&lt;/p&gt;
&lt;h2 id=&#34;21-信息存储&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-信息存储&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1 信息存储&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;计算机一般使用字节作为最小的可寻址的内存单位。&lt;/p&gt;
&lt;p&gt;在机器级程序中不包含关于数据类型的信息。&lt;/p&gt;
&lt;p&gt;指针的值是某个存储块的第一个字节的&lt;strong&gt;虚拟地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个程序对象可以视为一个字节块。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;211-十六进制表示法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#211-十六进制表示法&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.1 十六进制表示法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;十六进制以 0x 开头。&lt;/p&gt;
&lt;p&gt;A：10；C:12；F：15&lt;/p&gt;
&lt;h3 id=&#34;212-字数据大小&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#212-字数据大小&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.2 字数据大小&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;每个计算机有对应的字长，虚拟地址用一个字来编码，所以&lt;strong&gt;字长决定了虚拟地址空间的大小&lt;/strong&gt;。&lt;strong&gt;64 位机器的指针类型长度为 8 字节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;32 位机器的虚拟地址空间为 &lt;strong&gt;4GB&lt;/strong&gt;，64 位字长的虚拟地址空间位 16 EB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int32_t&lt;/strong&gt; 和 &lt;strong&gt;int64_t&lt;/strong&gt; 类型分别为 4 字节和 8 字节，不受机器影响。使用确定大小的整数类型很有用。&lt;/p&gt;
&lt;p&gt;对 32 位和 64 位机器而言，char、short、int、long long 长度都是一样的，为  1，2，4，8。long 的长度不一样。&lt;/p&gt;
&lt;p&gt;float 和 double 的长度一样，分别为 4，8&lt;/p&gt;
&lt;p&gt;程序对 char 有无符号一般不敏感。&lt;/p&gt;
&lt;h3 id=&#34;213-寻址和字节顺序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#213-寻址和字节顺序&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.3 寻址和字节顺序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于跨越多字节的对象，它的地址是它所用字节中的&lt;strong&gt;最小地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种字节存储法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;小端法&lt;/strong&gt;：数字的低位在前（前就是最小地址）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大端法&lt;/strong&gt;：数字的高位在前&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多数 Intel 都是小端法，不是所有。&lt;/p&gt;
&lt;h3 id=&#34;214-表示字符串&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#214-表示字符串&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.4 表示字符串&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;C 语言字符串是以 null 字符结尾的字符数组，即 &#39;\0&#39;&lt;/p&gt;
&lt;p&gt;ASCII 字符适合编码英文文档。&lt;/p&gt;
&lt;p&gt;Unicode（UTF-8）使用 &lt;strong&gt;4 字节&lt;/strong&gt;表示字符，一些常用的字符只需要 1 或 2 个字节。所有 ASCII 字符在 UTF-8 中是一样的。&lt;/p&gt;
&lt;p&gt;JAVA 使用 UTF-8 来编码字符串。&lt;/p&gt;
&lt;h3 id=&#34;215-表示代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#215-表示代码&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.5 表示代码&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;二进制代码是&lt;strong&gt;不兼容&lt;/strong&gt;的，一般无法在不同机器间移植。&lt;/p&gt;
&lt;p&gt;从机器的角度看，&lt;strong&gt;程序就是一个字节序列&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;216-布尔代数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#216-布尔代数&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.6 布尔代数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;布尔代数&lt;/strong&gt;是在 0 和 1 基础上的定义&lt;/p&gt;
&lt;p&gt;可以把字节看作是一个长为 8 的&lt;strong&gt;位向量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;位向量的一个应用是表示有限集合。如位向量 [0110 1001] 表示集合 A = {0,3,5,6}。&lt;/p&gt;
&lt;h3 id=&#34;217-c-语言中的位级运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#217-c-语言中的位级运算&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.7 C 语言中的位级运算&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;位运算的常见应用是实现&lt;strong&gt;掩码&lt;/strong&gt;。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8 位。&lt;/p&gt;
&lt;p&gt;表达式 &lt;strong&gt;~0&lt;/strong&gt; 可以生成一个全 1 的掩码，不管机器的字大小是多少。&lt;/p&gt;
&lt;h3 id=&#34;218-c-语言中的逻辑运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#218-c-语言中的逻辑运算&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.8 C 语言中的逻辑运算&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;逻辑运算符 &amp;amp;&amp;amp; 和 || 如果第一个参数就能确定结果，就不再计算第二个参数&lt;/p&gt;
&lt;h3 id=&#34;219-c-语言中的移位运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#219-c-语言中的移位运算&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.1.9 C 语言中的移位运算&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;左移 k 位丢掉最高的 k 位，并在右端补 k 个 0。&lt;/p&gt;
&lt;p&gt;右移分为&lt;strong&gt;逻辑右移&lt;/strong&gt;和&lt;strong&gt;算术右移&lt;/strong&gt;。&lt;strong&gt;逻辑右移左端补 0，算术右移左端补最高有效位的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般都对有符号数使用算术右移，即补符号位的值。无符号数，&lt;strong&gt;只能是逻辑右移&lt;/strong&gt;，即补 0&lt;/p&gt;
&lt;h2 id=&#34;22-整数表示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-整数表示&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.2 整数表示&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;无符号表示与补码表示&lt;/p&gt;
&lt;p&gt;有符号数到无符号数的转换会产生漏洞，&lt;strong&gt;避免错误的方法之一是绝不使用无符号数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了 C 以外&lt;strong&gt;很少有语言支持无符号整数&lt;/strong&gt;，Java 就只支持有符号数&lt;/p&gt;
&lt;h3 id=&#34;221-整数数据类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#221-整数数据类型&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.2.1 整数数据类型&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 64 位系统上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i&lt;strong&gt;nt&lt;/strong&gt;：4 字节，可表示十进制数字位数：&lt;strong&gt;10 位（-20~20 亿以内）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;long long&lt;/strong&gt;：8 字节，可表示十进制数字位数：&lt;strong&gt;19 位（千亿亿级）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;long：8 字节&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;double&lt;/strong&gt;：8 字节，&lt;strong&gt;精度 15 位&lt;/strong&gt;，可表示十进制数字位数&lt;strong&gt; 308 位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;float&lt;/strong&gt;：4 字节，&lt;strong&gt;精度 6 位&lt;/strong&gt;，可表示十进制数字&lt;strong&gt; 38 位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;char&lt;/strong&gt;：&lt;strong&gt;-128~127&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;java 只支持有符号数。&lt;/p&gt;
&lt;h3 id=&#34;222-无符号数的编码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#222-无符号数的编码&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.2.2 无符号数的编码&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;无符号表示、补码表示与数据的映射都是双射，即一一对应。&lt;/p&gt;
&lt;h3 id=&#34;223-补码编码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#223-补码编码&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.2.3 补码编码&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;补码的定义实际就是&lt;strong&gt;将符号位解释为负权&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;C 库头文件  定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、UINT_MAX&lt;/p&gt;
&lt;p&gt;C 库头文件 中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.2.4 有符号数和无符号数之间的转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在有符号数与无符号数之间进行强制类型转换的结果是&lt;strong&gt;保持位值不变，只改变解释位的方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补码 x 转无符号数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x &amp;gt;= 0，值不变&lt;/li&gt;
&lt;li&gt;x &amp;lt; 0，转换后的值为 2^w + x&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;无符号数 x 转补码&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x &amp;lt;2^(w-1)，值不变&lt;/li&gt;
&lt;li&gt;x &amp;gt;= 2^(w-1)，转换后的值为 x - 2^w&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;225-c-语言中的有符号数和无符号数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#225-c-语言中的有符号数和无符号数&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.2.5 C 语言中的有符号数和无符号数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;C 语言中有符号数和无符号数相加减，有符号被转换成无符号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.2.6 扩展一个数字的位表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩展无符号数使用零扩展，即在最高位前加 0&lt;/p&gt;
&lt;p&gt;扩展有符号数使用符号扩展，即在最高位前加最高有效位的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.2.7 截断数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。&lt;/p&gt;
&lt;p&gt;对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。&lt;/p&gt;
&lt;h2 id=&#34;23-整数运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-整数运算&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.3 整数运算&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;231-无符号加法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#231-无符号加法&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.3.1 无符号加法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;考虑溢出，C 语言不会将溢出作为错误发出信号&lt;/p&gt;
&lt;p&gt;当 x+y &amp;gt;= 2^w，实际结果为 s = x+y-2^w&lt;/p&gt;
&lt;p&gt;对任意的 x+y，&lt;strong&gt;s = (x+y) % 2^w&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;** 溢出的结果：** 和小于两个加数&lt;/p&gt;
&lt;p&gt;** 检验溢出的方式：** 如果 &lt;strong&gt;s，说明溢出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无符号数的非&lt;/strong&gt;：~x = 2^w - x (x&amp;gt;0)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.3.2 补码加法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 x+y &amp;gt;= 2^(w-1)， s = x+y-2^w&lt;/p&gt;
&lt;p&gt;当 x+y &amp;lt;-2^(w-1)，s = x+y+2^w&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正溢出的结果是负数，负溢出的结果是正数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;** 检验溢出的方式：** 当 x,y&amp;gt;0 而 s&amp;lt;=0 是正溢出；当 x,y&amp;lt;0 而 s&amp;gt;=0 是负溢出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.3.3 补码的非&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x&lt;/p&gt;
&lt;p&gt;** 补码非的位级表示：**&lt;strong&gt; 对每一位求补，结果再加 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;** 计算补码非的第二种方法：** 假设 k 是最右边的 1 的位置，对 k 左边的所有位取反&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.3.4 无符号乘法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无符号乘法的积&lt;/strong&gt; &lt;strong&gt;m = (x*y) % 2^w&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;235-补码乘法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#235-补码乘法&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.3.5 补码乘法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可以认为补码乘法和无符号乘法的&lt;strong&gt;位级表示&lt;/strong&gt;是一样的&lt;/p&gt;
&lt;p&gt;C 语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补码乘法的积&lt;/strong&gt; &lt;strong&gt;m = (x*y) % 2^w&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.3.6 乘以常数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数机器上，整数乘法需要 &lt;strong&gt;10 个或更多&lt;/strong&gt;的时钟周期，而加法、减法、位级运算和移位只需要 1 个时钟周期&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译器对整数乘法进行优化的方式&lt;/strong&gt;：用&lt;strong&gt;移位和加法或减法&lt;/strong&gt;运算的组合来代替常数因子的乘法。&lt;/p&gt;
&lt;p&gt;左移 k 位等于乘以 2^k&lt;/p&gt;
&lt;p&gt;如 x * 14  =  (x&amp;lt;&amp;lt;3)+(x&amp;lt;&amp;lt;2)+(x&amp;lt;&amp;lt;1)   =   (x&amp;lt;&amp;lt;4)-(x&amp;lt;&amp;lt;2)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判断如何移动的方式&lt;/strong&gt;很简单：14 的位级表示为 1110，所以分别左移 3，2，1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.3.7 除以 2 的幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数机器上，整数除法更慢，需要 &lt;strong&gt;30 个或更多&lt;/strong&gt;的始终周期。&lt;/p&gt;
&lt;p&gt;（只有）除以 2 的幂可以用移位运算来代替，&lt;strong&gt;无符号采用&lt;strong&gt;&lt;strong&gt;逻辑右移&lt;/strong&gt;&lt;/strong&gt;，补码采用 **** 算术右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于有符号数而言，算术右移的结果相当于进行除法运算后&lt;strong&gt;向下舍入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;(x+(1&amp;lt;&amp;gt;k&lt;/strong&gt; 的结果相当于进行除法运算然后&lt;strong&gt;向零舍入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;p&gt;​                (x&amp;lt;0 ? x+(1&amp;lt;&amp;lt;k)-1 : x) &amp;gt;&amp;gt; k;&lt;/p&gt;
&lt;h3 id=&#34;238-关于整数运算的最后思考&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#238-关于整数运算的最后思考&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.3.8 关于整数运算的最后思考&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;补码使用了与无符号算术运算相同的位级实现&lt;/strong&gt;，包括加法、减法、乘法甚至除法。都有完全一样或非常类似的位级行为。&lt;/p&gt;
&lt;h2 id=&#34;24-浮点数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#24-浮点数&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.4 浮点数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;浮点数对于非常大，非常接近零，近似值计算都很有用&lt;/p&gt;
&lt;h3 id=&#34;241-二进制小数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#241-二进制小数&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.4.1 二进制小数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;小数的二进制表示法只能表示那些能够写为 &lt;strong&gt;x * 2^w&lt;/strong&gt; 的数，&lt;strong&gt;其他的数都是近似表示。x 必须可以由形如 2^i + 2^j + ... + 2^n 的多项式表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浮点运算的不精确性可能产生严重后果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;### 2.4.2 IEEE 浮点表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IEEE 浮点标准&lt;/strong&gt;的表示形式为：&lt;strong&gt;V = (-1)^S * M * 2^E&lt;/strong&gt;，它分为三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;符号&lt;/strong&gt;：&lt;strong&gt;S&lt;/strong&gt; 决定是负数还是正数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶码&lt;/strong&gt;：&lt;strong&gt;E&lt;/strong&gt; 的作用是对浮点数加权&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾数&lt;/strong&gt;：&lt;strong&gt;M&lt;/strong&gt; 是一个二进制小数，范围是 1~2-ε 或 0~1-ε&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在对浮点数的位编码&lt;/strong&gt;时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个单独的符号位编码直接编码 S&lt;/li&gt;
&lt;li&gt;k 位的&lt;strong&gt;阶码字段 e&lt;/strong&gt; 编码 E；float 中 k=8，double 中 &lt;strong&gt;k=11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;n 位的&lt;strong&gt;小数字段 f&lt;/strong&gt; 编码 M；float 中 n=23，double 中 &lt;strong&gt;n=52&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;E 和 M 的编码方式分为&lt;strong&gt;三种情况&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;** 规格化的值：** 阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;阶码字段解释方式：&lt;strong&gt;E = e - (2^(k-1)-1)&lt;/strong&gt;；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127&lt;/li&gt;
&lt;li&gt;小数字段解释方式：&lt;strong&gt;M = 1 + f&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非规格化的值&lt;/strong&gt;：阶码字段全为 0 时属于非规格化形式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;阶码字段解释方式：&lt;strong&gt;E = 1 - (2^(k-1)-1)&lt;/strong&gt;；&lt;strong&gt;与规格化值中 e = 1 时的 E 相同&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;小数字段解释方式：&lt;strong&gt;M = f&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 特殊值：** 阶码字段全为 1 时，分两种情况：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;小数字段全为 0：表示无穷&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;** 小数字段非零：表示 NaN。** 比如 ∞-∞ 的结果就返回 NaN&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;243-数字示例&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#243-数字示例&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.4.3 数字示例&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;0 有 +0.0 和 -0.0 两种表示方式&lt;/p&gt;
&lt;p&gt;最大非规格化数到最小规格化数的过渡是平滑的。&lt;/p&gt;
&lt;p&gt;浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升序负数降序）。&lt;/p&gt;
&lt;p&gt;浮点数可表示的数的分布是不均匀的，越接近零时越稠密&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几个特殊的值的位级表示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;+0.0 全为 0&lt;/li&gt;
&lt;li&gt;** 最小的正非规格化值：** 最低有效位为 1，其他为 0&lt;/li&gt;
&lt;li&gt;** 最大的非规格化值：** 小数字段全为 1，其他为 0&lt;/li&gt;
&lt;li&gt;** 最小的正规格化值：** 阶码字段最低位为 1，其他为 0&lt;/li&gt;
&lt;li&gt;** 最大的规格化值：** 阶码字段最低位为 0，符号位为 0，其他为 1&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;244-舍入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#244-舍入&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.4.4 舍入&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为范围和精度有限，浮点运算只能近似表示实数运算。&lt;/p&gt;
&lt;p&gt;在浮点数的近似匹配上，IEEE 浮点格式定义了&lt;strong&gt;四种舍入方式（默认第一种）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;向偶数舍入（向最接近的值舍入）&lt;/strong&gt;：非中间值 (0.5) 四舍五入，中间值向偶数舍入。&lt;/li&gt;
&lt;li&gt;向零舍入&lt;/li&gt;
&lt;li&gt;向下舍入&lt;/li&gt;
&lt;li&gt;向上舍入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;向偶数舍入可以计算一组数的平均数时避免统计偏差。&lt;/p&gt;
&lt;p&gt;实际上这种舍入是发生在二进制小数上的。&lt;/p&gt;
&lt;h3 id=&#34;245-浮点运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#245-浮点运算&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.4.5 浮点运算&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;IEEE 标准定义 1/-0 = -∞，1/+0 = +∞&lt;/p&gt;
&lt;p&gt;浮点运算是&lt;strong&gt;可交换不可结合也不可分配&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;浮点加法满足&lt;strong&gt;加法和乘法上的单调性&lt;/strong&gt;。如果 a&amp;gt;=b，则 x+a &amp;gt;= x+b&lt;/p&gt;
&lt;p&gt;缺乏结合性和分配性会使一些简单问题变得很复杂&lt;/p&gt;
&lt;h3 id=&#34;246-c-语言中的浮点数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#246-c-语言中的浮点数&#34;&gt;#&lt;/a&gt; &lt;strong&gt;2.4.6 C 语言中的浮点数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 int、float、double 间进行&lt;strong&gt;强制类型转换时的几种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;int 到 float：不会溢出，可能舍入&lt;/li&gt;
&lt;li&gt;int 或 float 到 double：不会溢出也不会舍入&lt;/li&gt;
&lt;li&gt;double 到 float：可能溢出和舍入&lt;/li&gt;
&lt;li&gt;**float 或 double 到 int：** 向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，转变结果都为 [1000]，因此一个正浮点可能得到一个负整数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;把大的浮点数转换为整数是一种常见的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要小心地使用浮点运算。&lt;/strong&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
