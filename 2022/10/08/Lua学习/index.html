<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://maplelearc.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://maplelearc.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://maplelearc.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Lua"><link rel="canonical" href="https://maplelearc.github.io/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/"><meta name="description" content="Lua 入门学习   🍁Lua 基本语法  交互式编程 Lua 提供了人交互式编程模式。可以在命令行中输出程序并立即查看效果 Lua 交互式编程通过命令 lua -i 或 lua 来启用： $ lua -i $ lua Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio &gt;  在命令行中，输入以下命令： &gt; print(&quot;Hell"><meta property="og:type" content="article"><meta property="og:title" content="Lua 入门学习"><meta property="og:url" content="https://maplelearc.github.io/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/index.html"><meta property="og:site_name"><meta property="og:description" content="Lua 入门学习   🍁Lua 基本语法  交互式编程 Lua 提供了人交互式编程模式。可以在命令行中输出程序并立即查看效果 Lua 交互式编程通过命令 lua -i 或 lua 来启用： $ lua -i $ lua Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio &gt;  在命令行中，输入以下命令： &gt; print(&quot;Hell"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545745294943-c022acad-e773-4c4e-a469-fdf7b8517204.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545746389947-7897ad1a-bbd1-4476-abe4-5f9ea9530fb0.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545793869721-221c9099-efbc-4138-a2b0-1d5ecb0710d9.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545793890024-9bf3634c-bced-4a3b-a03b-8155d389d483.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545793918054-299b32a1-7e74-465f-9ad6-6c46aa29ad3c.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545794105298-442f3ac5-fbe0-4f54-87c0-324dd4c9c761.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545795069201-5fce3157-e13f-4f9f-b0d0-e192ad94e769.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545795441489-29359564-29c0-4153-9d50-4844cce2e22c.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545795625575-64b9f249-ad85-4d9f-862a-5cd0ffcbb041.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545795674871-1b606327-d0f9-42a6-b2d4-9d80989d0922.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545795704210-35cebb75-bc38-457b-98f5-648a9cb680d8.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545795776591-cf111597-927b-4ea3-af19-15f56fee05b2.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545796915099-182b544e-343b-4338-827b-16d5ce9807ff.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545796934445-08762e3c-8245-4964-ba85-d2469ae31630.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545796955997-b3a7dee8-81f8-42ce-9631-1f0e30b15143.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545796993558-cd2c7425-bff9-46c2-96f7-40ab6574733b.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545799061644-a6952d51-146a-4331-a0f6-2eeb9c40ac00.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545799123960-edb58671-3992-4e1c-9e3d-4c84aac76664.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545804695245-6b61a099-baec-4980-9a69-bec0849f2970.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545813715108-a8814d1f-7da1-4f70-943f-851d726b0969.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/1545814144758-2c44ef30-bb9e-46b1-acb7-49d785d58245.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/image-20221020215349667.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/image-20221020220223782.png"><meta property="og:image" content="http://lgqimg.changzer.cn/img/image-20221028193248563.png"><meta property="article:published_time" content="2022-10-08T09:41:18.000Z"><meta property="article:modified_time" content="2022-10-29T09:37:00.814Z"><meta property="article:author" content="Maple"><meta property="article:tag" content="Lua"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://lgqimg.changzer.cn/img/1545745294943-c022acad-e773-4c4e-a469-fdf7b8517204.png"><title>Lua 入门学习 - Lua - 计算机语言学习 | Maple Blog = = 与君初相识，犹如故人归</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Lua 入门学习</h1><div class="meta"><span class="item" title="创建时间：2022-10-08 17:41:18"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-08T17:41:18+08:00">2022-10-08</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Maple Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicli9lfebj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="item" rel="index" title="分类于 计算机语言学习"><span itemprop="name">计算机语言学习</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Lua/" itemprop="item" rel="index" title="分类于 Lua"><span itemprop="name">Lua</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://maplelearc.github.io/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar(1).png"><meta itemprop="name" content="Maple"><meta itemprop="description" content="与君初相识，犹如故人归, Maple 的编程学习"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h1 id="lua-入门学习"><a class="markdownIt-Anchor" href="#lua-入门学习"></a> Lua 入门学习</h1><hr><h2 id="lua-基本语法"><a class="markdownIt-Anchor" href="#lua-基本语法"></a> 🍁Lua 基本语法</h2><h3 id="交互式编程"><a class="markdownIt-Anchor" href="#交互式编程"></a> 交互式编程</h3><p>Lua 提供了人交互式编程模式。可以在命令行中输出程序并立即查看效果<br>Lua 交互式编程通过命令 lua -i 或 lua 来启用：</p><pre class="highlight"><code class="shell"><span class="hljs-meta">$</span><span class="bash"> lua -i</span>
<span class="hljs-meta">$</span><span class="bash"> lua Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio</span>
<span class="hljs-meta">&gt;</span>
</code></pre><p>在命令行中，输入以下命令：</p><pre class="highlight"><code class="shell"><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello world!"</span>)</span>
</code></pre><p>按下回车，得到以下结果：</p><pre class="highlight"><code class="shell"><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello World！"</span>)</span>
Hello World！
<span class="hljs-meta">&gt;</span>
</code></pre><h3 id="脚本编程"><a class="markdownIt-Anchor" href="#脚本编程"></a> 脚本编程</h3><p>我们可以将 Lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，如我们将如下代码存储在名为 hello.lua 的脚本文件中：</p><pre class="highlight"><code class="shell">print("Hello World！")
</code></pre><p>使用 lua 名执行以上脚本，输出结果为：</p><pre class="highlight"><code class="shell"><span class="hljs-meta">$</span><span class="bash"> lua test.lua</span>
Hello World！
</code></pre><p>我们也可以将代码修改为如下形式来执行脚本（在开头添加：#!/usr/local/bin/lua）：</p><pre class="highlight"><code class="shell"><span class="hljs-meta">#</span><span class="bash">!/usr/<span class="hljs-built_in">local</span>/bin/lua</span>
print("Hello World！")
</code></pre><p>以上代码中，我们指定了 Lua 的解释器 /usr/local/bin directory。加上 # 号标记解释器会忽略它。接下来我们为脚本添加可执行权限，并执行：</p><pre class="highlight"><code class="shell">./test.lua
Hello World！
</code></pre><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><h4 id="单行注释"><a class="markdownIt-Anchor" href="#单行注释"></a> 单行注释</h4><p>两个减号是单行注释</p><pre class="highlight"><code class="lua"><span class="hljs-comment">--</span>
</code></pre><h4 id="多行注释"><a class="markdownIt-Anchor" href="#多行注释"></a> 多行注释</h4><pre class="highlight"><code>--[[
多行注释
多行注释
--]]
</code></pre><h3 id="标示符"><a class="markdownIt-Anchor" href="#标示符"></a> 标示符</h3><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。最好不要使用下划线加大写字母的标示符，因为 Lua 的保留字也是这样的。</p><p>Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Test 与 test 是两个不同的标示符。以下列出了一些正确的标示符：</p><pre class="highlight"><code class="lua">mohd         zara      abc     move_name    a_123
myname50     _temp     j       a23b9        retVal
</code></pre><h4 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h4><p>以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545745294943-c022acad-e773-4c4e-a469-fdf7b8517204.png" alt="img"></p><p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p><h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3><p>在默认情况下，变量总是认为是全局的。全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p><pre class="highlight"><code class="shell"><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">print</span>(b)</span>
nil
<span class="hljs-meta">&gt;</span><span class="bash"> b=10</span>
<span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">print</span>(b)</span>
10
<span class="hljs-meta">&gt;</span>
</code></pre><p>如果你想删除一个全局变量，只需要将变量赋值为 nil。</p><pre class="highlight"><code class="shell">b = nil
print(b)      --&gt; nil
</code></pre><p>这样变量 b 就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于 nil 时，这个变量即存在。</p><hr><h2 id="lua-数据类型"><a class="markdownIt-Anchor" href="#lua-数据类型"></a> 🍁Lua 数据类型</h2><p>Lua 是动态数据类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p><p><img data-src="http://lgqimg.changzer.cn/img/1545746389947-7897ad1a-bbd1-4476-abe4-5f9ea9530fb0.png" alt="img"></p><p>我们可以使用 type 函数测试给定变量或者值的类型：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">"Hello world"</span>))      <span class="hljs-comment">--&gt; string</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">10.4</span>*<span class="hljs-number">3</span>))             <span class="hljs-comment">--&gt; number</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">print</span>))              <span class="hljs-comment">--&gt; function</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>))               <span class="hljs-comment">--&gt; function</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>))               <span class="hljs-comment">--&gt; boolean</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">nil</span>))                <span class="hljs-comment">--&gt; nil</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>(X)))            <span class="hljs-comment">--&gt; string</span>
</code></pre><h3 id="nil空"><a class="markdownIt-Anchor" href="#nil空"></a> nil(空)</h3><p>nil 表示一个没有任何有效值，它只有一个值–nil，例如打印一个没有赋值的变量，就会输出一个 nil 值：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))
</code></pre><p>结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-literal">nil</span>
</code></pre><p>对于全局变量和 table，nil 还有一个“删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉。</p><pre class="highlight"><code class="lua">tab1 = &#123; key1 = <span class="hljs-string">"val1"</span>, key2 = <span class="hljs-string">"val2"</span>, <span class="hljs-string">"val3"</span> &#125;
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tab1) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(k .. <span class="hljs-string">" - "</span> .. v)
<span class="hljs-keyword">end</span>
 <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>)
tab1.key1 = <span class="hljs-literal">nil</span>
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tab1) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(k .. <span class="hljs-string">" - "</span> .. v)
<span class="hljs-keyword">end</span>
</code></pre><p>结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>-val3
key1-val1
key2-val2


<span class="hljs-number">1</span>-val3
key2-val2
</code></pre><p>nil 作比较时应该加上双引号 &quot;：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">type</span>(x)
<span class="hljs-built_in">type</span>(x)==<span class="hljs-literal">nil</span>
<span class="hljs-built_in">type</span>(x)==<span class="hljs-string">"nil"</span>
</code></pre><p>结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-literal">nil</span>
<span class="hljs-literal">false</span>
<span class="hljs-literal">true</span>
</code></pre><h3 id="boolean"><a class="markdownIt-Anchor" href="#boolean"></a> boolean</h3><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是&quot;假&quot;，其他的都为&quot;真&quot;:</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">nil</span>))

<span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"至少有一个是true"</span>)
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"false和nil都为false"</span>)
<span class="hljs-keyword">end</span>
</code></pre><p>执行结果为：</p><pre class="highlight"><code class="lua">boolean
boolean
<span class="hljs-literal">nil</span>
<span class="hljs-literal">false</span>和<span class="hljs-literal">nil</span>都为<span class="hljs-literal">false</span>
</code></pre><h3 id="number数字"><a class="markdownIt-Anchor" href="#number数字"></a> number(数字)</h3><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">2</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">2.2</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">0.2</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">2e+1</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">0.2e-1</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">7.8263692594256e-06</span>))
</code></pre><p>执行结果为:</p><pre class="highlight"><code class="lua">number
number
number
number
number
number
</code></pre><h3 id="string字符串"><a class="markdownIt-Anchor" href="#string字符串"></a> string(字符串)</h3><p>字符串由一对双引号或单引号来表示。</p><pre class="highlight"><code class="lua">string1 = <span class="hljs-string">"this is string1"</span>
string2 = <span class="hljs-string">'this is string2'</span>
</code></pre><p>也可以用 2 个方括号 “[[]]” 来表示&quot;一块&quot;字符串</p><pre class="highlight"><code class="lua">html = <span class="hljs-string">[[
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;a href="http://www.baidu.com/"&gt;百度&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
]]</span>
<span class="hljs-built_in">print</span>(html)
</code></pre><p>执行结果为：</p><pre class="highlight"><code class="lua">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;a href=<span class="hljs-string">"http://www.baidu.com/"</span>&gt;百度&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">"2"</span>+<span class="hljs-number">6</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"2"</span>+<span class="hljs-string">"6"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"2+6"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"-2e2"</span>*<span class="hljs-string">"6"</span>)
</code></pre><p>执行以上代码为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">8</span>
<span class="hljs-number">8</span>
<span class="hljs-number">2</span>+<span class="hljs-number">6</span>
<span class="hljs-number">-1200</span>
</code></pre><p>若是执行下面的代码：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">"error"</span> + <span class="hljs-number">1</span>)
</code></pre><p>则会报错。Lua 中字符串连接使用的是<code>..</code></p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">"a"</span> .. <span class="hljs-string">'b'</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-number">157</span> .. <span class="hljs-number">428</span>)
</code></pre><p>执行结果为：</p><pre class="highlight"><code class="lua">ab
<span class="hljs-number">157428</span>
</code></pre><p>使用**#**来计算字符串的长度，放在字符串的前面：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">len</span> = <span class="hljs-string">"www.baidu.com"</span>
<span class="hljs-built_in">print</span>(#<span class="hljs-built_in">len</span>)
<span class="hljs-built_in">print</span>(#<span class="hljs-string">"ww.baidu.com"</span>)
</code></pre><p>执行结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">13</span>
<span class="hljs-number">13</span>
</code></pre><h3 id="table表"><a class="markdownIt-Anchor" href="#table表"></a> table(表)</h3><p>在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 创建一个空的 table</span>
<span class="hljs-keyword">local</span> tbl1 = &#123;&#125;

<span class="hljs-comment">-- 直接初始表</span>
<span class="hljs-keyword">local</span> tbl2 = &#123;<span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"grape"</span>&#125;
</code></pre><p>Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。</p><pre class="highlight"><code class="lua">a = &#123;&#125;
a[<span class="hljs-string">"key"</span>] = <span class="hljs-string">"value"</span>
key = <span class="hljs-number">10</span>
a[key] = <span class="hljs-number">22</span>
a[key] = a[key] + <span class="hljs-number">11</span>
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(k .. <span class="hljs-string">" : "</span> .. v)
<span class="hljs-keyword">end</span>
</code></pre><p>脚本执行结果为：</p><pre class="highlight"><code class="lua">key : value
<span class="hljs-number">10</span> : <span class="hljs-number">30</span>
</code></pre><p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">local</span> tbl = &#123;<span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"grape"</span>&#125;
<span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tbl) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Key"</span>, key)
<span class="hljs-keyword">end</span>
</code></pre><p>脚本执行结果为：</p><pre class="highlight"><code class="lua">Key    <span class="hljs-number">1</span>
Key    <span class="hljs-number">2</span>
Key    <span class="hljs-number">3</span>
Key    <span class="hljs-number">4</span>
</code></pre><p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p><pre class="highlight"><code class="lua">a3 = &#123;&#125;
<span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> <span class="hljs-keyword">do</span>
    a3[i] = i
<span class="hljs-keyword">end</span>
a3[<span class="hljs-string">"key"</span>] = <span class="hljs-string">"val"</span>
<span class="hljs-built_in">print</span>(a3[<span class="hljs-string">"key"</span>])
<span class="hljs-built_in">print</span>(a3[<span class="hljs-string">"none"</span>])
</code></pre><p>脚本执行结果：</p><pre class="highlight"><code class="lua">val
<span class="hljs-literal">nil</span>
</code></pre><h3 id="function函数"><a class="markdownIt-Anchor" href="#function函数"></a> function(函数)</h3><p>在 Lua 中，函数是被看作是&quot;第一类值（First-Class Value）&quot;，函数可以存在变量里:</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial1</span><span class="hljs-params">(n)</span></span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> n * factorial1(n - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(factorial1(<span class="hljs-number">5</span>))
factorial2 = factorial1
<span class="hljs-built_in">print</span>(factorial2(<span class="hljs-number">5</span>))
</code></pre><p>脚本执行结果为：</p><pre class="highlight"><code>120
120
</code></pre><p>function 可以以匿名函数（anonymous function）的方式通过参数传递:</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testFun</span><span class="hljs-params">(tab,fun)</span></span>
    <span class="hljs-keyword">for</span> k ,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tab) <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(fun(k,v));
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

tab=&#123;key1=<span class="hljs-string">"val1"</span>,key2=<span class="hljs-string">"val2"</span>&#125;;
testFun(tab,
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key,val)</span></span><span class="hljs-comment">--匿名函数</span>
    <span class="hljs-keyword">return</span> key..<span class="hljs-string">"="</span>..val;
<span class="hljs-keyword">end</span>
);
</code></pre><p>脚本执行结果为：</p><pre class="highlight"><code class="lua">key1 = val1
key2 = val2
</code></pre><h3 id="thread线程"><a class="markdownIt-Anchor" href="#thread线程"></a> thread(线程)</h3><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p><p>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p><h3 id="userdata自定义类型"><a class="markdownIt-Anchor" href="#userdata自定义类型"></a> userdata(自定义类型)</h3><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><hr><h2 id="lua-变量"><a class="markdownIt-Anchor" href="#lua-变量"></a> 🍁Lua 变量</h2><p>变量在使用前，必须在代码中进行声明，即创建该变量。</p><p>编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。</p><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p><ul><li><p>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p></li><li><p>局部变量的作用域为从声明位置开始到所在语句块结束。</p></li><li><p>变量的默认值均为 nil。</p></li></ul><pre class="highlight"><code class="lua">a = <span class="hljs-number">5</span>               <span class="hljs-comment">-- 全局变量</span>
<span class="hljs-keyword">local</span> b = <span class="hljs-number">5</span>         <span class="hljs-comment">-- 局部变量</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">joke</span><span class="hljs-params">()</span></span>
    c = <span class="hljs-number">5</span>           <span class="hljs-comment">-- 全局变量</span>
    <span class="hljs-keyword">local</span> d = <span class="hljs-number">6</span>     <span class="hljs-comment">-- 局部变量</span>
<span class="hljs-keyword">end</span>

joke()
<span class="hljs-built_in">print</span>(c,d)          <span class="hljs-comment">--&gt; 5 nil</span>

<span class="hljs-keyword">do</span>
    <span class="hljs-keyword">local</span> a = <span class="hljs-number">6</span>     <span class="hljs-comment">-- 局部变量</span>
    b = <span class="hljs-number">6</span>           <span class="hljs-comment">-- 对局部变量重新赋值</span>
    <span class="hljs-built_in">print</span>(a,b);     <span class="hljs-comment">--&gt; 6 6</span>
<span class="hljs-keyword">end</span>

<span class="hljs-built_in">print</span>(a,b)      <span class="hljs-comment">--&gt; 5 6</span>
</code></pre><p>执行以上实例输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">5</span>    <span class="hljs-literal">nil</span>
<span class="hljs-number">6</span>    <span class="hljs-number">6</span>
<span class="hljs-number">5</span>    <span class="hljs-number">6</span>
</code></pre><h3 id="赋值语句"><a class="markdownIt-Anchor" href="#赋值语句"></a> 赋值语句</h3><p>赋值是改变一个变量的值和改变表域的最基本的方法。</p><pre class="highlight"><code class="lua">a = <span class="hljs-string">"hello"</span> .. <span class="hljs-string">"world"</span>
t.n = t.n + <span class="hljs-number">1</span>
</code></pre><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><pre class="highlight"><code class="lua">a, b = <span class="hljs-number">10</span>, <span class="hljs-number">2</span>*x       &lt;<span class="hljs-comment">--&gt;       a=10; b=2*x</span>
</code></pre><p>遇到赋值语句 Lua 会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p><pre class="highlight"><code class="lua">x, y = y, x                     <span class="hljs-comment">-- swap 'x' for 'y'</span>
a[i], a[j] = a[j], a[i]         <span class="hljs-comment">-- swap 'a[i]' for 'a[j]'</span>
</code></pre><p>当变量个数和值的个数不一致时，Lua 会一直以变量个数为基础采取以下策略：</p><pre class="highlight"><code class="lua">a. 变量个数 &gt; 值的个数             按变量个数补足<span class="hljs-literal">nil</span>
b. 变量个数 &lt; 值的个数             多余的值会被忽略
</code></pre><p>例如：</p><pre class="highlight"><code class="lua">a, b, c = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
<span class="hljs-built_in">print</span>(a,b,c)             <span class="hljs-comment">--&gt; 0   1   nil</span>

a, b = a+<span class="hljs-number">1</span>, b+<span class="hljs-number">1</span>, b+<span class="hljs-number">2</span>     <span class="hljs-comment">-- value of b+2 is ignored</span>
<span class="hljs-built_in">print</span>(a,b)               <span class="hljs-comment">--&gt; 1   2</span>

a, b, c = <span class="hljs-number">0</span>
<span class="hljs-built_in">print</span>(a,b,c)             <span class="hljs-comment">--&gt; 0   nil   nil</span>
</code></pre><p>多值赋值经常用来交换变量，或将函数调用返回给变量：</p><pre class="highlight"><code class="lua">a, b = f()
</code></pre><p>f()返回两个值，第一个赋给 a，第二个赋给 b。</p><p>应该尽可能的使用局部变量，有两个好处：1. 避免命名冲突。2. 访问局部变量的速度比全局变量更快。</p><h3 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h3><p>对 table 的索引使用方括号 [];Lua 也提供了 . 操作。</p><pre class="highlight"><code class="lua">t[i]
t.i                 <span class="hljs-comment">-- 当索引为字符串类型时的一种简化写法</span>
gettable_event(t,i) <span class="hljs-comment">-- 采用索引访问本质上是一个类似这样的函数调用</span>
</code></pre><p>例如:</p><pre class="highlight"><code class="lua">site = &#123;&#125;
site[<span class="hljs-string">"key"</span>] = <span class="hljs-string">"www.baidu.cc"</span>
<span class="hljs-built_in">print</span>(site[<span class="hljs-string">"key"</span>])
<span class="hljs-built_in">print</span>(site.key)
</code></pre><p>结果为：</p><pre class="highlight"><code class="lua">www.baidu.cc
www.baidu.cc
</code></pre><hr><h2 id="lua-循环"><a class="markdownIt-Anchor" href="#lua-循环"></a> 🍁Lua 循环</h2><p>很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。</p><p>一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。</p><p>循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。</p><p>循环语句是由循环体及循环的终止条件两部分组成的。</p><p><img data-src="http://lgqimg.changzer.cn/img/1545793869721-221c9099-efbc-4138-a2b0-1d5ecb0710d9.png" alt="img"></p><p>Lua 语言提供了以下几种循环处理方式：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545793890024-9bf3634c-bced-4a3b-a03b-8155d389d483.png" alt="img"></p><p><strong>循环控制语句</strong></p><p>循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。</p><p>Lua 支持以下循环控制语句：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545793918054-299b32a1-7e74-465f-9ad6-6c46aa29ad3c.png" alt="img"></p><p><strong>无限循环</strong></p><p>在循环体中如果条件永远为 true 循环语句就会永远执行下去，以下以 while 循环为例：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> )
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"循环将永远执行下去"</span>)
<span class="hljs-keyword">end</span>
</code></pre><h3 id="while-循环"><a class="markdownIt-Anchor" href="#while-循环"></a> while 循环</h3><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><p>Lua 编程语言中 while 循环语法：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">while</span>(condition)
<span class="hljs-keyword">do</span>
    statements
<span class="hljs-keyword">end</span>
</code></pre><p>statements(循环体语句) 可以是一条或多条语句，condition(条件) 可以是任意表达式，在 condition(条件) 为 true 时执行循环体语句。 流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545794105298-442f3ac5-fbe0-4f54-87c0-324dd4c9c761.png" alt="img"></p><p>在以上流程图中我们可以看出在 condition(条件)为 false 时会跳过当前循环并开始脚本执行紧接着的语句。</p><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><p>以下实例循环输出 a 的值：</p><pre class="highlight"><code class="lua">a=<span class="hljs-number">10</span>
<span class="hljs-keyword">while</span>( a &lt; <span class="hljs-number">20</span> )
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为:"</span>, a)
   a = a+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>
</code></pre><p>执行以上代码，输出结果如下：</p><pre class="highlight"><code>a 的值为:    10
a 的值为:    11
a 的值为:    12
a 的值为:    13
a 的值为:    14
a 的值为:    15
a 的值为:    16
a 的值为:    17
a 的值为:    18
a 的值为:    19
</code></pre><h3 id="for-循环"><a class="markdownIt-Anchor" href="#for-循环"></a> for 循环</h3><p>Lua 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。</p><p>Lua 编程语言中 for 语句有两大类：：</p><ul><li><p>数值 for 循环</p></li><li><p>泛型 for 循环</p></li></ul><h4 id="数值-for-循环"><a class="markdownIt-Anchor" href="#数值-for-循环"></a> 数值 for 循环</h4><pre class="highlight"><code class="lua"><span class="hljs-keyword">for</span> var=exp1,exp2,exp3 <span class="hljs-keyword">do</span>
    &lt;执行体&gt;
<span class="hljs-keyword">end</span>
</code></pre><p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次&quot;执行体&quot;。exp3 是可选的，如果不指定，默认为 1。</p><ul><li><code>var</code>首先执行，执行一次。此步骤允许声明和初始化任何循环控制变量</li><li>接下来执行<code>exp2</code>。 这是循环继续执行的最大值或最小值。 它在内部创建条件检查，以比较初始值和最大/最小值。</li><li>在执行<code>for</code>循环体之后，控制流会跳回到<code>exp3</code>语句。此语句用于更新循环控制变量。</li><li>再次评估条件。 如果为真，则循环执行并且过程自身重复(循环体，然后递增步骤，然后再次调节)。 条件变为<code>false</code>后，<code>for</code>循环终止。</li></ul><h5 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h5><pre class="highlight"><code class="lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,f(x) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(i)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">for</span> i=<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(i)
<span class="hljs-keyword">end</span>
</code></pre><p>for 的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的 f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p><p>验证如下:</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"function"</span>)
    <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,f(<span class="hljs-number">5</span>) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(i)
<span class="hljs-keyword">end</span>
</code></pre><p>以上实例输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span>
1
2
3
4
5
6
7
8
9
10
</span></code></pre><h4 id="泛型-for-循环"><a class="markdownIt-Anchor" href="#泛型-for-循环"></a> 泛型 for 循环</h4><p>泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach 语句。Lua 编程语言中泛型 for 循环语法格式:</p><pre class="highlight"><code class="lua"><span class="hljs-comment">--打印数组a的所有值</span>
<span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a)
    <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(v)
<span class="hljs-keyword">end</span>
</code></pre><p>i 是数组索引值，v 是对应索引的数组元素值。ipairs 是 Lua 提供的一个迭代器函数，用来迭代数组。</p><h5 id="实例-2"><a class="markdownIt-Anchor" href="#实例-2"></a> 实例</h5><pre class="highlight"><code class="lua">days = &#123;<span class="hljs-string">"Suanday"</span>,<span class="hljs-string">"Monday"</span>,<span class="hljs-string">"Tuesday"</span>,<span class="hljs-string">"Wednesday"</span>,<span class="hljs-string">"Thursday"</span>,<span class="hljs-string">"Friday"</span>,<span class="hljs-string">"Saturday"</span>&#125;
<span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(days)
<span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(v)
<span class="hljs-keyword">end</span>
</code></pre><p>以上实例输出结果为：</p><pre class="highlight"><code class="lua">Suanday
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
</code></pre><h3 id="repeatuntil-循环"><a class="markdownIt-Anchor" href="#repeatuntil-循环"></a> repeat…until 循环</h3><p>Lua 编程语言中 repeat…until 循环语句不同于 for 和 while 循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断。</p><h4 id="语法-2"><a class="markdownIt-Anchor" href="#语法-2"></a> 语法</h4><p>Lua 编程语言中 repeat…until 循环语法格式:</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">repeat</span>
   statements
<span class="hljs-keyword">until</span>( condition )
</code></pre><p>我们注意到循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。</p><p>如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行。</p><p>Lua repeat…until 循环流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795069201-5fce3157-e13f-4f9f-b0d0-e192ad94e769.png" alt="img"></p><h4 id="实例-3"><a class="markdownIt-Anchor" href="#实例-3"></a> 实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 变量定义 --]</span>
a = <span class="hljs-number">10</span>
<span class="hljs-comment">--[ 执行循环 --]</span>
<span class="hljs-keyword">repeat</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a的值为:"</span>, a)
   a = a + <span class="hljs-number">1</span>
<span class="hljs-keyword">until</span>( a &gt; <span class="hljs-number">15</span> ）
</code></pre><p>执行以上代码，程序输出结果为：</p><pre class="highlight"><code class="lua">a的值为:    <span class="hljs-number">10</span>
a的值为:    <span class="hljs-number">11</span>
a的值为:    <span class="hljs-number">12</span>
a的值为:    <span class="hljs-number">13</span>
a的值为:    <span class="hljs-number">14</span>
a的值为:    <span class="hljs-number">15</span>
</code></pre><h3 id="嵌套循环"><a class="markdownIt-Anchor" href="#嵌套循环"></a> 嵌套循环</h3><h4 id="语法-3"><a class="markdownIt-Anchor" href="#语法-3"></a> 语法</h4><p>Lua 编程语言中 <code>for</code> 循环嵌套语法格式:</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">for</span> init,<span class="hljs-built_in">max</span>/<span class="hljs-built_in">min</span> value, increment
<span class="hljs-keyword">do</span>
   <span class="hljs-keyword">for</span> init,<span class="hljs-built_in">max</span>/<span class="hljs-built_in">min</span> value, increment
   <span class="hljs-keyword">do</span>
      statements
   <span class="hljs-keyword">end</span>
   statements
<span class="hljs-keyword">end</span>
</code></pre><p>Lua 编程语言中 <code>while</code> 循环嵌套语法格式:</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">while</span>(condition)
<span class="hljs-keyword">do</span>
   <span class="hljs-keyword">while</span>(condition)
   <span class="hljs-keyword">do</span>
      statements
   <span class="hljs-keyword">end</span>
   statements
<span class="hljs-keyword">end</span>
</code></pre><p>Lua 编程语言中 <code>repeat...until</code> 循环嵌套语法格式:</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">repeat</span>
   statements
   <span class="hljs-keyword">repeat</span>
      statements
   <span class="hljs-keyword">until</span>( condition )
<span class="hljs-keyword">until</span>( condition )
</code></pre><h4 id="实例-4"><a class="markdownIt-Anchor" href="#实例-4"></a> 实例</h4><pre class="highlight"><code class="lua">j =<span class="hljs-number">2</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span>
   <span class="hljs-keyword">for</span> j=<span class="hljs-number">2</span>,(i/j) , <span class="hljs-number">2</span> <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span>(i%j))
      <span class="hljs-keyword">then</span>
         <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">if</span>(j &gt; (i/j))<span class="hljs-keyword">then</span>
         <span class="hljs-built_in">print</span>(<span class="hljs-string">"i 的值为："</span>,i)
      <span class="hljs-keyword">end</span>
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua">i 的值为：    <span class="hljs-number">8</span>
i 的值为：    <span class="hljs-number">9</span>
i 的值为：    <span class="hljs-number">10</span>
</code></pre><h3 id="break-语句"><a class="markdownIt-Anchor" href="#break-语句"></a> break 语句</h3><p>Lua 编程语言 break 语句插入在循环体中，用于退出当前循环或语句，并开始脚本执行紧接着的语句。</p><p>如果你使用循环嵌套，break 语句将停止最内层循环的执行，并开始执行的外层的循环语句。</p><h4 id="语法-4"><a class="markdownIt-Anchor" href="#语法-4"></a> 语法</h4><pre class="highlight"><code class="lua"><span class="hljs-keyword">break</span>
</code></pre><p>流程图：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795441489-29359564-29c0-4153-9d50-4844cce2e22c.png" alt="img"></p><h4 id="实例-5"><a class="markdownIt-Anchor" href="#实例-5"></a> 实例</h4><p>下实例执行 while 循环，在变量 a 小于 20 时输出 a 的值，并在 a 大于 15 时终止执行循环：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 定义变量 --]</span>
a = <span class="hljs-number">10</span>

<span class="hljs-comment">--[ while 循环 --]</span>
<span class="hljs-keyword">while</span>( a &lt; <span class="hljs-number">20</span> )
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为:"</span>, a)
   a=a+<span class="hljs-number">1</span>
   <span class="hljs-keyword">if</span>( a &gt; <span class="hljs-number">15</span>)
   <span class="hljs-keyword">then</span>
      <span class="hljs-comment">--[ 使用 break 语句终止循环 --]</span>
      <span class="hljs-keyword">break</span>
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><p>以上代码执行结果如下：</p><pre class="highlight"><code class="lua">a 的值为:    <span class="hljs-number">10</span>
a 的值为:    <span class="hljs-number">11</span>
a 的值为:    <span class="hljs-number">12</span>
a 的值为:    <span class="hljs-number">13</span>
a 的值为:    <span class="hljs-number">14</span>
a 的值为:    <span class="hljs-number">15</span>
</code></pre><hr><h2 id="lua-流程控制"><a class="markdownIt-Anchor" href="#lua-流程控制"></a> 🍁Lua 流程控制</h2><p>Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。</p><p>下图是典型的流程控制流程图：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795625575-64b9f249-ad85-4d9f-862a-5cd0ffcbb041.png" alt="img"></p><p>控制结构的条件表达式结果可以是任何值，Lua 认为 false 和 nil 为假，true 和非 nil 为真。<br>要注意的是 Lua 中 0 为 true：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 0 为 true ]</span>
<span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"0 为 true"</span>)
<span class="hljs-keyword">end</span>
</code></pre><p>以上代码输出结果为:</p><pre class="highlight"><code class="lua"><span class="hljs-number">0</span> 为 <span class="hljs-literal">true</span>
</code></pre><p>Lua 提供了以下控制结构语句：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795674871-1b606327-d0f9-42a6-b2d4-9d80989d0922.png" alt="img"></p><h3 id="if-语句"><a class="markdownIt-Anchor" href="#if-语句"></a> if 语句</h3><pre class="highlight"><code class="lua"><span class="hljs-keyword">if</span>(布尔表达式)
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 在布尔表达式为 true 时执行的语句 --]</span>
<span class="hljs-keyword">end</span>
</code></pre><p>在布尔表达式为 true 时会 if 中的代码块会被执行，在布尔表达式为 false 时，紧跟在 if 语句 end 之后的代码会被执行。Lua 认为 false 和 nil 为假，true 和非 nil 为真。要注意的是 Lua 中 0 为 true。</p><p>if 语句流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795704210-35cebb75-bc38-457b-98f5-648a9cb680d8.png" alt="img"></p><h4 id="实例-6"><a class="markdownIt-Anchor" href="#实例-6"></a> 实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 定义变量 --]</span>
a = <span class="hljs-number">10</span>;

<span class="hljs-comment">--[ 使用 if 语句 --]</span>
<span class="hljs-keyword">if</span>( a &lt; <span class="hljs-number">20</span> )
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ if 条件为 true 时打印以下信息 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 小于 20"</span> );
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为:"</span>, a);
</code></pre><p>执行结果为：</p><pre class="highlight"><code class="lua">a 小于 <span class="hljs-number">20</span>
a 的值为:    <span class="hljs-number">10</span>
</code></pre><h3 id="ifelse-语句"><a class="markdownIt-Anchor" href="#ifelse-语句"></a> if…else 语句</h3><pre class="highlight"><code class="lua"><span class="hljs-keyword">if</span>(布尔表达式)
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 布尔表达式为 true 时执行该语句块 --]</span>
<span class="hljs-keyword">else</span>
   <span class="hljs-comment">--[ 布尔表达式为 false 时执行该语句块 --]</span>
<span class="hljs-keyword">end</span>
</code></pre><p>在布尔表达式为 true 时会 if 中的代码块会被执行，在布尔表达式为 false 时，else 的代码块会被执行。Lua 认为 false 和 nil 为假，true 和非 nil 为真。要注意的是 Lua 中 0 为 true。</p><p>if 语句流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795776591-cf111597-927b-4ea3-af19-15f56fee05b2.png" alt="img"></p><h4 id="实例-7"><a class="markdownIt-Anchor" href="#实例-7"></a> 实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 定义变量 --]</span>
a = <span class="hljs-number">100</span>;
<span class="hljs-comment">--[ 检查条件 --]</span>
<span class="hljs-keyword">if</span>( a &lt; <span class="hljs-number">20</span> )
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ if 条件为 true 时执行该语句块 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 小于 20"</span> )
<span class="hljs-keyword">else</span>
   <span class="hljs-comment">--[ if 条件为 false 时执行该语句块 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 大于 20"</span> )
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为 :"</span>, a)
</code></pre><p>执行结果：</p><pre class="highlight"><code class="lua">a 大于 <span class="hljs-number">20</span>
a 的值为 :    <span class="hljs-number">100</span>
</code></pre><h3 id="ifelse-ifelse-语句"><a class="markdownIt-Anchor" href="#ifelse-ifelse-语句"></a> if…else if…else 语句</h3><pre class="highlight"><code class="lua"><span class="hljs-keyword">if</span>( 布尔表达式 <span class="hljs-number">1</span>)
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span>

<span class="hljs-keyword">elseif</span>( 布尔表达式 <span class="hljs-number">2</span>)
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span>

<span class="hljs-keyword">elseif</span>( 布尔表达式 <span class="hljs-number">3</span>)
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 在布尔表达式 3 为 true 时执行该语句块 --]</span>
<span class="hljs-keyword">else</span>
   <span class="hljs-comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span>
<span class="hljs-keyword">end</span>
</code></pre><h4 id="实例-8"><a class="markdownIt-Anchor" href="#实例-8"></a> 实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 定义变量 --]</span>
a = <span class="hljs-number">100</span>

<span class="hljs-comment">--[ 检查布尔条件 --]</span>
<span class="hljs-keyword">if</span>( a == <span class="hljs-number">10</span> )
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 如果条件为 true 打印以下信息 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为 10"</span> )
<span class="hljs-keyword">elseif</span>( a == <span class="hljs-number">20</span> )
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ if else if 条件为 true 时打印以下信息 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为 20"</span> )
<span class="hljs-keyword">elseif</span>( a == <span class="hljs-number">30</span> )
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ if else if condition 条件为 true 时打印以下信息 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为 30"</span> )
<span class="hljs-keyword">else</span>
   <span class="hljs-comment">--[ 以上条件语句没有一个为 true 时打印以下信息 --]</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"没有匹配 a 的值"</span> )
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的真实值为: "</span>, a )
</code></pre><p>以上代码执行结果如下：</p><pre class="highlight"><code class="lua">没有匹配 a 的值
a 的真实值为:     <span class="hljs-number">100</span>
</code></pre><h3 id="if-嵌套语句"><a class="markdownIt-Anchor" href="#if-嵌套语句"></a> if 嵌套语句</h3><pre class="highlight"><code class="lua"><span class="hljs-keyword">if</span>( 布尔表达式 <span class="hljs-number">1</span>)
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ 布尔表达式 1 为 true 时执行该语句块 --]</span>
   <span class="hljs-keyword">if</span>(布尔表达式 <span class="hljs-number">2</span>)
   <span class="hljs-keyword">then</span>
      <span class="hljs-comment">--[ 布尔表达式 2 为 true 时执行该语句块 --]</span>
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><h4 id="实例-9"><a class="markdownIt-Anchor" href="#实例-9"></a> 实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">--[ 定义变量 --]</span>
a = <span class="hljs-number">100</span>;
b = <span class="hljs-number">200</span>;

<span class="hljs-comment">--[ 检查条件 --]</span>
<span class="hljs-keyword">if</span>( a == <span class="hljs-number">100</span> )
<span class="hljs-keyword">then</span>
   <span class="hljs-comment">--[ if 条件为 true 时执行以下 if 条件判断 --]</span>
   <span class="hljs-keyword">if</span>( b == <span class="hljs-number">200</span> )
   <span class="hljs-keyword">then</span>
      <span class="hljs-comment">--[ if 条件为 true 时执行该语句块 --]</span>
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为 100 b 的值为 200"</span> );
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a 的值为 :"</span>, a );
<span class="hljs-built_in">print</span>(<span class="hljs-string">"b 的值为 :"</span>, b );
</code></pre><p>以上代码执行结果如下：</p><pre class="highlight"><code class="lua">a 的值为 <span class="hljs-number">100</span> b 的值为 <span class="hljs-number">200</span>
a 的值为 :    <span class="hljs-number">100</span>
b 的值为 :    <span class="hljs-number">200</span>
</code></pre><hr><h2 id="lua-函数"><a class="markdownIt-Anchor" href="#lua-函数"></a> 🍁Lua 函数</h2><p>在 Lua 中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如 print()函数可以将传入的参数打印在控制台上。</p><p>Lua 函数主要有两种用途：</p><ul><li><p>1.完成指定的任务，这种情况下函数作为调用语句使用；</p></li><li><p>2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。</p></li></ul><h3 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h3><pre class="highlight"><code class="lua">optional_function_scope <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">function_name</span><span class="hljs-params">( argument1, argument2, argument3..., argumentn)</span></span>
    function_body
    <span class="hljs-keyword">return</span> result_params_comma_separated
<span class="hljs-keyword">end</span>
</code></pre><p>解析</p><ul><li><p>optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</p></li><li><p>function_name: 指定函数名称。</p></li><li><p>argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</p></li><li><p>function_body: 函数体，函数中需要执行的代码语句块。</p></li><li><p>result_params_comma_separated: 函数返回值，Lua 语言函数可以返回多个值，每个值以逗号隔开。</p></li></ul><h4 id="实例-10"><a class="markdownIt-Anchor" href="#实例-10"></a> 实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">--[[ 函数返回两个值的最大值 --]]</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2)</span></span>

   <span class="hljs-keyword">if</span> (num1 &gt; num2) <span class="hljs-keyword">then</span>
      result = num1;
   <span class="hljs-keyword">else</span>
      result = num2;
   <span class="hljs-keyword">end</span>

   <span class="hljs-keyword">return</span> result;
<span class="hljs-keyword">end</span>
<span class="hljs-comment">-- 调用函数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"两值比较最大值为 "</span>,<span class="hljs-built_in">max</span>(<span class="hljs-number">10</span>,<span class="hljs-number">4</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"两值比较最大值为 "</span>,<span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua">两值比较最大值为     <span class="hljs-number">10</span>
两值比较最大值为     <span class="hljs-number">6</span>
</code></pre><p>Lua 中我们可以将函数作为参数传递给函数，如下实例：</p><pre class="highlight"><code class="lua">myprint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(param)</span></span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"这是打印函数 -   ##"</span>,param,<span class="hljs-string">"##"</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(num1,num2,functionPrint)</span></span>
   result = num1 + num2
   <span class="hljs-comment">-- 调用传递的函数参数</span>
   functionPrint(result)
<span class="hljs-keyword">end</span>
myprint(<span class="hljs-number">10</span>)
<span class="hljs-comment">-- myprint 函数作为参数传递</span>
add(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,myprint)
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua">这是打印函数 -   ##    <span class="hljs-number">10</span>    ##
这是打印函数 -   ##    <span class="hljs-number">7</span>    ##
</code></pre><h3 id="多返回值"><a class="markdownIt-Anchor" href="#多返回值"></a> 多返回值</h3><p>Lua 函数可以返回多个结果值，比如 string.find，其返回匹配串&quot;开始和结束的下标&quot;（如果不存在匹配串返回 nil）。</p><pre class="highlight"><code class="lua">s, e = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(<span class="hljs-string">"www.baidu.com"</span>, <span class="hljs-string">"baidu"</span>)
<span class="hljs-built_in">print</span>(s, e)
</code></pre><p>结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">5</span>    <span class="hljs-number">9</span>
</code></pre><p>Lua 函数中，在 return 后列出要返回的值得列表即可返回多值，如</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maximum</span> <span class="hljs-params">(a)</span></span>
    <span class="hljs-keyword">local</span> mi = <span class="hljs-number">1</span>             <span class="hljs-comment">-- 最大值索引</span>
    <span class="hljs-keyword">local</span> m = a[mi]          <span class="hljs-comment">-- 最大值</span>
    <span class="hljs-keyword">for</span> i,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span>
       <span class="hljs-keyword">if</span> val &gt; m <span class="hljs-keyword">then</span>
           mi = i
           m = val
       <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> m, mi
<span class="hljs-keyword">end</span>

<span class="hljs-built_in">print</span>(maximum(&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>&#125;))
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">23</span>    <span class="hljs-number">3</span>
</code></pre><h3 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h3><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数。</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span>
<span class="hljs-keyword">local</span> s = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>&#123;...&#125; <span class="hljs-keyword">do</span>   <span class="hljs-comment">--&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组</span>
    s = s + v
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> s
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>))  <span class="hljs-comment">---&gt;25</span>
</code></pre><p>我们可以将可变参数赋值给一个变量。例如，我们计算几个数的平均值：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">average</span><span class="hljs-params">(...)</span></span>
   result = <span class="hljs-number">0</span>
   <span class="hljs-keyword">local</span> <span class="hljs-built_in">arg</span>=&#123;...&#125;    <span class="hljs-comment">--&gt; arg 为一个表，局部变量</span>
   <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(<span class="hljs-built_in">arg</span>) <span class="hljs-keyword">do</span>
      result = result + v
   <span class="hljs-keyword">end</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"总共传入 "</span> .. #<span class="hljs-built_in">arg</span> .. <span class="hljs-string">" 个数"</span>)
   <span class="hljs-keyword">return</span> result/#<span class="hljs-built_in">arg</span>
<span class="hljs-keyword">end</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"平均值为"</span>,average(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<span class="hljs-number">25</span>
</code></pre><p>我们也可以通过 select(&quot;#&quot;,…) 来获取可变参数的数量:</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">average</span><span class="hljs-params">(...)</span></span>
   result = <span class="hljs-number">0</span>
   <span class="hljs-keyword">local</span> <span class="hljs-built_in">arg</span>=&#123;...&#125;
   <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(<span class="hljs-built_in">arg</span>) <span class="hljs-keyword">do</span>
      result = result + v
   <span class="hljs-keyword">end</span>
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"总共传入 "</span> .. <span class="hljs-built_in">select</span>(<span class="hljs-string">"#"</span>,...) .. <span class="hljs-string">" 个数"</span>)
   <span class="hljs-keyword">return</span> result/<span class="hljs-built_in">select</span>(<span class="hljs-string">"#"</span>,...)
<span class="hljs-keyword">end</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"平均值为"</span>,average(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))
</code></pre><p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(fmt, ...)</span></span>  <span class="hljs-comment">---&gt; 固定的参数fmt</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(fmt, ...))
<span class="hljs-keyword">end</span>

fwrite(<span class="hljs-string">"runoob\n"</span>)       <span class="hljs-comment">---&gt;fmt = "runoob", 没有变长参数。</span>
fwrite(<span class="hljs-string">"%d%d\n"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)   <span class="hljs-comment">---&gt;fmt = "%d%d", 变长参数为 1 和 1</span>
</code></pre><p>通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(’#’, …) 或者 select(n, …)</p><ul><li><p>select(’#’, …) 返回可变参数的长度</p></li><li><p>select(n, …) 用于访问 n 到 select(’#’,…) 的参数</p></li></ul><p>调用 select 时，必须传入一个固定实参 selector(选择开关)和一系列变长参数。如果 selector 为数字 n,那么 select 返回它的第 n 个可变实参，否则只能为字符串&quot;#&quot;,这样 select 会返回变长参数的总数。例子代码：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">do</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>
        <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">select</span>(<span class="hljs-string">'#'</span>, ...) <span class="hljs-keyword">do</span>  <span class="hljs-comment">--&gt;获取参数总数</span>
            <span class="hljs-keyword">local</span> <span class="hljs-built_in">arg</span> = <span class="hljs-built_in">select</span>(i, ...); <span class="hljs-comment">--&gt;读取参数</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"arg"</span>, <span class="hljs-built_in">arg</span>);
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>

    foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">end</span>
</code></pre><p>输出结果：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">arg</span>    <span class="hljs-number">1</span>
<span class="hljs-built_in">arg</span>    <span class="hljs-number">2</span>
<span class="hljs-built_in">arg</span>    <span class="hljs-number">3</span>
<span class="hljs-built_in">arg</span>    <span class="hljs-number">4</span>
</code></pre><hr><h2 id="lua-运算符"><a class="markdownIt-Anchor" href="#lua-运算符"></a> 🍁Lua 运算符</h2><p>运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua 提供了以下几种运算符类型：</p><ul><li><p>算术运算符</p></li><li><p>关系运算符</p></li><li><p>逻辑运算符</p></li><li><p>其他运算符</p></li></ul><h3 id="算数运算符"><a class="markdownIt-Anchor" href="#算数运算符"></a> 算数运算符</h3><p>下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为 10，B 的值为 20：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796915099-182b544e-343b-4338-827b-16d5ce9807ff.png" alt="img"></p><h3 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h3><p>下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为 10，B 的值为 20：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796934445-08762e3c-8245-4964-ba85-d2469ae31630.png" alt="img"></p><h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3><p>下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796955997-b3a7dee8-81f8-42ce-9631-1f0e30b15143.png" alt="img"></p><h3 id="其他运算符"><a class="markdownIt-Anchor" href="#其他运算符"></a> 其他运算符</h3><p>下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796993558-cd2c7425-bff9-46c2-96f7-40ab6574733b.png" alt="img"></p><h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h3><p>从高到低的顺序：</p><pre class="highlight"><code class="lua">^
<span class="hljs-keyword">not</span>    - (unary)
*      /
+      -
..
&lt;      &gt;      &lt;=     &gt;=     ~=     ==
<span class="hljs-keyword">and</span>
<span class="hljs-keyword">or</span>
</code></pre><p>除了^和…外所有的二元运算符都是左连接的</p><pre class="highlight"><code class="lua">a+i &lt; b/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>          &lt;<span class="hljs-comment">--&gt;       (a+i) &lt; ((b/2)+1)</span>
<span class="hljs-number">5</span>+x^<span class="hljs-number">2</span>*<span class="hljs-number">8</span>              &lt;<span class="hljs-comment">--&gt;       5+((x^2)*8)</span>
a &lt; y <span class="hljs-keyword">and</span> y &lt;= z     &lt;<span class="hljs-comment">--&gt;       (a &lt; y) and (y &lt;= z)</span>
-x^<span class="hljs-number">2</span>                 &lt;<span class="hljs-comment">--&gt;       -(x^2)</span>
x^y^z                &lt;<span class="hljs-comment">--&gt;       x^(y^z)</span>
</code></pre><hr><h2 id="lua-字符串"><a class="markdownIt-Anchor" href="#lua-字符串"></a> 🍁Lua 字符串</h2><p>字符串或串(String)是由数字、字母、下划线组成的一串字符</p><p>Lua 语言中字符串可以使用以下三种方式来表示：</p><ul><li><p>单引号间的一串字符</p></li><li><p>双引号的一串字符</p></li><li><p>[[和]]间的一串字符</p></li></ul><p>以上三种方式的字符串实例如下：</p><pre class="highlight"><code class="lua">string1 = <span class="hljs-string">"Lua"</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\"字符串 1 是\""</span>,string1)
string2 = <span class="hljs-string">'runoob.com'</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"字符串 2 是"</span>,string2)

string3 = <span class="hljs-string">[["Lua 教程"]]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"字符串 3 是"</span>,string3)
</code></pre><p>以上代码执行输出结果是：</p><pre class="highlight"><code class="lua"><span class="hljs-string">"字符串 1 是"</span>    Lua
字符串 <span class="hljs-number">2</span> 是    runoob.com
字符串 <span class="hljs-number">3</span> 是    <span class="hljs-string">"Lua 教程"</span>
</code></pre><p>转义字符用于表示不能直接显示的字符，比如后退键，回车键，等。如在字符串转换双引号可以使用 “”&quot;。所有的转义字符和所对应的意义：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545799061644-a6952d51-146a-4331-a0f6-2eeb9c40ac00.png" alt="img"></p><h3 id="字符串操作"><a class="markdownIt-Anchor" href="#字符串操作"></a> 字符串操作</h3><p><img data-src="http://lgqimg.changzer.cn/img/1545799123960-edb58671-3992-4e1c-9e3d-4c84aac76664.png" alt="img"></p><h3 id="字符串格式化"><a class="markdownIt-Anchor" href="#字符串格式化"></a> 字符串格式化</h3><p>Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。</p><p>由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。</p><p>以下实例演示了如何对字符串进行格式化操作：格式字符串可能包含以下的转义码:</p><ul><li><p>%c - 接受一个数字, 并将其转化为 ASCII 码表中对应的字符</p></li><li><p>%d, %i - 接受一个数字并将其转化为有符号的整数格式</p></li><li><p>%o - 接受一个数字并将其转化为八进制数格式</p></li><li><p>%u - 接受一个数字并将其转化为无符号整数格式</p></li><li><p>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</p></li><li><p>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</p></li><li><p>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母 e</p></li><li><p>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母 E</p></li><li><p>%f - 接受一个数字并将其转化为浮点数格式</p></li><li><p>%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f 中较短的一种格式</p></li><li><p>%q - 接受一个字符串并将其转化为可安全被 Lua 编译器读入的格式</p></li><li><p>%s - 接受一个字符串并按照给定的参数格式化该字符串</p></li></ul><p>为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:</p><ul><li>(1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li><li>(2) 占位符: 一个 0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li><li>(3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li><li>(4) 宽度数值</li><li>(5) 小数位数/字串裁切: 在宽度数值后增加的小数部分 n, 若后接 f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留 n 位, 若后接 s(字符串转义符, 如%5.3s)则设定该字符串只显示前 n 位.</li></ul><hr><h2 id="lua数组"><a class="markdownIt-Anchor" href="#lua数组"></a> 🍁Lua数组</h2><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。</p><h3 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组</h3><p>一维数组是最简单的数组，其逻辑结构是线性表。一维数组可以用for循环出数组中的元素，如下实例：</p><pre class="highlight"><code class="lua">array=&#123;<span class="hljs-string">"Lua"</span>,<span class="hljs-string">"Tutorial"</span>&#125;

<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(array[i])
<span class="hljs-keyword">end</span>
</code></pre><p>以上代码执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-literal">nil</span>
Lua
Tutorial
</code></pre><p>正如你所看到的，我们可以使用整数索引来访问数组元素，如果知道的索引没有值则返回nil。在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始。除此外我们还可以以负数为数组索引值：</p><pre class="highlight"><code class="lua">array = &#123;&#125;

<span class="hljs-keyword">for</span> i= <span class="hljs-number">-2</span>, <span class="hljs-number">2</span> <span class="hljs-keyword">do</span>
   array[i] = i *<span class="hljs-number">2</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">for</span> i = <span class="hljs-number">-2</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(array[i])
<span class="hljs-keyword">end</span>
</code></pre><p>执行结果：</p><pre class="highlight"><code class="lua"><span class="hljs-number">-4</span>
<span class="hljs-number">-2</span>
<span class="hljs-number">0</span>
<span class="hljs-number">2</span>
<span class="hljs-number">4</span>
</code></pre><h3 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h3><p>多维数组即数组中包含数组或一维数组的索引键对应一个数组。以下是一个三行三列的阵列多维数组：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 初始化数组</span>
array = &#123;&#125;
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span>
   array[i] = &#123;&#125;
      <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span>
         array[i][j] = i*j
      <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
 
<span class="hljs-comment">-- 访问数组</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span>
   <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">do</span>
      <span class="hljs-built_in">print</span>(array[i][j])
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><p>不同索引键的三行三列阵列多维数组：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 初始化数组</span>
array = &#123;&#125;
maxRows = <span class="hljs-number">3</span>
maxColumns = <span class="hljs-number">3</span>
<span class="hljs-keyword">for</span> row=<span class="hljs-number">1</span>,maxRows <span class="hljs-keyword">do</span>
   <span class="hljs-keyword">for</span> col=<span class="hljs-number">1</span>,maxColumns <span class="hljs-keyword">do</span>
      array[row*maxColumns +col] = row*col
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 访问数组</span>
<span class="hljs-keyword">for</span> row=<span class="hljs-number">1</span>,maxRows <span class="hljs-keyword">do</span>
   <span class="hljs-keyword">for</span> col=<span class="hljs-number">1</span>,maxColumns <span class="hljs-keyword">do</span>
      <span class="hljs-built_in">print</span>(array[row*maxColumns +col])
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><p>以上代码执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">2</span>
<span class="hljs-number">4</span>
<span class="hljs-number">6</span>
<span class="hljs-number">3</span>
<span class="hljs-number">6</span>
<span class="hljs-number">9</span>
</code></pre><p>如你所看到的，以上的实例中，数组设定了指定的索引值，这样可以避免出现 nil 值，有利于节省内存空间。</p><hr><h2 id="lua垃圾回收"><a class="markdownIt-Anchor" href="#lua垃圾回收"></a> 🍁Lua垃圾回收</h2><p>Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p><p>Lua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p><p>Lua 实现了一个<ins>增量标记-扫描收集器</ins>{. dot}。 它使用这两个数字来控制垃圾收集循环： <ins>垃圾收集器间歇率和垃圾收集器步进倍率</ins>{. dot}。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p><p>垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</p><p>垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的&quot;两倍&quot;速工作。</p><p>如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。</p><h3 id="垃圾回收器函数"><a class="markdownIt-Anchor" href="#垃圾回收器函数"></a> 垃圾回收器函数</h3><p>Lua 提供了以下函数collectgarbage ([opt [, arg]])用来控制自动内存管理:</p><ul><li><p><code>collectgarbage(&quot;collect&quot;)</code>: 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</p></li><li><p><code>collectgarbage(&quot;count&quot;)</code>: 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</p></li><li><p><code>collectgarbage(&quot;restart&quot;)</code>: 重启垃圾收集器的自动运行。</p></li><li><p><code>collectgarbage(&quot;setpause&quot;)</code>: 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。</p></li><li><p><code>collectgarbage(&quot;setstepmul&quot;)</code>: 返回 步进倍率 的前一个值。</p></li><li><p><code>collectgarbage(&quot;step&quot;)</code>: 单步运行垃圾收集器。 步长&quot;大小&quot;由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</p></li><li><p><code>collectgarbage(&quot;stop&quot;)</code>: 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行</p></li></ul><pre class="highlight"><code class="lua">mytable = &#123;<span class="hljs-string">"apple"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"banana"</span>&#125;

<span class="hljs-built_in">print</span>(<span class="hljs-built_in">collectgarbage</span>(<span class="hljs-string">"count"</span>))

mytable = <span class="hljs-literal">nil</span>

<span class="hljs-built_in">print</span>(<span class="hljs-built_in">collectgarbage</span>(<span class="hljs-string">"count"</span>))

<span class="hljs-built_in">print</span>(<span class="hljs-built_in">collectgarbage</span>(<span class="hljs-string">"collect"</span>))

<span class="hljs-built_in">print</span>(<span class="hljs-built_in">collectgarbage</span>(<span class="hljs-string">"count"</span>))
</code></pre><p>执行以上程序，输出结果如下(注意内存使用的变化)：</p><pre class="highlight"><code class="lua"><span class="hljs-number">20.9560546875</span>
<span class="hljs-number">20.9853515625</span>
<span class="hljs-number">0</span>
<span class="hljs-number">19.4111328125</span>
</code></pre><hr><h2 id="lua数据库访问"><a class="markdownIt-Anchor" href="#lua数据库访问"></a> 🍁Lua数据库访问</h2><p>Lua数据库的操作库为：LuaSQL。它是开源的，支持的数据库有：ODBC、ADO、Oracle、MySQL、SQLite和PostgreSQL。</p><p>LuaSQL 可以使用 LuaRocks 来安装可以根据需要安装你需要的数据库驱动。LuaRocks 安装方法：</p><pre class="highlight"><code class="bash">$ wget http://luarocks.org/releases/luarocks-2.2.1.tar.gz
$ tar zxpf luarocks-2.2.1.tar.gz
$ <span class="hljs-built_in">cd</span> luarocks-2.2.1
$ ./configure; sudo make bootstrap
$ sudo luarocks install luasocket
$ lua
Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio
&gt; require <span class="hljs-string">"socket"</span>
</code></pre><p>Window 下安装 LuaRocks：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlcGxlcnByb2plY3QvbHVhcm9ja3Mvd2lraS9JbnN0YWxsYXRpb24taW5zdHJ1Y3Rpb25zLWZvci1XaW5kb3dz">https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows</span></p><p>安装不同数据库驱动：</p><pre class="highlight"><code class="bash">luarocks install luasql-sqlite3
luarocks install luasql-postgres
luarocks install luasql-mysql
luarocks install luasql-sqlite
luarocks install luasql-odbc
</code></pre><p>你也可以使用源码安装方式，Lua Github 源码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlcGxlcnByb2plY3QvbHVhc3Fs">https://github.com/keplerproject/luasql</span></p><p>Lua 连接MySql 数据库：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">require</span> <span class="hljs-string">"luasql.mysql"</span>

<span class="hljs-comment">--创建环境对象</span>
env = luasql.mysql()

<span class="hljs-comment">--连接数据库</span>
conn = env:connect(<span class="hljs-string">"数据库名"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>,<span class="hljs-string">"IP地址"</span>,端口)

<span class="hljs-comment">--设置数据库的编码格式</span>
conn:<span class="hljs-built_in">execute</span><span class="hljs-string">"SET NAMES UTF8"</span>

<span class="hljs-comment">--执行数据库操作</span>
cur = conn:<span class="hljs-built_in">execute</span>(<span class="hljs-string">"select * from role"</span>)

row = cur:fetch(&#123;&#125;,<span class="hljs-string">"a"</span>)

<span class="hljs-comment">--文件对象的创建</span>
file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">"role.txt"</span>,<span class="hljs-string">"w+"</span>);

<span class="hljs-keyword">while</span> row <span class="hljs-keyword">do</span>
    var = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">"%d %s\n"</span>, row.id, row.name)

    <span class="hljs-built_in">print</span>(var)

    file:<span class="hljs-built_in">write</span>(var)

    row = cur:fetch(row,<span class="hljs-string">"a"</span>)
<span class="hljs-keyword">end</span>


file:<span class="hljs-built_in">close</span>()  <span class="hljs-comment">--关闭文件对象</span>
conn:<span class="hljs-built_in">close</span>()  <span class="hljs-comment">--关闭数据库连接</span>
env:<span class="hljs-built_in">close</span>()   <span class="hljs-comment">--关闭数据库环境</span>
</code></pre><hr><h2 id="lua迭代器"><a class="markdownIt-Anchor" href="#lua迭代器"></a> 🍁Lua迭代器</h2><p>迭代器(iterator)是一种对象，它能够用来遍历标准模版库容器的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p><p>在Lua中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p><h3 id="泛型for迭代器"><a class="markdownIt-Anchor" href="#泛型for迭代器"></a> 泛型for迭代器</h3><p>泛型for迭代器提供了集合的key/value对，语法格式如下：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(k,v)
<span class="hljs-keyword">end</span>
</code></pre><p>上面代码中，k和v为变量列表；pairs(t)为表达式列表。查看如下实例：</p><pre class="highlight"><code class="lua">array = &#123;<span class="hljs-string">"Lua"</span>, <span class="hljs-string">"Tutorial"</span>&#125;

<span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(array) 
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(key, value)
<span class="hljs-keyword">end</span>
</code></pre><p>以上代码执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>  Lua
<span class="hljs-number">2</span>  Tutorial
</code></pre><p>以上实例中我们使用了 Lua 默认提供的迭代函数 ipairs。</p><p>下面我们看看泛型 for 的执行过程：</p><ul><li><p>首先，初始化，计算in后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。</p></li><li><p>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</p></li><li><p>第三，将迭代函数返回的值赋给变量列表。</p></li><li><p>第四，如果返回的第一个值为nil循环结束，否则执行循环体。第五，回到第二步再次调用迭代函数</p></li></ul><h3 id="无状态的迭代器"><a class="markdownIt-Anchor" href="#无状态的迭代器"></a> 无状态的迭代器</h3><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。</p><p>以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span><span class="hljs-params">(iteratorMaxCount,currentNumber)</span></span>
   <span class="hljs-keyword">if</span> currentNumber&lt;iteratorMaxCount
   <span class="hljs-keyword">then</span>
      currentNumber = currentNumber+<span class="hljs-number">1</span>
   <span class="hljs-keyword">return</span> currentNumber, currentNumber*currentNumber
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">for</span> i,n <span class="hljs-keyword">in</span> square,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(i,n)
<span class="hljs-keyword">end</span>
</code></pre><p>以上实例输出结果：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>    <span class="hljs-number">1</span>
<span class="hljs-number">2</span>    <span class="hljs-number">4</span>
<span class="hljs-number">3</span>    <span class="hljs-number">9</span>
</code></pre><p>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs和迭代函数都很简单，我们在Lua中可以这样实现：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iter</span> <span class="hljs-params">(a, i)</span></span>
    i = i + <span class="hljs-number">1</span>
    <span class="hljs-keyword">local</span> v = a[i]
    <span class="hljs-keyword">if</span> v <span class="hljs-keyword">then</span>
       <span class="hljs-keyword">return</span> i, v
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ipairs</span> <span class="hljs-params">(a)</span></span>
    <span class="hljs-keyword">return</span> iter, a, <span class="hljs-number">0</span>
<span class="hljs-keyword">end</span>
</code></pre><h3 id="多状态的迭代器"><a class="markdownIt-Anchor" href="#多状态的迭代器"></a> 多状态的迭代器</h3><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。</p><p>以下实例我们创建了自己的迭代器：</p><pre class="highlight"><code class="lua">array = &#123;<span class="hljs-string">"Lua"</span>, <span class="hljs-string">"Tutorial"</span>&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elementIterator</span> <span class="hljs-params">(collection)</span></span>
   <span class="hljs-keyword">local</span> index = <span class="hljs-number">0</span>
   <span class="hljs-keyword">local</span> count = #collection
   <span class="hljs-comment">-- 闭包函数</span>
   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>
      index = index + <span class="hljs-number">1</span>
      <span class="hljs-keyword">if</span> index &lt;= count
      <span class="hljs-keyword">then</span>
         <span class="hljs-comment">--  返回迭代器的当前元素</span>
         <span class="hljs-keyword">return</span> collection[index]
      <span class="hljs-keyword">end</span>
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elementIterator(array)
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(element)
<span class="hljs-keyword">end</span>
</code></pre><p>以上实例输出结果为：</p><pre class="highlight"><code class="lua">Lua
Tutorial
</code></pre><p>以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。</p><hr><h2 id="lua-table表"><a class="markdownIt-Anchor" href="#lua-table表"></a> 🍁Lua table(表)</h2><p>table是Lua的一种数据结构用来帮助我们创建不同的数据类型，如：数字、字典等。</p><p>Lua table 使用关联型数组，你可以使用任意类型的值来作数组的索引，但这个值不能是nil。</p><p>Lua table是不固定大小的，你可以根据自己需要进行扩容。</p><p>Lua也是通过table来解决模块(module)、包(package)和对象(Object)的</p><h3 id="table表的构造"><a class="markdownIt-Anchor" href="#table表的构造"></a> table(表)的构造</h3><p>构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组。</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 初始化表</span>
mytable = &#123;&#125;

<span class="hljs-comment">--指定值</span>
mytable[<span class="hljs-number">1</span>] = <span class="hljs-string">"Lua"</span>

<span class="hljs-comment">--移除引用</span>
mytable = <span class="hljs-literal">nil</span>
</code></pre><p>当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。</p><p>以下实例演示了以上的描述情况：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 简单的 table</span>
mytable = &#123;&#125;
<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 的类型是 "</span>,<span class="hljs-built_in">type</span>(mytable))

mytable[<span class="hljs-number">1</span>]= <span class="hljs-string">"Lua"</span>
mytable[<span class="hljs-string">"wow"</span>] = <span class="hljs-string">"修改前"</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 索引为 1 的元素是 "</span>, mytable[<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 索引为 wow 的元素是 "</span>, mytable[<span class="hljs-string">"wow"</span>])

<span class="hljs-comment">-- alternatetable和mytable的是指同一个 table</span>
alternatetable = mytable

<span class="hljs-built_in">print</span>(<span class="hljs-string">"alternatetable 索引为 1 的元素是 "</span>, alternatetable[<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 索引为 wow 的元素是 "</span>, alternatetable[<span class="hljs-string">"wow"</span>])

alternatetable[<span class="hljs-string">"wow"</span>] = <span class="hljs-string">"修改后"</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 索引为 wow 的元素是 "</span>, mytable[<span class="hljs-string">"wow"</span>])

<span class="hljs-comment">-- 释放变量</span>
alternatetable = <span class="hljs-literal">nil</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"alternatetable 是 "</span>, alternatetable)

<span class="hljs-comment">-- mytable 仍然可以访问</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 索引为 wow 的元素是 "</span>, mytable[<span class="hljs-string">"wow"</span>])

mytable = <span class="hljs-literal">nil</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"mytable 是 "</span>, mytable)
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua">mytable 的类型是     <span class="hljs-built_in">table</span>
mytable 索引为 <span class="hljs-number">1</span> 的元素是     Lua
mytable 索引为 wow 的元素是     修改前
alternatetable 索引为 <span class="hljs-number">1</span> 的元素是     Lua
mytable 索引为 wow 的元素是     修改前
mytable 索引为 wow 的元素是     修改后
alternatetable 是     <span class="hljs-literal">nil</span>
mytable 索引为 wow 的元素是     修改后
mytable 是     <span class="hljs-literal">nil</span>
</code></pre><h3 id="table操作"><a class="markdownIt-Anchor" href="#table操作"></a> Table操作</h3><p>以下列出了 Table 操作常用的方法：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545804695245-6b61a099-baec-4980-9a69-bec0849f2970.png" alt="img"></p><h3 id="table连接"><a class="markdownIt-Anchor" href="#table连接"></a> Table连接</h3><pre class="highlight"><code class="lua">fruits = &#123;<span class="hljs-string">"banana"</span>,<span class="hljs-string">"orange"</span>,<span class="hljs-string">"apple"</span>&#125;
<span class="hljs-comment">-- 返回 table 连接后的字符串</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"连接后的字符串 "</span>,<span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(fruits))

<span class="hljs-comment">-- 指定连接字符</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"连接后的字符串 "</span>,<span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(fruits,<span class="hljs-string">", "</span>))

<span class="hljs-comment">-- 指定索引来连接 table</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"连接后的字符串 "</span>,<span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(fruits,<span class="hljs-string">", "</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>))
</code></pre><p>执行结果：</p><pre class="highlight"><code class="lua">连接后的字符串     bananaorangeapple
连接后的字符串     banana, orange, apple
连接后的字符串     orange, apple
</code></pre><h3 id="插入和移除"><a class="markdownIt-Anchor" href="#插入和移除"></a> 插入和移除</h3><pre class="highlight"><code class="lua">fruits = &#123;<span class="hljs-string">"banana"</span>,<span class="hljs-string">"orange"</span>,<span class="hljs-string">"apple"</span>&#125;

<span class="hljs-comment">-- 在末尾插入</span>
<span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(fruits,<span class="hljs-string">"mango"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"索引为 4 的元素为 "</span>,fruits[<span class="hljs-number">4</span>])

<span class="hljs-comment">-- 在索引为 2 的键处插入</span>
<span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(fruits,<span class="hljs-number">2</span>,<span class="hljs-string">"grapes"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"索引为 2 的元素为 "</span>,fruits[<span class="hljs-number">2</span>])

<span class="hljs-built_in">print</span>(<span class="hljs-string">"最后一个元素为 "</span>,fruits[<span class="hljs-number">5</span>])
<span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(fruits)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"移除后最后一个元素为 "</span>,fruits[<span class="hljs-number">5</span>])
</code></pre><p>执行以上代码输出结果为：</p><pre class="highlight"><code class="lua">索引为 <span class="hljs-number">4</span> 的元素为     mango
索引为 <span class="hljs-number">2</span> 的元素为     grapes
最后一个元素为     mango
移除后最后一个元素为     <span class="hljs-literal">nil</span>
</code></pre><h3 id="table排序"><a class="markdownIt-Anchor" href="#table排序"></a> Table排序</h3><pre class="highlight"><code class="lua">fruits = &#123;<span class="hljs-string">"banana"</span>,<span class="hljs-string">"orange"</span>,<span class="hljs-string">"apple"</span>,<span class="hljs-string">"grapes"</span>&#125;
<span class="hljs-built_in">print</span>(<span class="hljs-string">"排序前"</span>)
<span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(fruits) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(k,v)
<span class="hljs-keyword">end</span>

<span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(fruits)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"排序后"</span>)
<span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(fruits) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(k,v)
<span class="hljs-keyword">end</span>
</code></pre><p>执行以上代码输出结果为：</p><pre class="highlight"><code class="lua">排序前
<span class="hljs-number">1</span>    banana
<span class="hljs-number">2</span>    orange
<span class="hljs-number">3</span>    apple
<span class="hljs-number">4</span>    grapes
排序后
<span class="hljs-number">1</span>    apple
<span class="hljs-number">2</span>    banana
<span class="hljs-number">3</span>    grapes
<span class="hljs-number">4</span>    orange
</code></pre><h3 id="table最大值"><a class="markdownIt-Anchor" href="#table最大值"></a> Table最大值</h3><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">table_maxn</span><span class="hljs-params">(t)</span></span>
  <span class="hljs-keyword">local</span> mn=<span class="hljs-literal">nil</span>;
  <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span>(mn==<span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span>
      mn=v
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">if</span> mn &lt; v <span class="hljs-keyword">then</span>
      mn = v
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> mn
<span class="hljs-keyword">end</span>
tbl = &#123;[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>, [<span class="hljs-number">3</span>] = <span class="hljs-number">34</span>, [<span class="hljs-number">26</span>] =<span class="hljs-number">5</span>&#125;
<span class="hljs-built_in">print</span>(<span class="hljs-string">"tbl 最大值："</span>, table_maxn(tbl))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"tbl 长度 "</span>, #tbl)
</code></pre><p>执行以上代码输出结果为：</p><pre class="highlight"><code class="lua">tbl 最大值：    <span class="hljs-number">34</span>
tbl 长度     <span class="hljs-number">3</span>
</code></pre><p>[注意：当我们获取 table 的长度的时候无论是使用 # 还是 table.getn 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。]{ .red}</p><p><em>可以使用以下方法来代替：</em></p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">table_leng</span><span class="hljs-params">(t)</span></span>
  <span class="hljs-keyword">local</span> leng=<span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span>
    leng=leng+<span class="hljs-number">1</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> leng;
<span class="hljs-keyword">end</span>
</code></pre><h3 id="table去重"><a class="markdownIt-Anchor" href="#table去重"></a> Table去重</h3><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">table.unique</span><span class="hljs-params">(t, bArray)</span></span>
    <span class="hljs-keyword">local</span> check = &#123;&#125;
    <span class="hljs-keyword">local</span> n = &#123;&#125;
    <span class="hljs-keyword">local</span> idx = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check[v] <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">if</span> bArray <span class="hljs-keyword">then</span>
                n[idx] = v
                idx = idx + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>
                n[k] = v
            <span class="hljs-keyword">end</span>
            check[v] = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> n
<span class="hljs-keyword">end</span>
</code></pre><hr><h2 id="lua模块与包"><a class="markdownIt-Anchor" href="#lua模块与包"></a> 🍁Lua模块与包</h2><p>模块类似于一个封装库，从Lua 5.1开始，Lua加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以API接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p><p>Lua的模块是由变量、函数等已知元素组成的table，因此创建一个模块很简单，就是创建一个table，然后把需要导出的变量、函数放入其中，最后返回这个table就行。以下为创建自定义模块 module.lua,文件代码格式如下：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 文件名为 module.lua</span>
<span class="hljs-comment">-- 定义一个名为 module 的模块</span>
module = &#123;&#125;
 
<span class="hljs-comment">-- 定义一个常量</span>
module.constant = <span class="hljs-string">"这是一个常量"</span>
 
<span class="hljs-comment">-- 定义一个函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module.func1</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">"这是一个公有函数！\n"</span>)
<span class="hljs-keyword">end</span>
 
<span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"这是一个私有函数！"</span>)
<span class="hljs-keyword">end</span>
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module.func3</span><span class="hljs-params">()</span></span>
    func2()
<span class="hljs-keyword">end</span>
 
<span class="hljs-keyword">return</span> module
</code></pre><p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用。</p><h3 id="require函数"><a class="markdownIt-Anchor" href="#require函数"></a> require函数</h3><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">require</span>(<span class="hljs-string">"函数名"</span>)
</code></pre><p>或者</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">require</span> <span class="hljs-string">"&lt;函数名&gt;"</span>
</code></pre><p>执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- test_module.lua 文件</span>
<span class="hljs-comment">-- module 模块为上文提到到 module.lua</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"module"</span>)
 
<span class="hljs-built_in">print</span>(module.constant)
 
module.func3()
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua">这是一个常量
这是一个私有函数！
</code></pre><h3 id="加载机制"><a class="markdownIt-Anchor" href="#加载机制"></a> 加载机制</h3><p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p><p>require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。</p><p>当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 “~/lua/” 路径加入 LUA_PATH 环境变量里：</p><pre class="highlight"><code class="lua">#LUA_PATH
export LUA_PATH=<span class="hljs-string">"~/lua/?.lua;;"</span>
</code></pre><p>文件路径以 “<code>;</code>” 号分隔，最后的 2 个 “<code>;;</code>” 表示新加的路径后面加上原来的默认路径</p><p>接着，更新环境变量参数，使之立即生效。</p><pre class="highlight"><code class="lua">source ~/.profile
</code></pre><p>这时假设package.path的值是</p><pre class="highlight"><code class="cpp">/Users/dengjoe/lua/?.lua;./?.lua;/usr/local/share/lua/<span class="hljs-number">5.1</span>/?.lua;/usr/local/share/lua/<span class="hljs-number">5.1</span>/?/init.lua;/usr/local/lib/lua/<span class="hljs-number">5.1</span>/?.lua;/usr/local/lib/lua/<span class="hljs-number">5.1</span>/?/init.lua
</code></pre><p>那么调用 require(“module”) 时就会尝试打开以下文件目录去搜索目标。</p><pre class="highlight"><code class="lua">/Users/dengjoe/lua/module.lua;
./module.lua
/usr/<span class="hljs-keyword">local</span>/share/lua/<span class="hljs-number">5.1</span>/module.lua
/usr/<span class="hljs-keyword">local</span>/share/lua/<span class="hljs-number">5.1</span>/module/init.lua
/usr/<span class="hljs-keyword">local</span>/lib/lua/<span class="hljs-number">5.1</span>/module.lua
/usr/<span class="hljs-keyword">local</span>/lib/lua/<span class="hljs-number">5.1</span>/module/init.lua
</code></pre><p>如果找过目标文件，则会调用package.loadfile来加载模块。否则，就会去找C程序库。</p><p>搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。</p><p>搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。</p><h3 id="c包"><a class="markdownIt-Anchor" href="#c包"></a> C包</h3><p>Lua和C是很容易结合的，使用C为Lua写包。</p><p>与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p><p>Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p><pre class="highlight"><code class="cpp">local path = <span class="hljs-string">"/usr/local/lua/lib/libluasocket.so"</span>
local f = loadlib(path, <span class="hljs-string">"luaopen_socket"</span>)
</code></pre><p><code>loadlib</code>函数加载指定的库并且连接到Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为Lua的一个函数，这样我们就可以直接在Lua中调用他。</p><p>如果加载动态库或者查找初始化函数时出错，loadlib将返回nil和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：</p><pre class="highlight"><code class="cpp">local path = <span class="hljs-string">"/usr/local/lua/lib/libluasocket.so"</span>
-- 或者 
path = <span class="hljs-string">"C:\\windows\\luasocket.dll"</span>，这是 Window 平台下
local f = assert(loadlib(path, <span class="hljs-string">"luaopen_socket"</span>))
f()  -- 真正打开库
</code></pre><p>一般情况下我们期望二进制的发布库包含一个与前面代码段相似的stub文件，安装二进制库的时候可以随便放在某个目录，只需要修改stub文件对应二进制库的实际路径即可。</p><p>将stub文件所在的目录加入到LUA_PATH，这样设定后就可以使用require函数加载C库了。</p><hr><h2 id="lua元表metatable"><a class="markdownIt-Anchor" href="#lua元表metatable"></a> 🍁Lua元表(Metatable)</h2><p>在Lua table中我们可以访问对应的key来得到value值，但是却无法对两个table进行操作。因此Lua提供了[元表(Metatable)]{ .red},允许我们改变table的行为，每个行为关联了对应的元方法。</p><p>例如，使用元素我们可以定义Lua如何计算两个table的相加操作a+b。当Lua试图对两个表进行相加时，先检查两者之一是否有元素，之后检查是否有一个叫“__add”的字段，若找到，则调用对应的值。“__add”等即时字段，其对应的值（往往是一个函数或是table）就是“元方法”。</p><p>有两个很重要的函数来处理元表：</p><ul><li><code>setmetatable(table,metatable)</code>: 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</li><li><code>getmetatable(table)</code>: 返回对象的元表(metatable)。</li></ul><p>以下实例演示了如何对指定的表设置元表：</p><pre class="highlight"><code class="lua">mytable = &#123;&#125;						<span class="hljs-comment">--普通表</span>
mymetatable = &#123;&#125;					<span class="hljs-comment">--元表</span>
<span class="hljs-built_in">setmetatable</span>(mytable,mymetable)		<span class="hljs-comment">--把 mymetatable 设为 mytable 的元表</span>
</code></pre><p>以上代码也可以直接写成一行：</p><pre class="highlight"><code class="lua">mytable = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;,&#123;&#125;)
</code></pre><p>以下为返回对象元表：</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">getmetatable</span>(mytable)                 <span class="hljs-comment">-- 这会返回mymetatable</span>
</code></pre><h3 id="__index元方法"><a class="markdownIt-Anchor" href="#__index元方法"></a> __index元方法</h3><p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。</p><p>我们可以在使用 lua 命令进入交互模式查看：</p><pre class="highlight"><code class="basic">$ lua
Lua <span class="hljs-number">5.3.0</span>  Copyright (C) <span class="hljs-number">1994</span>-<span class="hljs-number">2015</span> Lua.org, PUC-Rio
&gt; other = &#123; foo = <span class="hljs-number">3</span> &#125; 
&gt; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;) 
&gt; t.foo
<span class="hljs-number">3</span>
&gt; t.bar
nil
</code></pre><p>如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。__index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。</p><pre class="highlight"><code class="lua">mytable = <span class="hljs-built_in">setmetatable</span>(&#123;key1 = <span class="hljs-string">"value1"</span>&#125;, &#123;
  <span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mytable, key)</span></span>
    <span class="hljs-keyword">if</span> key == <span class="hljs-string">"key2"</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">return</span> <span class="hljs-string">"metatablevalue"</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
&#125;)

<span class="hljs-built_in">print</span>(mytable.key1,mytable.key2)
</code></pre><p>实例输出结果为：</p><pre class="highlight"><code class="lua">value1    metatablevalue
</code></pre><p>实例解析：</p><ul><li><p>mytable 表赋值为 {key1 = “value1”}。</p></li><li><p>mytable 设置了元表，元方法为 __index。</p></li><li><p>在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。</p></li><li><p>在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。</p></li><li><p>判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。</p></li><li><p>元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 “metatablevalue”，否则返回 mytable 对应的键值。</p></li></ul><p>我们可以将以上代码简单写成：</p><pre class="highlight"><code class="lua">mytable = <span class="hljs-built_in">setmetatable</span>(&#123;key1 = <span class="hljs-string">"value1"</span>&#125;, &#123; <span class="hljs-built_in">__index</span> = &#123; key2 = <span class="hljs-string">"metatablevalue"</span> &#125; &#125;)
<span class="hljs-built_in">print</span>(mytable.key1,mytable.key2)
</code></pre><p>Lua查找一个表元素时的规则，其实就是如下3个步骤:</p><ol><li><p>在表中查找，如果找到，返回该元素，找不到则继续</p></li><li><p>判断该表是否有元表，如果没有元表，返回nil，有元表则继续。</p></li><li><p>判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。</p></li></ol><h3 id="__newindex元方法"><a class="markdownIt-Anchor" href="#__newindex元方法"></a> __newindex元方法</h3><p>__newindex 元方法用来对表更新，__index则用来对表访问 。当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在,则调用这个函数而不进行赋值操作。</p><p>以下实例演示了 __newindex 元方法的应用：</p><pre class="highlight"><code class="lua">mymetatable = &#123;&#125;
mytable = <span class="hljs-built_in">setmetatable</span>(&#123;key1 = <span class="hljs-string">"value1"</span>&#125;, &#123; <span class="hljs-built_in">__newindex</span> = mymetatable &#125;)

<span class="hljs-built_in">print</span>(mytable.key1)

mytable.newkey = <span class="hljs-string">"新值2"</span>
<span class="hljs-built_in">print</span>(mytable.newkey,mymetatable.newkey)

mytable.key1 = <span class="hljs-string">"新值1"</span>
<span class="hljs-built_in">print</span>(mytable.key1,mymetatable.key1)
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua">value1
<span class="hljs-literal">nil</span>    新值<span class="hljs-number">2</span>
新值<span class="hljs-number">1</span>    <span class="hljs-literal">nil</span>
</code></pre><p>以上实例中表设置了元方法 __newindex，在对新索引键（newkey）赋值时（mytable.newkey = “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。</p><p>以下实例使用了 rawset 函数来更新表：</p><pre class="highlight"><code class="lua">mytable = <span class="hljs-built_in">setmetatable</span>(&#123;key1 = <span class="hljs-string">"value1"</span>&#125;, &#123;
  <span class="hljs-built_in">__newindex</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mytable, key, value)</span></span>
        <span class="hljs-built_in">rawset</span>(mytable, key, <span class="hljs-string">"\""</span>..value..<span class="hljs-string">"\""</span>)

  <span class="hljs-keyword">end</span>
&#125;)

mytable.key1 = <span class="hljs-string">"new value"</span>
mytable.key2 = <span class="hljs-number">4</span>

<span class="hljs-built_in">print</span>(mytable.key1,mytable.key2)
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua">new value    <span class="hljs-string">"4"</span>
</code></pre><h3 id="为表添加操作符"><a class="markdownIt-Anchor" href="#为表添加操作符"></a> 为表添加操作符</h3><p>以下实例演示了两表相加操作：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span>
<span class="hljs-comment">-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">table_maxn</span><span class="hljs-params">(t)</span></span>
    <span class="hljs-keyword">local</span> mn = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">if</span> mn &lt; k <span class="hljs-keyword">then</span>
            mn = k
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> mn
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 两表相加操作</span>
mytable = <span class="hljs-built_in">setmetatable</span>(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;, &#123;
  <span class="hljs-built_in">__add</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mytable, newtable)</span></span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, table_maxn(newtable) <span class="hljs-keyword">do</span>
      <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(mytable, table_maxn(mytable)+<span class="hljs-number">1</span>,newtable[i])
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> mytable
  <span class="hljs-keyword">end</span>
&#125;)

secondtable = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;

mytable = mytable + secondtable
    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(mytable) <span class="hljs-keyword">do</span>
<span class="hljs-built_in">print</span>(k,v)
<span class="hljs-keyword">end</span>
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>    <span class="hljs-number">1</span>
<span class="hljs-number">2</span>    <span class="hljs-number">2</span>
<span class="hljs-number">3</span>    <span class="hljs-number">3</span>
<span class="hljs-number">4</span>    <span class="hljs-number">4</span>
<span class="hljs-number">5</span>    <span class="hljs-number">5</span>
<span class="hljs-number">6</span>    <span class="hljs-number">6</span>
</code></pre><p>__add 键包含在元表中，并进行相加操作。 表中对应的操作列表如下：(注意：__是两个下划线)</p><p><img data-src="http://lgqimg.changzer.cn/img/1545813715108-a8814d1f-7da1-4f70-943f-851d726b0969.png" alt="img"></p><h3 id="__call方法"><a class="markdownIt-Anchor" href="#__call方法"></a> __call方法</h3><p>__call 元方法在 Lua 调用一个值时调用。以下实例演示了计算表中元素的和：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span>
<span class="hljs-comment">-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">table_maxn</span><span class="hljs-params">(t)</span></span>
    <span class="hljs-keyword">local</span> mn = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">if</span> mn &lt; k <span class="hljs-keyword">then</span>
            mn = k
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> mn
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 定义元方法__call</span>
mytable = <span class="hljs-built_in">setmetatable</span>(&#123;<span class="hljs-number">10</span>&#125;, &#123;
  <span class="hljs-built_in">__call</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mytable, newtable)</span></span>
    sum = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, table_maxn(mytable) <span class="hljs-keyword">do</span>
        sum = sum + mytable[i]
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, table_maxn(newtable) <span class="hljs-keyword">do</span>
        sum = sum + newtable[i]
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> sum
  <span class="hljs-keyword">end</span>
&#125;)
newtable = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;
<span class="hljs-built_in">print</span>(mytable(newtable))
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">70</span>
</code></pre><h3 id="__tostring方法"><a class="markdownIt-Anchor" href="#__tostring方法"></a> __tostring方法</h3><p>__tostring 元方法用于修改表的输出行为。以下实例我们自定义了表的输出内容：</p><pre class="highlight"><code class="lua">mytable = <span class="hljs-built_in">setmetatable</span>(&#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span> &#125;, &#123;
  <span class="hljs-built_in">__tostring</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mytable)</span></span>
    sum = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(mytable) <span class="hljs-keyword">do</span>
        sum = sum + v
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"表所有元素的和为 "</span> .. sum
  <span class="hljs-keyword">end</span>
&#125;)
<span class="hljs-built_in">print</span>(mytable)
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua">表所有元素的和为 <span class="hljs-number">60</span>
</code></pre><p>从本文中我们可以知道元表可以很好的简化我们的代码功能，所以了解 Lua 的元表，可以让我们写出更加简单优秀的 Lua 代码。</p><hr><h2 id="lua协同程序coroutine"><a class="markdownIt-Anchor" href="#lua协同程序coroutine"></a> 🍁Lua协同程序(coroutine)</h2><h3 id="什么是协同coroutine"><a class="markdownIt-Anchor" href="#什么是协同coroutine"></a> 什么是协同(coroutine)</h3><p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。协同是非常强大的功能，但是用起来也很复杂。</p><h3 id="线程与协同程序的区别"><a class="markdownIt-Anchor" href="#线程与协同程序的区别"></a> 线程与协同程序的区别</h3><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p><h3 id="基本术语"><a class="markdownIt-Anchor" href="#基本术语"></a> 基本术语</h3><p><img data-src="http://lgqimg.changzer.cn/img/1545814144758-2c44ef30-bb9e-46b1-acb7-49d785d58245.png" alt="img"></p><h3 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h3><pre class="highlight"><code class="lua"><span class="hljs-comment">-- coroutine_test.lua 文件</span>
co = coroutine.<span class="hljs-built_in">create</span>(
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span></span>
        <span class="hljs-built_in">print</span>(i);
    <span class="hljs-keyword">end</span>
)
 
coroutine.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">1</span>)   <span class="hljs-comment">-- 1</span>
<span class="hljs-built_in">print</span>(coroutine.<span class="hljs-built_in">status</span>(co))  <span class="hljs-comment">-- dead</span>
 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"----------"</span>)
 
co = coroutine.<span class="hljs-built_in">wrap</span>(
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span></span>
        <span class="hljs-built_in">print</span>(i);
    <span class="hljs-keyword">end</span>
)
 
co(<span class="hljs-number">1</span>)
 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"----------"</span>)
 
co2 = coroutine.<span class="hljs-built_in">create</span>(
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span>
            <span class="hljs-built_in">print</span>(i)
            <span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span> <span class="hljs-keyword">then</span>
                <span class="hljs-built_in">print</span>(coroutine.<span class="hljs-built_in">status</span>(co2))  <span class="hljs-comment">--running</span>
                <span class="hljs-built_in">print</span>(coroutine.<span class="hljs-built_in">running</span>()) <span class="hljs-comment">--thread:XXXXXX</span>
            <span class="hljs-keyword">end</span>
            coroutine.<span class="hljs-built_in">yield</span>()
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
)
 
coroutine.<span class="hljs-built_in">resume</span>(co2) <span class="hljs-comment">--1</span>
coroutine.<span class="hljs-built_in">resume</span>(co2) <span class="hljs-comment">--2</span>
coroutine.<span class="hljs-built_in">resume</span>(co2) <span class="hljs-comment">--3</span>
 
<span class="hljs-built_in">print</span>(coroutine.<span class="hljs-built_in">status</span>(co2))   <span class="hljs-comment">-- suspended</span>
<span class="hljs-built_in">print</span>(coroutine.<span class="hljs-built_in">running</span>())
 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"----------"</span>)
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>
dead
<span class="hljs-comment">----------</span>
<span class="hljs-number">1</span>
<span class="hljs-comment">----------</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-built_in">running</span>
thread: <span class="hljs-number">0x7fb801c05868</span>    <span class="hljs-literal">false</span>
suspended
thread: <span class="hljs-number">0x7fb801c04c88</span>    <span class="hljs-literal">true</span>
<span class="hljs-comment">----------</span>
</code></pre><p>coroutine.running就可以看出来,coroutine在底层实现就是一个线程。</p><p>当create一个coroutine的时候就是在新线程中注册了一个事件。</p><p>当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p><p>接下来我们分析一个更详细的实例：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(a)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"foo 函数输出"</span>, a)
    <span class="hljs-keyword">return</span> coroutine.<span class="hljs-built_in">yield</span>(<span class="hljs-number">2</span> * a) <span class="hljs-comment">-- 返回  2*a 的值</span>
<span class="hljs-keyword">end</span>
 
co = coroutine.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a , b)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"第一次协同程序执行输出"</span>, a, b) <span class="hljs-comment">-- co-body 1 10</span>
    <span class="hljs-keyword">local</span> r = foo(a + <span class="hljs-number">1</span>)
     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"第二次协同程序执行输出"</span>, r)
    <span class="hljs-keyword">local</span> r, s = coroutine.<span class="hljs-built_in">yield</span>(a + b, a - b)  <span class="hljs-comment">-- a，b的值为第一次调用协同程序时传入</span>
     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"第三次协同程序执行输出"</span>, r, s)
    <span class="hljs-keyword">return</span> b, <span class="hljs-string">"结束协同程序"</span>                   <span class="hljs-comment">-- b的值为第二次调用协同程序时传入</span>
<span class="hljs-keyword">end</span>)
        
<span class="hljs-built_in">print</span>(<span class="hljs-string">"main"</span>, coroutine.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment">-- true, 4</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"--分割线----"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"main"</span>, coroutine.<span class="hljs-built_in">resume</span>(co, <span class="hljs-string">"r"</span>)) <span class="hljs-comment">-- true 11 -9</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"---分割线---"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"main"</span>, coroutine.<span class="hljs-built_in">resume</span>(co, <span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>)) <span class="hljs-comment">-- true 10 end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"---分割线---"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"main"</span>, coroutine.<span class="hljs-built_in">resume</span>(co, <span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>)) <span class="hljs-comment">-- cannot resume dead coroutine</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"---分割线---"</span>)
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua">第一次协同程序执行输出    <span class="hljs-number">1</span>    <span class="hljs-number">10</span>
foo 函数输出    <span class="hljs-number">2</span>
main    <span class="hljs-literal">true</span>    <span class="hljs-number">4</span>
<span class="hljs-comment">--分割线----</span>
第二次协同程序执行输出    r
main    <span class="hljs-literal">true</span>    <span class="hljs-number">11</span>    <span class="hljs-number">-9</span>
<span class="hljs-comment">---分割线---</span>
第三次协同程序执行输出    x    y
main    <span class="hljs-literal">true</span>    <span class="hljs-number">10</span>    结束协同程序
<span class="hljs-comment">---分割线---</span>
main    <span class="hljs-literal">false</span>    cannot <span class="hljs-built_in">resume</span> dead coroutine
<span class="hljs-comment">---分割线---</span>
</code></pre><p>以上实例分析如下：</p><ul><li><p>调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；</p></li><li><p>协同程序运行；</p></li><li><p>运行到yield语句；</p></li><li><p>yield挂起协同程序，第一次resume返回；（注意：此处yield返回，参数是resume的参数）</p></li><li><p>第二次resume，再次唤醒协同程序；（注意：此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）</p></li><li><p>yield返回；</p></li><li><p>协同程序继续运行；</p></li><li><p>如果使用的协同程序继续运行完成后继续调用 resume方法则输出：cannot resume dead coroutine</p></li></ul><p>resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</p><h3 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者—消费者问题</h3><pre class="highlight"><code class="lua"><span class="hljs-keyword">local</span> newProductor

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">productor</span><span class="hljs-params">()</span></span>
     <span class="hljs-keyword">local</span> i = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>
          i = i + <span class="hljs-number">1</span>
          send(i)     <span class="hljs-comment">-- 将生产的物品发送给消费者</span>
     <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>
          <span class="hljs-keyword">local</span> i = receive()     <span class="hljs-comment">-- 从生产者那里得到物品</span>
          <span class="hljs-built_in">print</span>(i)
     <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>
     <span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>, value = coroutine.<span class="hljs-built_in">resume</span>(newProductor)
     <span class="hljs-keyword">return</span> value
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span><span class="hljs-params">(x)</span></span>
     coroutine.<span class="hljs-built_in">yield</span>(x)     <span class="hljs-comment">-- x表示需要发送的值，值返回以后，就挂起该协同程序</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 启动程序</span>
newProductor = coroutine.<span class="hljs-built_in">create</span>(productor)
consumer()
</code></pre><p>以上实例执行输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>
<span class="hljs-number">13</span>
……
</code></pre><hr><h2 id="lua文件io"><a class="markdownIt-Anchor" href="#lua文件io"></a> 🍁Lua文件I/O</h2><p>Lua I/O库用于读取和处理文件。分为简单模式（和C一样）、完全模式</p><ul><li>简单模式(simple model)拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。</li><li>完全模式(complete model)使用外部的文件句柄来实现。它以一种面对对象的形式，将所有文件操作定义位文件句柄的方法。</li></ul><p>简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。</p><p>开文件操作如下：</p><pre class="highlight"><code class="lua">file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(filename[ , mode])
</code></pre><p>mode 的值有：</p><p><img data-src="http://lgqimg.changzer.cn/img/image-20221020215349667.png" alt="image-20221020215349667"></p><h3 id="简单模式"><a class="markdownIt-Anchor" href="#简单模式"></a> 简单模式</h3><p>简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。</p><p>以下为 file.lua 文件代码，操作的文件为test.lua(如果没有你需要创建该文件)，代码如下：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 以只读方式打开文件</span>
file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">"test.lua"</span>, <span class="hljs-string">"r"</span>)

<span class="hljs-comment">-- 设置默认输入文件为 test.lua</span>
<span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>(file)

<span class="hljs-comment">-- 输出文件第一行</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>())

<span class="hljs-comment">-- 关闭打开的文件</span>
<span class="hljs-built_in">io</span>.<span class="hljs-built_in">close</span>(file)

<span class="hljs-comment">-- 以附加的方式打开只写文件</span>
file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">"test.lua"</span>, <span class="hljs-string">"a"</span>)

<span class="hljs-comment">-- 设置默认输出文件为 test.lua</span>
<span class="hljs-built_in">io</span>.<span class="hljs-built_in">output</span>(file)

<span class="hljs-comment">-- 在文件最后一行添加 Lua 注释</span>
<span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">"--  test.lua 文件末尾注释"</span>)

<span class="hljs-comment">-- 关闭打开的文件</span>
<span class="hljs-built_in">io</span>.<span class="hljs-built_in">close</span>(file)
</code></pre><p>执行以上代码，你会发现，输出了 <span class="exturl" data-url="aHR0cDovL3Rlc3QudWE=">test.ua</span> 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- test.lua 文件</span>
</code></pre><p>在以上实例中我们使用了 io.“x” 方法，其中 io.read() 中我们没有带参数，参数可以是下表中的一个：</p><p><img data-src="http://lgqimg.changzer.cn/img/image-20221020220223782.png" alt="image-20221020220223782"></p><p>其他的 io 方法有：</p><ul><li><p>io.tmpfile():返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</p></li><li><p>io.type(file): 检测obj是否一个可用的文件句柄</p></li><li><p>io.flush(): 向文件写入缓冲中的所有数据</p></li><li><p>io.lines(optional file name): 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件</p></li></ul><h3 id="完全模式"><a class="markdownIt-Anchor" href="#完全模式"></a> 完全模式</h3><p>通常我们需要在同一时间处理多个文件。我们需要使用 <code>file:function_name</code> 来代替 <code>io.function_name</code> 方法。以下实例演示了如同同时处理同一个文件:</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 以只读方式打开文件</span>
file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">"test.lua"</span>, <span class="hljs-string">"r"</span>)

<span class="hljs-comment">-- 输出文件第一行</span>
<span class="hljs-built_in">print</span>(file:<span class="hljs-built_in">read</span>())

<span class="hljs-comment">-- 关闭打开的文件</span>
file:<span class="hljs-built_in">close</span>()

<span class="hljs-comment">-- 以附加的方式打开只写文件</span>
file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">"test.lua"</span>, <span class="hljs-string">"a"</span>)

<span class="hljs-comment">-- 在文件最后一行添加 Lua 注释</span>
file:<span class="hljs-built_in">write</span>(<span class="hljs-string">"--test"</span>)

<span class="hljs-comment">-- 关闭打开的文件</span>
file:<span class="hljs-built_in">close</span>()
</code></pre><p>执行以上代码，你会发现，输出了 <span class="exturl" data-url="aHR0cDovL3Rlc3QudWE=">test.ua</span> 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- test.lua 文件</span>
</code></pre><p>其他方法:</p><ul><li><p><code>**file:seek(optional whence, optional offset)</code>😗* 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是:</p></li><li><ul><li>“set”: 从文件头开始</li></ul></li><li><ul><li>“cur”: 从当前位置开始[默认]</li></ul></li><li><ul><li>“end”: 从文件尾开始</li></ul></li><li><ul><li>offset:默认为0</li></ul></li><li><p>不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小</p></li><li><p><code>file:flush()</code>: 向文件写入缓冲中的所有数据</p></li><li><p><code>io.lines(optional file name)</code>: 打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。</p></li><li><p>若不带参数时io.lines() &lt;=&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件,如</p></li><li><pre class="highlight"><code class="lua"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">lines</span>(<span class="hljs-string">"main.lua"</span>) <span class="hljs-keyword">do</span>

　　<span class="hljs-built_in">print</span>(line)

　　<span class="hljs-keyword">end</span>
</code></pre></li><li><p>以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当期位置(倒数第 25 个位置)读取整个文件。</p></li><li><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 以只读方式打开文件</span>
file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">"test.lua"</span>, <span class="hljs-string">"r"</span>)

file:seek(<span class="hljs-string">"end"</span>,<span class="hljs-number">-25</span>)
<span class="hljs-built_in">print</span>(file:<span class="hljs-built_in">read</span>(<span class="hljs-string">"*a"</span>))

<span class="hljs-comment">-- 关闭打开的文件</span>
file:<span class="hljs-built_in">close</span>()
</code></pre></li><li><p>我这边输出的结果是：</p></li><li><pre class="highlight"><code class="lua">st.lua 文件末尾<span class="hljs-comment">--test</span>
</code></pre></li></ul><hr><h2 id="lua-错误处理"><a class="markdownIt-Anchor" href="#lua-错误处理"></a> 🍁Lua 错误处理</h2><p>程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行。</p><p>任何程序语言中，都需要错误处理。错误类型有：</p><ul><li>语法错误</li><li>运行错误</li></ul><h3 id="语法错误"><a class="markdownIt-Anchor" href="#语法错误"></a> 语法错误</h3><p>语法错误通常是由于对程序的组件(如运算符、表达式)使用不当引起的。一个简单的示例如下：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">--test.lua文件</span>
a == <span class="hljs-number">2</span>
</code></pre><p>以上代码执行结果为：</p><pre class="highlight"><code class="lua">lua: test.lua:<span class="hljs-number">2</span>: syntax <span class="hljs-built_in">error</span> near <span class="hljs-string">'=='</span>
</code></pre><p>正如你看到的，以上出现了两个语法错误，一个“=”号跟两个“=”号是有区别的。一个“=”是赋值表达式，两个“=”是比较运算。另一个示例：</p><pre class="highlight"><code>for a=1,1,10
	print(a)
end
</code></pre><p>执行以上程序会出现如下错误：</p><pre class="highlight"><code class="lua">lua: test2.lua:<span class="hljs-number">2</span>: <span class="hljs-string">'do'</span> expected near <span class="hljs-string">'print'</span>
</code></pre><p>语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在for语句下添加 do 即可：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">for</span> a= <span class="hljs-number">1</span>,<span class="hljs-number">10</span>
<span class="hljs-keyword">do</span>
   <span class="hljs-built_in">print</span>(a)
<span class="hljs-keyword">end</span>
</code></pre><h3 id="运行错误"><a class="markdownIt-Anchor" href="#运行错误"></a> 运行错误</h3><p>运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b)</span></span>
	<span class="hljs-keyword">return</span> a+b
<span class="hljs-keyword">end</span>

add(<span class="hljs-number">10</span>)
</code></pre><p>当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误</p><pre class="highlight"><code class="lua">lua: test2.lua:<span class="hljs-number">2</span>: attempt to perform arithmetic on <span class="hljs-keyword">local</span> <span class="hljs-string">'b'</span> (a <span class="hljs-literal">nil</span> value)
stack <span class="hljs-built_in">traceback</span>:
    test2.lua:<span class="hljs-number">2</span>: <span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-keyword">function</span> '<span class="hljs-title">add</span>'
    <span class="hljs-title">test2.lua</span>:5: <span class="hljs-title">in</span> <span class="hljs-title">main</span> <span class="hljs-title">chunk</span>
    [<span class="hljs-title">C</span>]: ?
</span></code></pre><p>以下报错信息是由于程序缺少 b 参数引起的。b</p><h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3><p>我们可以使用两个函数：assert 和 error 来处理错误。实例如下：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b)</span></span>
    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">type</span>(a) == <span class="hljs-string">"number"</span>,<span class="hljs-string">"a不是一个数字"</span>)
    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">type</span>(b) == <span class="hljs-string">"number"</span>,<span class="hljs-string">"b不是一个数字"</span>)
    <span class="hljs-keyword">return</span> a+b
<span class="hljs-keyword">end</span>

add(<span class="hljs-number">10</span>)
</code></pre><p>执行以上程序会出现如下错误：</p><pre class="highlight"><code class="lua">lua: test.lua:<span class="hljs-number">3</span>: b 不是一个数字
stack <span class="hljs-built_in">traceback</span>:
    [C]: <span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-keyword">function</span> '<span class="hljs-title">assert</span>'
    <span class="hljs-title">test.lua</span>:3: <span class="hljs-title">in</span> <span class="hljs-title">local</span> '<span class="hljs-title">add</span>'
    <span class="hljs-title">test.lua</span>:6: <span class="hljs-title">in</span> <span class="hljs-title">main</span> <span class="hljs-title">chunk</span>
    [<span class="hljs-title">C</span>]: <span class="hljs-title">in</span> ?
</span></code></pre><p>实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。</p><h3 id="error函数"><a class="markdownIt-Anchor" href="#error函数"></a> error函数</h3><p>语法格式</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">error</span> (message [,level])
</code></pre><p>功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)</p><p>通常情况下，error会附加一下错误位置的信息到message头部</p><p>level参数指示获得错误的位置：</p><ul><li>level=1[默认]：为调用error位置(文件+行号)</li><li>rlevel=2：指出哪个调用error的函数的函数</li><li>level=0：不添加错误位置信息</li></ul><h3 id="pcall和xpacll-debug"><a class="markdownIt-Anchor" href="#pcall和xpacll-debug"></a> pcall和xpacll、debug</h3><p>Lua中处理错误，可以使用函数<code>pcall(protect call)</code>来包装需要执行的代码。pcall接受一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回true或者false，errorinfo。</p><p>语法格式如下：</p><pre class="highlight"><code class="lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">pcall</span>(function_name,...) <span class="hljs-keyword">then</span>
    <span class="hljs-comment">--没有错误</span>
<span class="hljs-keyword">else</span>
	<span class="hljs-comment">--一些错误</span>
<span class="hljs-keyword">end</span>
</code></pre><p>简单实例：</p><pre class="highlight"><code class="basic">&gt; =pcall(function(i) <span class="hljs-keyword">print</span>(i) <span class="hljs-keyword">end</span>, <span class="hljs-number">33</span>)
<span class="hljs-number">33</span>
true
   
&gt; =pcall(function(i) <span class="hljs-keyword">print</span>(i) <span class="hljs-keyword">error</span>(<span class="hljs-comment">'error..') end, 33)</span>
<span class="hljs-number">33</span>
false        stdin:<span class="hljs-number">1</span>: <span class="hljs-keyword">error</span>..
</code></pre><pre class="highlight"><code class="basic">&gt; function f() <span class="hljs-keyword">return</span> false,<span class="hljs-number">2</span> <span class="hljs-keyword">end</span>
&gt; <span class="hljs-keyword">if</span> f() <span class="hljs-keyword">then</span> <span class="hljs-keyword">print</span> <span class="hljs-comment">'1' else print '0' end</span>
<span class="hljs-number">0</span>
</code></pre><p>pcall以一种&quot;保护模式&quot;来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。</p><p>Lua提供了<code>xpcall</code>函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p><p><code>debug</code>库提供了两个通用的错误处理函数:</p><ul><li><p>debug.debug：提供一个Lua提示符，让用户来检查错误的原因</p></li><li><p>debug.traceback：根据调用桟来构建一个扩展的错误消息</p></li></ul><p>xpcall 使用实例 2:</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">()</span></span>
   n = n/<span class="hljs-literal">nil</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myerrorhandler</span><span class="hljs-params">( err )</span></span>
   <span class="hljs-built_in">print</span>( <span class="hljs-string">"ERROR:"</span>, err )
<span class="hljs-keyword">end</span>

<span class="hljs-built_in">status</span> = <span class="hljs-built_in">xpcall</span>( myfunction, myerrorhandler )
<span class="hljs-built_in">print</span>( <span class="hljs-built_in">status</span>)
</code></pre><p>执行以上程序会出现如下错误：</p><pre class="highlight"><code class="basic"><span class="hljs-keyword">ERROR</span>:    test2.lua:<span class="hljs-number">2</span>: attempt <span class="hljs-keyword">to</span> perform arithmetic <span class="hljs-keyword">on</span> global <span class="hljs-comment">'n' (a nil value)</span>
false
</code></pre><hr><h2 id="lua调试debug"><a class="markdownIt-Anchor" href="#lua调试debug"></a> 🍁 Lua调试(Debug)</h2><p>Lua提供了debug库用于提供创建我们自定义调试器的功能。Lua本身并未有内置的调试器，但很多开发者共享了他们的Lua调试代码。</p><p>Lua中debug库包含以下函数：</p><p><img data-src="http://lgqimg.changzer.cn/img/image-20221028193248563.png" alt="image-20221028193248563"></p></div><p></p><p>上表列出了我们常用的调试函数，接下来我们可以看些简单的例子：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myfunction</span><span class="hljs-params">()</span></span>
	<span class="hljs-built_in">print</span>(<span class="hljs-built_in">debug</span>.tracrback(<span class="hljs-string">"Stack trace"</span>))
	<span class="hljs-built_in">print</span>(<span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getinfo</span>(<span class="hljs-number">1</span>))
	<span class="hljs-built_in">print</span>(<span class="hljs-string">"Stack trace end"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">end</span>
myfunction()
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getinfo</span>())
</code></pre><p>执行以上代码输出结果为：</p><pre class="highlight"><code class="lua">Stack trace
stack <span class="hljs-built_in">traceback</span>:
    test2.lua:<span class="hljs-number">2</span>: <span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-keyword">function</span> '<span class="hljs-title">myfunction</span>'
    <span class="hljs-title">test2.lua</span>:8: <span class="hljs-title">in</span> <span class="hljs-title">main</span> <span class="hljs-title">chunk</span>
    [<span class="hljs-title">C</span>]: ?
<span class="hljs-title">table</span>: 0054<span class="hljs-title">C6C8</span>
<span class="hljs-title">Stack</span> <span class="hljs-title">trace</span> <span class="hljs-title">end</span>
</span></code></pre><p>在以实例中，我们使用到了 debug 库的 traceback 和 getinfo 函数， getinfo 函数用于返回函数信息的表。</p><p><strong>另一个实例</strong></p><p>我们经常需要调用函数的内部的局部变量。我们getupvalue函数来函数来设置这些变量。实例如下：</p><pre class="highlight"><code class="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newCounter</span> <span class="hljs-params">()</span></span>
  <span class="hljs-keyword">local</span> n = <span class="hljs-number">0</span>
  <span class="hljs-keyword">local</span> k = <span class="hljs-number">0</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>
    k = n
    n = n + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> n
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

counter = newCounter ()
<span class="hljs-built_in">print</span>(counter())
<span class="hljs-built_in">print</span>(counter())

<span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span>

<span class="hljs-keyword">repeat</span>
  name, val = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getupvalue</span>(counter, i)
  <span class="hljs-keyword">if</span> name <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">print</span> (<span class="hljs-string">"index"</span>, i, name, <span class="hljs-string">"="</span>, val)
    <span class="hljs-keyword">if</span>(name == <span class="hljs-string">"n"</span>) <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">setupvalue</span> (counter,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>)
    <span class="hljs-keyword">end</span>
    i = i + <span class="hljs-number">1</span>
  <span class="hljs-keyword">end</span> <span class="hljs-comment">-- if</span>
<span class="hljs-keyword">until</span> <span class="hljs-keyword">not</span> name

<span class="hljs-built_in">print</span>(counter())
</code></pre><p>执行以上代码输出结果为：</p><pre class="highlight"><code class="lua"><span class="hljs-number">1</span>
<span class="hljs-number">2</span>
index    <span class="hljs-number">1</span>    k    =    <span class="hljs-number">1</span>
index    <span class="hljs-number">2</span>    n    =    <span class="hljs-number">2</span>
<span class="hljs-number">11</span>
</code></pre><p>在以上实例中，计数器在每次调用时都会自增1。实例中我们使用了 getupvalue 函数查看局部变量的当前状态。我们可以设置局部变量为新值。实例中，在设置前 n 的值为 2,使用 setupvalue 函数将其设置为 10。现在我们调用函数，执行后输出为 11 而不是 3。</p><h3 id="调试类型"><a class="markdownIt-Anchor" href="#调试类型"></a> 调试类型</h3><ul><li><p>命令行调试</p></li><li><p>图形界面调试</p></li></ul><p>命令行调试器有：RemDebug、clidebugger、ctrace、xdbLua、LuaInterface - Debugger、Rldb、ModDebug。</p><p>图形界调试器有：SciTE、Decoda、ZeroBrane Studio、akdebugger、luaedit。</p><hr><h2 id="lua-面向对象"><a class="markdownIt-Anchor" href="#lua-面向对象"></a> 🍁Lua 面向对象</h2><h3 id="面向对象的特征"><a class="markdownIt-Anchor" href="#面向对象的特征"></a> 面向对象的特征</h3><ol><li>封装：指能把一个实体的信息、功能、响应都装入一个单独的对象中的特性</li><li>继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能得以拓展。这有利于减少重复编码，提高软件的开发效率。</li><li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</li><li>抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</li></ol><h3 id="lua中面向对象"><a class="markdownIt-Anchor" href="#lua中面向对象"></a> Lua中面向对象</h3><p>我们知道，对象由属性和方法组成。Lua中最基本的结构是table，所以需要用table来描述对象的属性。Lua中的function可以用来表示方法。那么Lua中的类可以通过table+function模拟出来。至于继承可以通过metatable模拟出来。</p><p>Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有对象（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以拥有的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：</p><pre class="highlight"><code class="lua">Account = &#123;balance = <span class="hljs-number">0</span>&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account.withdraw</span> <span class="hljs-params">(v)</span></span>
    Account.balance = Account.blance - v
<span class="hljs-keyword">end</span>
</code></pre><p>这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：</p><pre class="highlight"><code class="lua">Account.withdraw(<span class="hljs-number">100.00</span>)
</code></pre><h3 id="一个简单实例"><a class="markdownIt-Anchor" href="#一个简单实例"></a> 一个简单实例</h3><p>以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- Meta class</span>
Rectangle = &#123;area = <span class="hljs-number">0</span>, length = <span class="hljs-number">0</span>, breadth = <span class="hljs-number">0</span>&#125;

<span class="hljs-comment">-- 派生类的方法 new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle:new</span> <span class="hljs-params">(o,length,breadth)</span></span>
  o = o <span class="hljs-keyword">or</span> &#123;&#125;
    
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  self.length = length <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
  self.breadth = breadth <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
  self.area = length*breadth;
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 派生类的方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"矩形面积为 "</span>,self.area)
<span class="hljs-keyword">end</span>
</code></pre><h4 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h4><p>创建对象是为类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。</p><pre class="highlight"><code class="lua">r = Rectangle:new(<span class="hljs-literal">nil</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)
</code></pre><h4 id="访问属性"><a class="markdownIt-Anchor" href="#访问属性"></a> 访问属性</h4><p>我们可以使用点号（.）来访问类的属性</p><pre class="highlight"><code class="lua"><span class="hljs-built_in">print</span>(r.lenght)
</code></pre><h4 id="访问成员"><a class="markdownIt-Anchor" href="#访问成员"></a> 访问成员</h4><p>我们可以使用冒号 : 来访问类的成员函数：</p><pre class="highlight"><code class="lua">r:printArea()
</code></pre><h4 id="完整实例"><a class="markdownIt-Anchor" href="#完整实例"></a> 完整实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">-- Meta class</span>
Shape = &#123;area = <span class="hljs-number">0</span>&#125;

<span class="hljs-comment">-- 基础类方法 new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:new</span> <span class="hljs-params">(o,side)</span></span>
  o = o <span class="hljs-keyword">or</span> &#123;&#125;
    
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  side = side <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
  self.area = side*side;
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 基础类方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"面积为 "</span>,self.area)
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 创建对象</span>
myshape = Shape:new(<span class="hljs-literal">nil</span>,<span class="hljs-number">10</span>)

myshape:printArea()
</code></pre><p>执行以上程序，输出结果为：</p><pre class="highlight"><code class="lua">面积为   <span class="hljs-number">100</span>
</code></pre><h3 id="lua继承"><a class="markdownIt-Anchor" href="#lua继承"></a> Lua继承</h3><p>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。以下演示了一个简单的继承实例：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- Meta class</span>
Shape = &#123;area = <span class="hljs-number">0</span>&#125;
<span class="hljs-comment">-- 基础类方法 new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:new</span> <span class="hljs-params">(o,side)</span></span>
  o = o <span class="hljs-keyword">or</span> &#123;&#125;
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  side = side <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
  self.area = side*side;
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>
<span class="hljs-comment">-- 基础类方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"面积为 "</span>,self.area)
<span class="hljs-keyword">end</span>
</code></pre><p>接下来的实例，Square 对象继承了 Shape 类:</p><pre class="highlight"><code class="lua">Square = Shape:new()
<span class="hljs-comment">-- Derived class method new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square:new</span> <span class="hljs-params">(o,side)</span></span>
  o = o <span class="hljs-keyword">or</span> Shape:new(o,side)
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>
</code></pre><h4 id="完整实例-2"><a class="markdownIt-Anchor" href="#完整实例-2"></a> 完整实例</h4><pre class="highlight"><code class="lua"><span class="hljs-comment">-- Meta class</span>
Shape = &#123;area = <span class="hljs-number">0</span>&#125;
<span class="hljs-comment">-- 基础类方法 new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:new</span> <span class="hljs-params">(o,side)</span></span>
  o = o <span class="hljs-keyword">or</span> &#123;&#125;
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  side = side <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
  self.area = side*side;
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>
<span class="hljs-comment">-- 基础类方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"面积为 "</span>,self.area)
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 创建对象</span>
myshape = Shape:new(<span class="hljs-literal">nil</span>,<span class="hljs-number">10</span>)
myshape:printArea()

Square = Shape:new()
<span class="hljs-comment">-- 派生类方法 new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square:new</span> <span class="hljs-params">(o,side)</span></span>
  o = o <span class="hljs-keyword">or</span> Shape:new(o,side)
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 派生类方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"正方形面积为 "</span>,self.area)
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 创建对象</span>
mysquare = Square:new(<span class="hljs-literal">nil</span>,<span class="hljs-number">10</span>)
mysquare:printArea()

Rectangle = Shape:new()
<span class="hljs-comment">-- 派生类方法 new</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle:new</span> <span class="hljs-params">(o,length,breadth)</span></span>
  o = o <span class="hljs-keyword">or</span> Shape:new(o)
  <span class="hljs-built_in">setmetatable</span>(o, self)
  self.<span class="hljs-built_in">__index</span> = self
  self.area = length * breadth
  <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 派生类方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"矩形面积为 "</span>,self.area)
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- 创建对象</span>
myrectangle = Rectangle:new(<span class="hljs-literal">nil</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)
myrectangle:printArea()
</code></pre><p>执行以上代码，输出结果为：</p><pre class="highlight"><code class="lua">面积为     <span class="hljs-number">100</span>
正方形面积为     <span class="hljs-number">100</span>
矩形面积为     <span class="hljs-number">200</span>
</code></pre><h3 id="函数重写"><a class="markdownIt-Anchor" href="#函数重写"></a> 函数重写</h3><p>Lua 中我们可以重写基础类的函数，在派生类中定义自己的实现方式：</p><pre class="highlight"><code class="lua"><span class="hljs-comment">-- 派生类方法 printArea</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square:printArea</span> <span class="hljs-params">()</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"正方形面积 "</span>,self.area)
<span class="hljs-keyword">end</span>
</code></pre><div class="tags"><a href="/tags/Lua/" rel="tag"><i class="ic i-tag"></i> Lua</a></div></article></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-29 17:37:00" itemprop="dateModified" datetime="2022-10-29T17:37:00+08:00">2022-10-29</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Maple <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://maplelearc.github.io/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/" title="Lua 入门学习">https://maplelearc.github.io/2022/10/08/Lua学习/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></div><div class="post-nav"><div class="item left"><a href="/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexj2jgzj20zk0m8b09.jpg" title="CSAPP:第一章"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> CSAPP</span><h3>CSAPP:第一章</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lua-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Lua 入门学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">🍁Lua 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">交互式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">脚本编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.3.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">单行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">多行注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.1.4.</span> <span class="toc-text">标示符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">关键词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.5.</span> <span class="toc-text">全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">🍁Lua 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nil%E7%A9%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">nil(空)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolean"><span class="toc-number">1.2.2.</span> <span class="toc-text">boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#number%E6%95%B0%E5%AD%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">number(数字)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.4.</span> <span class="toc-text">string(字符串)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E8%A1%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">table(表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">function(函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">thread(线程)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#userdata%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">userdata(自定义类型)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">🍁Lua 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">赋值语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.</span> <span class="toc-text">🍁Lua 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">while 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">数值 for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">泛型 for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#repeatuntil-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">repeat…until 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">嵌套循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.5.</span> <span class="toc-text">break 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-5"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">🍁Lua 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">if 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-6"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifelse-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">if…else 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-7"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifelse-ifelse-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.3.</span> <span class="toc-text">if…else if…else 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E5%B5%8C%E5%A5%97%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.4.</span> <span class="toc-text">if 嵌套语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-9"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">🍁Lua 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-10"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.6.2.</span> <span class="toc-text">多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.3.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">🍁Lua 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.1.</span> <span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.4.</span> <span class="toc-text">其他运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.7.5.</span> <span class="toc-text">运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.8.</span> <span class="toc-text">🍁Lua 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.1.</span> <span class="toc-text">字符串操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.8.2.</span> <span class="toc-text">字符串格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text">🍁Lua数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.10.</span> <span class="toc-text">🍁Lua垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">垃圾回收器函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE"><span class="toc-number">1.11.</span> <span class="toc-text">🍁Lua数据库访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.12.</span> <span class="toc-text">🍁Lua迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8Bfor%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.12.1.</span> <span class="toc-text">泛型for迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.12.2.</span> <span class="toc-text">无状态的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.12.3.</span> <span class="toc-text">多状态的迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-table%E8%A1%A8"><span class="toc-number">1.13.</span> <span class="toc-text">🍁Lua table(表)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.13.1.</span> <span class="toc-text">table(表)的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E6%93%8D%E4%BD%9C"><span class="toc-number">1.13.2.</span> <span class="toc-text">Table操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.13.3.</span> <span class="toc-text">Table连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E7%A7%BB%E9%99%A4"><span class="toc-number">1.13.4.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.5.</span> <span class="toc-text">Table排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.13.6.</span> <span class="toc-text">Table最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E5%8E%BB%E9%87%8D"><span class="toc-number">1.13.7.</span> <span class="toc-text">Table去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85"><span class="toc-number">1.14.</span> <span class="toc-text">🍁Lua模块与包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#require%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.1.</span> <span class="toc-text">require函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.14.2.</span> <span class="toc-text">加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%8C%85"><span class="toc-number">1.14.3.</span> <span class="toc-text">C包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E5%85%83%E8%A1%A8metatable"><span class="toc-number">1.15.</span> <span class="toc-text">🍁Lua元表(Metatable)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#__index%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.15.1.</span> <span class="toc-text">__index元方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__newindex%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.15.2.</span> <span class="toc-text">__newindex元方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E8%A1%A8%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.15.3.</span> <span class="toc-text">为表添加操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__call%E6%96%B9%E6%B3%95"><span class="toc-number">1.15.4.</span> <span class="toc-text">__call方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__tostring%E6%96%B9%E6%B3%95"><span class="toc-number">1.15.5.</span> <span class="toc-text">__tostring方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8Fcoroutine"><span class="toc-number">1.16.</span> <span class="toc-text">🍁Lua协同程序(coroutine)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%90%8Ccoroutine"><span class="toc-number">1.16.1.</span> <span class="toc-text">什么是协同(coroutine)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.2.</span> <span class="toc-text">线程与协同程序的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.16.3.</span> <span class="toc-text">基本术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.16.4.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.16.5.</span> <span class="toc-text">生产者—消费者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E6%96%87%E4%BB%B6io"><span class="toc-number">1.17.</span> <span class="toc-text">🍁Lua文件I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.17.1.</span> <span class="toc-text">简单模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.17.2.</span> <span class="toc-text">完全模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.18.</span> <span class="toc-text">🍁Lua 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"><span class="toc-number">1.18.1.</span> <span class="toc-text">语法错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF"><span class="toc-number">1.18.2.</span> <span class="toc-text">运行错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.18.3.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.4.</span> <span class="toc-text">error函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcall%E5%92%8Cxpacll-debug"><span class="toc-number">1.18.5.</span> <span class="toc-text">pcall和xpacll、debug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E8%B0%83%E8%AF%95debug"><span class="toc-number">1.19.</span> <span class="toc-text">🍁 Lua调试(Debug)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.19.1.</span> <span class="toc-text">调试类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.20.</span> <span class="toc-text">🍁Lua 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.20.1.</span> <span class="toc-text">面向对象的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.20.2.</span> <span class="toc-text">Lua中面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.20.3.</span> <span class="toc-text">一个简单实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.20.3.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.20.3.2.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98"><span class="toc-number">1.20.3.3.</span> <span class="toc-text">访问成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.20.3.4.</span> <span class="toc-text">完整实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E7%BB%A7%E6%89%BF"><span class="toc-number">1.20.4.</span> <span class="toc-text">Lua继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">1.20.4.1.</span> <span class="toc-text">完整实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99"><span class="toc-number">1.20.5.</span> <span class="toc-text">函数重写</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/" rel="bookmark" title="Lua入门学习">Lua入门学习</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Maple" data-src="/images/avatar(1).png"><p class="name" itemprop="name">Maple</p><div class="description" itemprop="description">Maple 的编程学习</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">9</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcGxlbGVhcmM=" title="https:&#x2F;&#x2F;github.com&#x2F;maplelearc"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOm1hcGxlbGVhcmNAZ21haWwuY29t" title="mailto:maplelearc@gmail.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></main></div><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 计算机语言学习">计算机语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Lua/" title="分类于 Lua">Lua</a></div><span><a href="/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/" title="Lua入门学习">Lua入门学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSAPP/" title="分类于 CSAPP">CSAPP</a></div><span><a href="/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/" title="CSAPP:第一章">CSAPP:第一章</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2022/10/03/NetWork/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/" title="《计算机网络：自定向下》第三章：传输层">《计算机网络：自定向下》第三章：传输层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 计算机语言学习">计算机语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/SQL%E8%AF%AD%E8%A8%80/" title="分类于 SQL 语言">SQL 语言</a></div><span><a href="/2022/10/04/Mysql/" title="MySql">MySql</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="分类于 计算机语言学习">计算机语言学习</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C/" title="分类于 C#">C#</a></div><span><a href="/2022/10/03/%E3%80%8ACS%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9/" title="《C#图解教程》阅读记忆点">《C#图解教程》阅读记忆点</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法和数据结构">算法和数据结构</a></div><span><a href="/2022/10/03/%E7%AE%97%E6%B3%95/" title="算法和数据结构">算法和数据结构</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSAPP/" title="分类于 CSAPP">CSAPP</a></div><span><a href="/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/" title="CSAPP:第二章">CSAPP:第二章</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2022/10/03/NetWork/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/" title="《计算机网络：自定向下》第二章：应用层">《计算机网络：自定向下》第二章：应用层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2022/10/03/NetWork/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A6%82%E8%BF%B0/" title="《计算机网络：自定向下》第一章：概述">《计算机网络：自定向下》第一章：概述</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Maple @ Maple Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer><script data-config type="text/javascript">var LOCAL={path:"2022/10/08/Lua学习/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>