<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《C#图解教程》阅读记忆点 | Maple Blog</title><meta name="keywords" content="C#"><meta name="author" content="Maple"><meta name="copyright" content="Maple"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《C#图解教程》阅读记忆点一、数据类型1. 栈和堆 栈  堆    堆是一块内存区域,在堆里可以分配大块的内存用于存储某种类型的数据对象.堆中的内存能够以任意顺序存入和移除. CLR 的自动垃圾收集器在判断出程序的代码不在访问某项数据时,会自动清除无主的堆对象.  2. 值类型和引用类型 C#中数据分为值类型和引用类型。这两种类型的对象在内存中的存储方式不同 值类型只需要一段单独的内存，它总是位于">
<meta property="og:type" content="article">
<meta property="og:title" content="《C#图解教程》阅读记忆点">
<meta property="og:url" content="https://maplelearc.github.io/2022/10/03/%E3%80%8ACS%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Maple Blog">
<meta property="og:description" content="《C#图解教程》阅读记忆点一、数据类型1. 栈和堆 栈  堆    堆是一块内存区域,在堆里可以分配大块的内存用于存储某种类型的数据对象.堆中的内存能够以任意顺序存入和移除. CLR 的自动垃圾收集器在判断出程序的代码不在访问某项数据时,会自动清除无主的堆对象.  2. 值类型和引用类型 C#中数据分为值类型和引用类型。这两种类型的对象在内存中的存储方式不同 值类型只需要一段单独的内存，它总是位于">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-03T07:00:03.631Z">
<meta property="article:modified_time" content="2022-10-03T11:29:09.062Z">
<meta property="article:author" content="Maple">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/thumbbig-10411.webp"><link rel="canonical" href="https://maplelearc.github.io/2022/10/03/%E3%80%8ACS%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#FFFAFA","bgDark":"#1f1f1f","position":"top-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C#图解教程》阅读记忆点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-03 19:29:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar(1).png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Maple Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C#图解教程》阅读记忆点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-03T07:00:03.631Z" title="发表于 2022-10-03 15:00:03">2022-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-03T11:29:09.062Z" title="更新于 2022-10-03 19:29:09">2022-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C#图解教程》阅读记忆点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="《C-图解教程》阅读记忆点"><a href="#《C-图解教程》阅读记忆点" class="headerlink" title="《C#图解教程》阅读记忆点"></a>《C#图解教程》阅读记忆点</h1><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-栈和堆"><a href="#1-栈和堆" class="headerlink" title="1. 栈和堆"></a>1. 栈和堆</h3><ol>
<li><p>栈<br><img src="http://lgqimg.changzer.cn/image-20220913201351108.png" alt="image-20220913201351108"></p>
</li>
<li><p>堆</p>
</li>
</ol>
<ul>
<li>堆是一块内存区域,在堆里可以分配大块的内存用于存储某种类型的数据对象.堆中的内存能够以任意顺序存入和移除.</li>
<li>CLR 的自动垃圾收集器在判断出程序的代码不在访问某项数据时,会自动清除无主的堆对象.<br><img src="http://lgqimg.changzer.cn/image-20220913201848664.png" alt="image-20220913201848664"></li>
</ul>
<h3 id="2-值类型和引用类型"><a href="#2-值类型和引用类型" class="headerlink" title="2. 值类型和引用类型"></a>2. 值类型和引用类型</h3><ul>
<li>C#中数据分为值类型和引用类型。这两种类型的对象在内存中的存储方式不同</li>
<li>值类型只需要一段单独的内存，它总是位于堆中。</li>
<li>引用类型需要两段内存。第一段存储的实际数据总是存储在堆中。第二段的是一个引用，指向数据在堆中的从存放位置。<br><img src="http://lgqimg.changzer.cn/image-20220913200717360.png" alt="image-20220913200717360"></li>
<li><img src="http://lgqimg.changzer.cn/image-20220913205013024.png" alt="image-20220913205013024"></li>
</ul>
<h3 id="3-嵌套快中的局部变量"><a href="#3-嵌套快中的局部变量" class="headerlink" title="3. 嵌套快中的局部变量"></a>3. 嵌套快中的局部变量</h3><ul>
<li>可以有任意数量的块,并且他们既可以是顺序的也可以是嵌套的.块可以嵌套到任何级别.</li>
<li>局部变量可以在嵌套块的内部声明,并且和所有的局部变量一样,他们的生存期和可见性仅局限与声明它们的块及其内嵌快.<br><img src="http://lgqimg.changzer.cn/image-20220913204838044.png" alt="image-20220913204838044"></li>
</ul>
<h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><h3 id="1-方法的引用参数和值参数"><a href="#1-方法的引用参数和值参数" class="headerlink" title="1. 方法的引用参数和值参数"></a>1. 方法的引用参数和值参数</h3><p>1.值参数</p>
<ul>
<li><p>在方法使用值参数,在方法被调用时，系统在栈中为形参分配空间，并将实参的值赋值给形参。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">calss MyCalss</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calss Program</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params">MyCalss f1,<span class="built_in">int</span> f2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val=f1.Val+<span class="number">5</span>;</span><br><span class="line">        f2=f2+<span class="number">5</span>;</span><br><span class="line">        ConSole.WriteLine(<span class="string">$&quot;f1.Val:<span class="subst">&#123;f1.Val&#125;</span>，f2:<span class="subst">&#123;f2&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1=<span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        MyMethod(a1,a2);</span><br><span class="line">        ConSole.WriteLine(<span class="string">$&quot;a1.Val:<span class="subst">&#123;a1.Val&#125;</span>，a2:<span class="subst">&#123;a2&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出为</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.Val:&#123;<span class="number">25</span>&#125;，f2:&#123;<span class="number">15</span>&#125;</span><br><span class="line">a1.Val:&#123;<span class="number">25</span>&#125;，a2:&#123;<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>

<p>结果表示：</p>
<ul>
<li>在方法被调用前，用作实参的变量 a2 已经在栈里面了。</li>
<li>在方法开始时，系统在栈中为形参分配空间，并从实参复制值。<ul>
<li>因为 a1 是引用类型的，所以引用被复制，结果实参和形参都引用堆中的同一数据。</li>
<li>因为 a2 是值类型的，所以值被复制，产生了一个独立的数据项。</li>
</ul>
</li>
<li>在方法的结尾，f2 和对象 f1 的字段都被加上了 5.<ul>
<li>方法执行后，形参从栈出弹出。</li>
<li>a2，值类型，它的值不受方法行为的影响。</li>
<li>a1，引用类型，但它的值被方法的行为改变了。</li>
</ul>
</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220913213459760.png" alt="image-20220913213459760"></p>
</li>
</ul>
<ol start="2">
<li>引用参数</li>
</ol>
<ul>
<li><p>使用引用参数时，必须在方法的声明和调和中都使用<strong>ref</strong>修饰符。</p>
</li>
<li><p>实参必须是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或<strong>null</strong>。</p>
</li>
<li><p>方法使用引用参数时，系统不会再栈上位形参分配内存，形参的参数名将作为实参变量名，指向相同的内存位置。</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">calss MyCalss</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calss Program</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"><span class="keyword">ref</span> MyCalss f1,<span class="keyword">ref</span> <span class="built_in">int</span> f2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val=f1.Val+<span class="number">5</span>;</span><br><span class="line">        f2=f2+<span class="number">5</span>;</span><br><span class="line">        ConSole.WriteLine(<span class="string">$&quot;f1.Val:<span class="subst">&#123;f1.Val&#125;</span>，f2:<span class="subst">&#123;f2&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1=<span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        MyMethod(<span class="keyword">ref</span> a1,<span class="keyword">ref</span> a2);</span><br><span class="line">        ConSole.WriteLine(<span class="string">$&quot;a1.Val:<span class="subst">&#123;a1.Val&#125;</span>，a2:<span class="subst">&#123;a2&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.Val:&#123;<span class="number">25</span>&#125;，f2:&#123;<span class="number">15</span>&#125;</span><br><span class="line">a1.Val:&#123;<span class="number">25</span>&#125;，a2:&#123;<span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure>

<p>结果表示：</p>
<ul>
<li><p>在方法调用前，将要被用作实参的便改良 a1 和 a2 已经栈里了。</p>
</li>
<li><p>在方法的开始，形参名被设置位实参的别名。变量 a1 和 f1 引用相同的内存位置，a2 和 f2 引用相同的内存位置。</p>
</li>
<li><p>在方法的结束位置，f2 和 f1 的对象的字段都被加上了 5。</p>
</li>
<li><p>方法被执行后，形参的名称已经失效，但是值类型 a2 的值和引用类型 a1 所指向的对象的值都被方法内的行为改变了。</p>
<p><img src="http://lgqimg.changzer.cn/image-20220913215058035.png" alt="image-20220913215058035"></p>
</li>
</ul>
<h3 id="2-引用类型作为值参数和引用参数"><a href="#2-引用类型作为值参数和引用参数" class="headerlink" title="2. 引用类型作为值参数和引用参数"></a>2. 引用类型作为值参数和引用参数</h3><ol>
<li>引用类型作为值参数</li>
</ol>
<ul>
<li><p>将引用类型对象作为值参数传递如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且在方法调用结束后，新对象也将不复存在。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReFAsParameter</span>(<span class="params">MyClass f1</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val = <span class="number">50</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After member assignment：<span class="subst">&#123;f1.Val&#125;</span>&quot;</span>);</span><br><span class="line">        f1=<span class="keyword">new</span> MyClass();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After new object cretion：<span class="subst">&#123;f1.Val&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before method call：<span class="subst">&#123;a1.Val&#125;</span>&quot;</span>);</span><br><span class="line">        ReFAsParameter(a1);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After method call：<span class="subst">&#123;a1.Val&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before method call：<span class="number">20</span></span><br><span class="line">After member assignment：<span class="number">50</span></span><br><span class="line">After <span class="keyword">new</span> <span class="built_in">object</span> cretion：<span class="number">20</span></span><br><span class="line">After method call：<span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>结果表明：</p>
<ul>
<li><p>在方法开始时，实参和形参指向堆中的相同对象</p>
</li>
<li><p>在位对象成员赋值之后，他们仍指向堆中相同的对象</p>
</li>
<li><p>当方法分配新的对象并复制给形参时，方法外部的实参仍指向原时对象，而形参指向的是新对象</p>
</li>
<li><p>在方法调用之后，实参指向原时对象，形参和新对象都会消失</p>
<p><img src="http://lgqimg.changzer.cn/image-20220913221643242.png" alt="image-20220913221643242"></p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>引用类型作为引用参数</li>
</ol>
<ul>
<li><p>将引用类型对象作为引用参数传递如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReFAsParameter</span>(<span class="params"><span class="keyword">ref</span> MyClass f1</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val = <span class="number">50</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After member assignment：<span class="subst">&#123;f1.Val&#125;</span>&quot;</span>);</span><br><span class="line">        f1=<span class="keyword">new</span> MyClass();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After new object cretion：<span class="subst">&#123;f1.Val&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before method call：<span class="subst">&#123;a1.Val&#125;</span>&quot;</span>);</span><br><span class="line">        ReFAsParameter(<span class="keyword">ref</span> a1);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After method call：<span class="subst">&#123;a1.Val&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before method call：<span class="number">20</span></span><br><span class="line">After member assignment：<span class="number">50</span></span><br><span class="line">After <span class="keyword">new</span> <span class="built_in">object</span> cretion：<span class="number">20</span></span><br><span class="line">After method call：<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>结果表示：</p>
<ul>
<li>在方法调用时，形参和实参指向堆中相同的对象。</li>
<li>对成员值的修改会同时影响到形参和实参。</li>
<li>当方法创建新的对象并赋值给形参时，形参和实参的引用都指向该新对象。</li>
<li>在方法结束后，实参指向在方法内创建的新对象<br><img src="http://lgqimg.changzer.cn/image-20220913221820856.png" alt="image-20220913221820856"></li>
</ul>
</li>
</ul>
<h3 id="3-输出参数"><a href="#3-输出参数" class="headerlink" title="3. 输出参数"></a>3. 输出参数</h3><ol>
<li><p>输出参数用于从方法体内把数据传出到调用代码，他们的行为与引用参数类似。如同引用参数，输出参数有以下要求：</p>
<ul>
<li><p>必须声明和调用中都使用修饰符。输出参数的修饰符是<strong>out</strong>。</p>
</li>
<li><p>和引用参数相似，实参必须是变量，而不能是其他类型的表达式。因为方法需要内存位置来保存返回值。<br>例子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> val</span>)</span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">1</span>;</span><br><span class="line">MyMethod(<span class="keyword">out</span> y );</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出参数的形参充当实参的别名。形参与实参都是同一块内存位置的名称。</p>
</li>
</ul>
</li>
<li><p>输出参数规则</p>
<ul>
<li>在方法内部，给输出参数赋值之后才能读取它。这意味着参数的初始值的无关的，而且没有必要再方法调用之前为实参赋值。</li>
<li>在方法内部，再方法返回之前，代码中每条可能的路径都必须为所有输出参数赋值。</li>
</ul>
</li>
</ol>
<h3 id="4-参数数组"><a href="#4-参数数组" class="headerlink" title="4. 参数数组"></a>4. 参数数组</h3><ol>
<li><p>参数数组允许特定的零个或多个实参定义一个特定的形参。</p>
<ul>
<li><p>一个参数列表中只能有一个参数列表</p>
</li>
<li><p>如果有，它必须是列表中的最后一个</p>
</li>
<li><p>有参数数组表示的所有参数必须是同一个类型的</p>
</li>
<li><p>声明参数数组时，必须：</p>
<ul>
<li><p>在数据类型前使用<strong>params</strong>修饰符</p>
</li>
<li><p>再数据后放置空的方括号</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInit</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] inVals</span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>方法调用</p>
<ul>
<li><p><strong>可以使用一个用逗号分隔的相应数据类型的列表。</strong>被称为<strong>延伸式</strong>可在调用中使用独立的实参。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListInit(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用一个参数数组使用独立参数的调用时，编译器会执行：<ol>
<li>接受参数列表，用它们在堆中创建并初始化一个数组。</li>
<li>把数组的引用报存到栈中的形参里。</li>
<li>如果在对应形参数组的位置没有实参，编译器会创建一个有零个元素的数组使用</li>
</ol>
</li>
<li>如果数组参数是值类型，那么值被复制，实参在方法内部不受影响。如果数组参数是引用类型，那么引用被复制，实参引用的对象在方祛内部会受到影响。</li>
</ul>
</li>
<li><p><strong>一个相应数据类型的一维数组。</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArrary=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ListInit(intArrary);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="5-ref局部变量和ref返回"><a href="#5-ref局部变量和ref返回" class="headerlink" title="5. ref局部变量和ref返回"></a>5. <em>ref</em>局部变量和<em>ref</em>返回</h3><ol>
<li><p><strong>ref</strong>局部变量</p>
<ul>
<li>ref 局部变量可以创建一个变量的别名，即引用的对象是值类型。</li>
<li>对任意一个变量的赋值都会反映到另一个变量上。因为两个的引用对象是相同的，即使是值类型也如此。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ref</span> <span class="built_in">int</span> y =<span class="keyword">ref</span> x; <span class="comment">//创建int变量x，别名为y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ref</strong>返回</p>
<ul>
<li><p>使用 ref 返回，也要使用两次<strong>ref</strong>关键字：</p>
<ul>
<li>一次是在方法的返回类型声明之前</li>
<li>另一次是在 return 关键字之后，被返回对象的变量名之前</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> Val;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">RefToVal</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ref</span> Val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>限制</p>
<ul>
<li><p>返回值为 void 的方法无法声明为<strong>ref</strong>返回方法</p>
</li>
<li><p><strong>ref return</strong>表达式无法返回以下内容：</p>
<ul>
<li>空值</li>
<li>常量</li>
<li>枚举成员</li>
<li>类或结构体的属性</li>
<li>指向只读位置的指针</li>
</ul>
</li>
<li><p><strong>ref return</strong>表达式只能指向原先就在调用域内的位置，或者字段。所以无法指向方法的局部变量。</p>
</li>
<li><p><strong>ref</strong>局部变量只能被赋值一次。一旦被初始化，就无法指向不同的存储位置了。</p>
</li>
<li><p>即使将一个方法声明为<strong>ref</strong>返回方法，如果在调用该方法时省略了<strong>ref</strong>关键字，则返回的<br>将是值，而不是指向值的内存位置的指针。</p>
</li>
<li><p>如果将<strong>ref</strong>局部变量作为常规的实际参数传递给其他方法，则该方法仅获取该变量的一个<br>副本。尽管<strong>ref</strong>局部变量包含指向存储位置的指针，但是当以这种方式使用时，它会传递<br>值而不是引用。</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-命名参数"><a href="#6-命名参数" class="headerlink" title="6. 命名参数"></a>6. 命名参数</h3><ol>
<li><p>在调用方法时，形参的名字后面跟着冒号和实际的参数表达式或参数值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> c</span>)</span>&#123;<span class="keyword">return</span> a+b+c&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> ro mc.Calc(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span> )<span class="comment">//位置参数</span></span><br><span class="line">		<span class="built_in">int</span> r1 mc.Calc(<span class="number">4</span>,b:<span class="number">3</span>,c:<span class="number">2</span> )<span class="comment">//位置参数和命名参数</span></span><br><span class="line">		<span class="built_in">int</span> r2 mc.Calc(<span class="number">4</span>,c:<span class="number">2</span>,b:<span class="number">3</span> )<span class="comment">//交换了顺序</span></span><br><span class="line">		<span class="built_in">int</span> r3 mc.Calc(c:<span class="number">2</span>,b:<span class="number">3</span>,a:<span class="number">4</span>);<span class="comment">//所有都是命名参数</span></span><br><span class="line">		<span class="built_in">int</span> r4=mc.Calc(c:<span class="number">2</span>,b:<span class="number">1</span>+<span class="number">2</span>,a:<span class="number">3</span>+<span class="number">1</span>);<span class="comment">//命名参数表达式</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;r0&#125;,&#123;r1&#125;,&#123;r2&#125;,&#123;r3&#125;,&#123;r4&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>,<span class="number">14</span>,<span class="number">14</span>,<span class="number">14</span>,<span class="number">14</span></span><br></pre></td></tr></table></figure>

<ul>
<li>命名参数对于自描述的程序来说很有用，因为我们可以在方法调用的时候显示哪个值赋给哪个形参。</li>
</ul>
</li>
</ol>
<h3 id="7-可选参数"><a href="#7-可选参数" class="headerlink" title="7. 可选参数"></a>7. 可选参数</h3><ol>
<li><p>可选参数就是可以在调用方法的时候包含这个参数，也可以省略它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Clac</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b=<span class="number">3</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> r0=mc.Clac(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="built_in">int</span> r1=mc.Clac(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;r0&#125;,&#123;r1&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>,<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>在代码中：</p>
<ul>
<li>形参 b 的默认值为 3。</li>
<li>如果调用方法的时候只有一个参数，方法会使用 3 作为的二个参数的初始值。</li>
</ul>
</li>
<li><p>可选参数的声明限制</p>
<ul>
<li>不是所有的参数类型都可以作为可选参数。<ul>
<li>只要值类型的默认值在编译的时候可以确定，就可以使用值类型作为可选类型</li>
<li>只有在默认值是 null 的时候，引用类型才可以用作可选参数<br><img src="http://lgqimg.changzer.cn/image-20220915192549731.png"></li>
</ul>
</li>
<li>所有必填参数必须在可选参数声明之前声明。如果有<strong>params</strong>，必须在所有可选参数之后声明。<img src="http://lgqimg.changzer.cn/image-20220915193352286.png" alt="image-20220915193352286"></li>
</ul>
</li>
<li><p>可选参数省略：</p>
<ul>
<li>必须从可选参数列表的最后开始省略，一直到列表开头。</li>
<li>可以省略最后一个可选参数，或是最后 n 个可选参数，但是不饿能随意选择省略任意的可选参数，省略必须从最后开始。</li>
</ul>
</li>
</ol>
<h3 id="8-栈帧"><a href="#8-栈帧" class="headerlink" title="8. 栈帧"></a>8. 栈帧</h3><ol>
<li>在调用方法的时候，内存从栈的顶部开始分配，保存和方法关联的一些数据项。这块内存叫作方法的栈帧(stack frame)。<ul>
<li>栈帧保存内容：<ul>
<li>返回地址，也就是在方法退出的时候继续执行的位置。</li>
<li>分配内存的的参数，也就是方法的值参数，还可能是参数数组(如果有的话)。</li>
<li>和方法调用相关的其他管理数据项。</li>
</ul>
</li>
<li>在方法调用时，整个栈帧都会压入栈。</li>
<li>在方法退出时，整个栈帧都会从栈上弹出。弹出栈帧有的时候也叫作栈展开(unwind)。</li>
</ul>
</li>
</ol>
<h2 id="三、深入理解类"><a href="#三、深入理解类" class="headerlink" title="三、深入理解类"></a>三、深入理解类</h2><h3 id="1-静态字段"><a href="#1-静态字段" class="headerlink" title="1. 静态字段"></a>1. 静态字段</h3><ol>
<li><p>静态字段被类的所有实例共享，所有实例都访问同一内存位置因此，如果该内存位置的值被一个实例改变了，这种改变对所有的实例都可见。</p>
</li>
<li><p>使用<strong>static</strong>修饰符将字段声明为静态。</p>
</li>
<li><p>从类外访问静态不需要使用类实例前缀可以使用类型和点运算符来访问静态成员，或是在该成员所属类中包含一个 using static 声明。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console; <span class="comment">//在其他成员中包含WriteLine()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Mem1;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> Mem2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        D.Mem2=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态字段的生存期</p>
<ul>
<li>即使类没有实例，静态成员也存在并且可以访问。</li>
<li>如果静态字段有生存周期，那么会在使用该类的任何静态成员之前初始化该字段，但不一定在程序执行的开始就初始化。</li>
</ul>
</li>
</ol>
<h3 id="2-静态函数成员"><a href="#2-静态函数成员" class="headerlink" title="2. 静态函数成员"></a>2. 静态函数成员</h3><ol>
<li><p>静态成员如同静态字段，独立于任何类实例。即使没有类实例，任然可以调用静态方法。</p>
</li>
<li><p>静态函数成员不能访问实例成员，但能访问其他静态成员。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> A;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintValA</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        COnsole.WriteLine(<span class="string">&quot;Value of A:&#123;0&#125;&quot;</span>,A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        X.A=<span class="number">10</span>;</span><br><span class="line">        X.PrintValA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of A:<span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他静态成员类型<br><img src="http://lgqimg.changzer.cn/image-20220915204231609.png" alt="image-20220915204231609"></p>
</li>
</ol>
<h3 id="3-成员常量"><a href="#3-成员常量" class="headerlink" title="3. 成员常量"></a>3. 成员常量</h3><ol>
<li><p>与局部常量类似，用于初始化成员常量的值在编译时必须时可计算的，而且通常时一个预定义简单类型或由他们组成表达式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> IntVal1=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> InVal2=<span class="number">2</span>*IntVal1;  <span class="comment">//IntVal1已经初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> IntVal1;   <span class="comment">//错误：必须初始化</span></span><br><span class="line">    IntVal1=<span class="number">100</span>;         <span class="comment">//错误：不允许赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C#中没有全局常量。每个常量都必须声明在类型内。</li>
</ul>
</li>
<li><p>常量与静态量</p>
<ul>
<li>成员常量像静态量一样，不需要使用类的实例就可以访问。</li>
<li>与真正的静态两不同，常量没有自己的存储位置，而是在编译器时被编译器替换。</li>
</ul>
</li>
</ol>
<h3 id="4-属性"><a href="#4-属性" class="headerlink" title="4. 属性"></a>4. 属性</h3><ol>
<li><p>属性时代表类实例或类中的数据项的成员。使用属性就像写入或读取一个字段，语法相同。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">mc.Filed = <span class="number">5</span>;          <span class="comment">//给字段赋值</span></span><br><span class="line">mc. MyProperty = <span class="number">10</span>;   <span class="comment">//该属性赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属性与字段类似，属性有以下特征：</p>
<ul>
<li>是命名的类成员。</li>
<li>有类型。</li>
<li>可以被赋值和读取。</li>
</ul>
<p>和字段不相同，属性是一个成员函数</p>
<ul>
<li>它不一定为数据存储分配内存</li>
<li>它执行代码</li>
</ul>
</li>
<li><p>属性是一组(两个)匹配的、命名的、成为访问器的方法。</p>
<ul>
<li><p><strong>set</strong>访问器为属性赋值</p>
</li>
<li><p><strong>get</strong>访问器从属性获取值</p>
<p>int 类型名称为 MyValue 的属性展示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> MyValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetAccessorCode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetAccessorCode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>属性声明和访问器</p>
<ul>
<li><p>set 和 get 访问器有预定义的语法和语义。可以把 set 访问器想象成一个方法，带有单一的参数，它“设置”属性的值。get 访问器没有参数并从属性返回一个值。</p>
</li>
<li><p><strong>set</strong>访问器总是：</p>
<ul>
<li>拥有一个单独的、隐式的值参，名称为 Value，与属性的类型相同。</li>
<li>拥有一个返回类型 void。</li>
</ul>
</li>
<li><p><strong>get</strong>访问器总是：</p>
<ul>
<li>没有参数。</li>
<li>拥有一个与属性类型相同的返回类型。</li>
</ul>
</li>
<li><p>属性结构声明(访问器声明既没有显式的参数，也没有返回类型声明，已经隐含在属性中)<br><img src="http://lgqimg.changzer.cn/image-20220915213845985.png" alt="image-20220915213845985"></p>
<p>set 访问器中的隐式参数 value 是一个普通的值参。和其他值参一样，可以用它发送数据到方法体或访问器块。在块的内部，可以像普通变量那样使用 value,包括对它赋值。</p>
</li>
<li><p>访问器的其他要点：</p>
<ul>
<li><strong>get</strong>访问器的所有执行路径必须包含一条<strong>return</strong>语句，它返回一个属性类型的值。</li>
<li>访问器<strong>set</strong>和<strong>get</strong>可以以任何顺序声明，并且，除了这两个访问器外，属性上不允许有其他方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>属性示例</p>
<ul>
<li><p>属性本身没有任何存储。取而代之，访问器决定如何处理发送进来的数据。以及将什么数据发送出去。在这种情况下，属性使用一个名为 TheRealValue 的字段作为存储。</p>
</li>
<li><p><strong>set</strong>访问器接受它的输入参数 value，并把它的值赋给字段 TheRealValue。</p>
</li>
<li><p><strong>get</strong>访问器只是返回字段 TheRealValue 的值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> theRealValue;       <span class="comment">//字段：发配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyValue</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span>&#123;theRealValue=<span class="keyword">value</span>;&#125;    <span class="comment">//属性：未分配内存</span></span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> theRealValue;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用属性</p>
<ul>
<li><p>要写入一个属性，在赋值语句的左边使用属性的名称。</p>
</li>
<li><p>要读取一个属性，把属性的名称用在表达式中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> MyValue      <span class="comment">//属性声明</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span>&#123;……&#125;</span><br><span class="line">    <span class="keyword">get</span>&#123;……&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyValue=<span class="number">5</span>;       <span class="comment">//赋值：隐式调用set方法，MyValue为属性名称</span></span><br><span class="line">z=MyValue;       <span class="comment">//表达式：隐式调用get方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能显示地调用访问器<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y =Myvalue.<span class="keyword">get</span>();  <span class="comment">//错误！不能显式调用t访问器</span></span><br><span class="line">MyValue.<span class="keyword">set</span>(<span class="number">5</span>);   <span class="comment">//错误！不能显式调用set访问器</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>属性和字段关联</p>
<ul>
<li>一个常见的方式是在类中将字段声明为<strong>private</strong>以封装字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段常被称为后备字段或后备存储</li>
<li>属性访问器并不局限于对关联的后备字段传进传出数据。访问器 get 和 set 能执行任何计算，也可以不执行任何计算。唯一必需的行为是 get 访问器要返回一个属性类型的值。</li>
</ul>
</li>
<li><p>只读和只写属性</p>
<ol>
<li>要想不定义属性的某个访问器，可以忽略访问器的声明。<ul>
<li>只有 get 访问器的属性称为只读属性。只读属性能够安全地将一个数据项从类或类的实例中传出，而不必让调用者修改属性值。</li>
<li>只有 set 访问器的属性称为只写属性。只写属性很少见，因为它们几乎没有实际用途。如果想在赋值时触发一个副作用，应该使用方法而不是属性。</li>
<li>两个访问器中至少有一个必须定义，否则编译器会产生一条错误消息。</li>
</ul>
</li>
</ol>
</li>
<li><p>属性和共有字段</p>
<p>属性比共有字段更好</p>
<ul>
<li>属性是函数成员而不是数据成员，允许处理输入和输出，而共有字段不行。</li>
<li>属性可以只读或只写，而字段不行。</li>
<li>编译后的变量和编译后的属性语义不同。</li>
</ul>
</li>
<li><p>自动实现属性</p>
</li>
</ol>
<ul>
<li><p>因为属性经常被关联到后备字段，所以 C#提供了自动实现属性(automatically implemented property 或 auto-implemented property,常简称为“自动属性”，auto-property),允许只声明属性而不声明后备字段。编译器会为你创建隐藏的后备字段，并且自动挂接到 gt 和 st 访问器上。</p>
</li>
<li><p>自动实现属性有以下要点：</p>
<ul>
<li>不声明后备字段——编译器根据属性的类型分配存储。</li>
<li>不能提供访问器的方法体一它们必须被简单地声明为分号。get 担当简单的内存读，set 担当简单的写。但是，因为无法访问自动属性的方法体，所以在使用自动属性时调试代码通常会更加困难。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyValue</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li><p>静态属性</p>
<ol>
<li>属性也可以声明为<strong>static</strong>。静态属性的访问器和所有静态成员一样，具有以下特点“<ul>
<li>不能访问类的实例成员，但能被实例成员访问。</li>
<li>不管类是否有实例，他们都是存在的。</li>
<li>在类的内部，可以仅使用名称来引用静态属性。</li>
<li>在类的外部，可以通过类型或者使用<strong>using static</strong>结构来引用静态属性。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="5-静态构造函数"><a href="#5-静态构造函数" class="headerlink" title="5.静态构造函数"></a>5.静态构造函数</h3><ol>
<li>构造函数也可以声明为 static。实例构造函数初始化类的每个新实例，而 static 构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。<ul>
<li>初始化类级别的项。<ul>
<li>在引用任何静态成员之前。</li>
<li>在创建类的任何实例之前。</li>
</ul>
</li>
<li>静态构造函数在以下方面与实例构造函数类似。<ul>
<li>静态构造函数的名称必须和类名相同。</li>
<li>构造函数不能返回值。</li>
</ul>
</li>
<li>静态构造函数在以下方面和实例构造函数不同。<ul>
<li>静态构造函数声明中使用<strong>static</strong>关键字。</li>
<li>类只能由一个静态构造函数，而且不能带参数。</li>
<li>静态构造函数不能有修饰符。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6-对象初始化和析构函数"><a href="#6-对象初始化和析构函数" class="headerlink" title="6. 对象初始化和析构函数"></a>6. 对象初始化和析构函数</h3><ol>
<li><p>对象初始化</p>
<ul>
<li>对象化初始化语法有两种。一种形式包括构造函数的参数列表，另一种不包括。</li>
<li>对象初始化内容：<ul>
<li>创建对象的代码能够访问要初始化的字段和属性。</li>
<li>初始化发生在构造方法执行之后，因此在构造方法中设置的值可能会在之后对象初始化中重置为相同或不同的值。</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Point pt1=<span class="keyword">new</span> Point();</span><br><span class="line">            Point pt2=<span class="keyword">new</span> Point &#123;X=<span class="number">5</span>,y=<span class="number">6</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数</p>
<p>析构函数(destructor)执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源是指通过 Win32API 获得的文件句柄，或非托管内存块。使用 NET 资源是无法得到它们的，因此如果坚持使用正 T 类，就不需要为类编写析构函数。</p>
</li>
</ol>
<h3 id="7-readonly修饰符"><a href="#7-readonly修饰符" class="headerlink" title="7. readonly修饰符"></a>7. <strong>readonly</strong>修饰符</h3><ol>
<li>字段使用<strong>readonly</strong>修饰符声明，其作用类似于将字段声明为 const，一旦被设定就不能在改变。<ul>
<li>const 字段只能在字段的声明语句中初始化，而 readonly 字段可以在下列任意位置设置它的值。<ul>
<li>字段声明语句，类似于 const。</li>
<li>类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成。</li>
</ul>
</li>
<li>const 字段的值必须可在编译时决定，而 readonly 字段的值可以在运行时决定。这种自由性允许你在不同的环境或不同的构造函数中设置不同的值。</li>
<li>const 的行为总是静态的，而对于 readonly 字段以下两点是正确的。<ul>
<li>它可以是实例字段，也可以是静态字段。</li>
<li>它在内存中有存储位置。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="8-索引器"><a href="#8-索引器" class="headerlink" title="8. 索引器"></a>8. 索引器</h3><ol>
<li><p>假设我们要定义一个类 Employee,它带有 3 个 string 型字段，那么可以使用字段的名称方间们加 Main 中的代码所示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> FirstName;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> CityofBirth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Employee empl <span class="keyword">new</span> <span class="title">Employee</span>()</span>;</span><br><span class="line"></span><br><span class="line">		empl.LastName=<span class="string">&quot;Doe&quot;</span>;</span><br><span class="line">		empl.FirstName:<span class="string">&quot;Jane&quot;</span>;</span><br><span class="line">		empi:cityofBirth <span class="string">&quot;Dallas&quot;</span>;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;(0)&quot;</span>.empl:LastName);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;(0)&quot;</span>,empl.FirstName);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;(0]&quot;</span>.empl.CityofBirth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而有的时候，如果能使用索引访问它们将会很方便，好像该实例是字段的数组一样。这正是索引器能做的事。如果为类 Employee 写一个索引器。请注意没有使用点运算符，相反，索引器使用索引运算符，它由一对方括号和中间的索引组成。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> FirstName;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> CityofBirth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Employee empl <span class="keyword">new</span> <span class="title">Employee</span>()</span>;</span><br><span class="line"></span><br><span class="line">		empl.LastName=<span class="string">&quot;Doe&quot;</span>;</span><br><span class="line">		empl.FirstName=<span class="string">&quot;Jane&quot;</span>;</span><br><span class="line">		empi:cityofBirth=<span class="string">&quot;Dallas&quot;</span>;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;(0)&quot;</span>.empl[<span class="number">0</span>]);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;(0)&quot;</span>,empl[<span class="number">1</span>]);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;(0]&quot;</span>.empl[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引器是一组 get 和 set 访问器，与属性类似。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">this</span> [<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetAccessorCode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetAccessorCode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引器和属性</p>
<ul>
<li>和属性一样，索引器不用分配内存来存储</li>
<li>索引器和属性都主要被用来访问其他数据成员，它们与这些成员关联，并为他们提供获取和设置访问。<ul>
<li>属性同常表示单个数据成员。</li>
<li>索引器通常表示多个数据成员。</li>
</ul>
</li>
</ul>
<p>索引器属意事项</p>
<ul>
<li>和属性一样，索引器可以只有一个访问器，也可以两个都有。</li>
<li>索引器总是实例成员，因此不能被声明为 static。</li>
<li>和属性一样，实现 get 和 set 访问器的代码不一定要关联到某个字段或属性。这段代码可以做任何事情也可以什么也不用做，只要 get 访问器返回某个指定类型的值即可。</li>
</ul>
</li>
<li><p>索引器声明</p>
<ul>
<li><p>声明索引器注意点：</p>
<ul>
<li>索引器没有名称。在名称的位置是关键字 this</li>
<li>参数列表在方括号中间</li>
<li>参数列表中至少声明一个参数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReturnType <span class="keyword">this</span> [Type param1,……]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>索引器的 set 和 get 访问器</p>
<ul>
<li><p>set 索引器：当索引器被用于赋值时，set 访问器被调用，并接受两项数据。set 访问器中的代码必须检查索引参数，以确定数据应该存往何处，然后保存它。</p>
<ul>
<li>一个名为 value 的隐式参数，其中持有要保存的数据。</li>
<li>一个或更多个索引参数，表示数据应该保存到哪里。</li>
</ul>
<p>set 访问器语义：</p>
<ul>
<li>它的返回类型为 void。</li>
<li>它使用的参数列表和索引器声明中的相同。</li>
<li>它有一个名为 value 的隐式参数，值参类型和索引器类型相同。</li>
</ul>
</li>
<li><p>get 索引器：当使用索引器获取值时，可以通过一个或多个索引参数调用 get 访问器。get 访问器中的代码必须检查索引参数，以确定数据应该存往何处，然后保存它。</p>
<p>get 访问器语义</p>
<ul>
<li>它的参数列表和索引器声明中的相同。</li>
<li>它返回与索引类型相同的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>索引器示例</p>
<ul>
<li><p>&#96;&#96;&#96;c#<br>class Employee<br>{<br>public string LastName;                &#x2F;&#x2F;调用字段0<br>public string FirstName;			   &#x2F;&#x2F;调用字段1<br>public string CityOfBirth;			   &#x2F;&#x2F;调用字段2<br><br>public string this[int index]		   &#x2F;&#x2F;索引器声明<br>{<br>    set								   &#x2F;&#x2F;set访问器声明<br>    {<br>        switch(index)<br>        {<br>            case 0:LastName&#x3D;value;<br>                break;<br>            case 1:FirstName&#x3D;value;<br>                break;<br>            case 2:CityOfBirth&#x3D;value;<br>                break;<br>            defaul:<br>                throw new ArgumentoutofRangeException(“index”);<br>        }<br>    }<br>    get								   &#x2F;&#x2F;get访问器声明<br>    {<br>        switch(index)<br>        {<br>            case 0:return LastName;<br>            case 1:return FirstName;<br>            case 2:return CityOfBirth;<br><br>            default:<br>                throw new ArgumentoutofRangeException(“index”);<br>        }<br>    }<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```c#</span><br><span class="line">  class Class1</span><br><span class="line">  &#123;</span><br><span class="line">      int Temp0;					//私有字段</span><br><span class="line">      int Temp1;					//私有字段</span><br><span class="line">      public int this[int index]</span><br><span class="line">      &#123;</span><br><span class="line">          get</span><br><span class="line">          &#123;</span><br><span class="line">              return(0==index)?Temp0:Temp1;</span><br><span class="line">  		&#125;</span><br><span class="line">          set</span><br><span class="line">          &#123;</span><br><span class="line">              if(0==index)</span><br><span class="line">                  Temp0=value;</span><br><span class="line">              else</span><br><span class="line">                  Temp1=value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Example</span><br><span class="line">  &#123;</span><br><span class="line">      static void Main()</span><br><span class="line">      &#123;</span><br><span class="line">          Class1 a=new Class1();</span><br><span class="line"></span><br><span class="line">          Console.WriteLine(&quot;Value -- T0:&#123;0&#125;,T1:&#123;1&#125;,a[0],a[1]&quot;);</span><br><span class="line">          a[0]=15;</span><br><span class="line">          a[1]=20;</span><br><span class="line">           Console.WriteLine(&quot;Value -- T0:&#123;,a[0]&#125;,T1:&#123;,a[1]&#125;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Values -T0:<span class="number">0</span>,T1:<span class="number">0</span></span><br><span class="line">Va1ues--T0:<span class="number">15</span>,T1:<span class="number">20</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>索引器重载</p>
<ol>
<li><p>只要索引器的参数列表不同，类就可以有任意多个索引器。索引器类型不同是不够的。这叫作索引器重载，因为所有的索引器都有相同的“名称”：this 访问引用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span> [<span class="built_in">int</span> index]</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span> [<span class="built_in">int</span> index1,<span class="built_in">int</span> index2]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span> [<span class="built_in">float</span> index1]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="9-访问器的访问修饰符"><a href="#9-访问器的访问修饰符" class="headerlink" title="9. 访问器的访问修饰符"></a>9. 访问器的访问修饰符</h3><ol>
<li><p>默认情况，索引器和属性的两个访问器级别跟索引器和属性自身的访问级别相同。也可以为两个访问器分配不同的访问级别。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;Name=name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    [</span><br><span class="line"><span class="title">static</span> <span class="title">public</span> <span class="title">void</span> <span class="title">Main</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> Person(<span class="string">&quot;Capt.Ernest Evans&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Person&#x27;s name is &#123;P.Name&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person<span class="string">&#x27;s name is Capt.Ernest Evans</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，可以从类的外部读取属性，但是只能在类的内部设置它。</p>
</li>
<li><p>访问器的修饰符限制条件：</p>
<ul>
<li>仅当成员(属性和索引器)既有 get 访问器也有 set 访问器，其访问器才能访问修饰符。</li>
<li>虽然两个访问器都必须出现，但它们中只能有一个有访问修饰符。</li>
<li>访问器的访问修饰符的显示不惜比成员的访问级别更加严格。</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220917195545721.png" alt="image-20220917195545721"></p>
</li>
</ol>
<h3 id="10-分部类和分布类型"><a href="#10-分部类和分布类型" class="headerlink" title="10. 分部类和分布类型"></a>10. 分部类和分布类型</h3><ol>
<li><p>类的声明可以分割成几个分布类的声明</p>
<ul>
<li>每个分部类的声明都含有一些类成员的声明。</li>
<li>类的分部类声明可以在同一一个文件中也可以在不同文件中。</li>
<li>每个分部类声明必须被标注为 partial class,而不是单独的关键字 class。分部类声明看起来和普通类声明相同，只是增加了类型修饰符 partial。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> clas5 MyPartClass				<span class="comment">//类名称与下面的相同</span></span><br><span class="line">&#123;</span><br><span class="line">	memberi declaration;</span><br><span class="line">	member2 declaration;</span><br><span class="line">&#125;</span><br><span class="line">类型修饰符</span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MyPartClass</span>				<span class="comment">//类名称与上西的相同</span></span><br><span class="line">&#123;</span><br><span class="line">    member3 declaration;</span><br><span class="line">	member4 declaration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型修饰符 partial 不是关键字，所以在其他上下文中，可以在程序中把它用作标识符。但直接用在关键字 class、struct 或 interface 之前时，它表示分部类型。</p>
</li>
<li><p>分部类型还有局部结构和局部接口。</p>
</li>
</ol>
<h3 id="11-分部方法"><a href="#11-分部方法" class="headerlink" title="11. 分部方法"></a>11. 分部方法</h3><ol>
<li>分部方法是声明在分部类中不同部分的方法。分部方法的不同部分可以声明在分部类的不同<br>部分中，也可以声明在同一个部分中。分部方法的两个部分如下。<ul>
<li>定义分部方法声明。<ul>
<li>给出签名和返回类型。</li>
<li>声明的实现部分只是一个分号。</li>
</ul>
</li>
<li>实现分部方法声明。<ul>
<li>给出签名和返回类型。</li>
<li>以普通的语句块形式实现。</li>
</ul>
</li>
</ul>
</li>
<li>分部方法需要了解的内容<ul>
<li>定义声明和实现声明的签名和返回类型必须匹配。签名和返回类型有如下特征：<ul>
<li>返回类型必须是 void。</li>
<li>签名不能包括访问修饰符，这使分部方法是隐式私有的。</li>
<li>参数列表不能包含 out 参数。</li>
<li>在定义声明和实现声明中都必须包含上下文关键字 partial,并且直接放在关键字 void 之前。</li>
</ul>
</li>
<li>可以有定义部分而没有实现部分。在这种情况下，编译器把方法的声明以及方法内部任何对方法的调用都移除。不能只有分部方法的实现部分而没有定义部分</li>
</ul>
</li>
</ol>
<h2 id="四、类的继承"><a href="#四、类的继承" class="headerlink" title="四、类的继承"></a>四、类的继承</h2><h3 id="1-屏蔽基类的成员"><a href="#1-屏蔽基类的成员" class="headerlink" title="1. 屏蔽基类的成员"></a>1. 屏蔽基类的成员</h3><ol>
<li>虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏薇(mask)基类成员。这是继承的主要功能之一，非常实用。<ul>
<li>要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称。</li>
<li>通过在派生类中声明新的带有相同签名的函数成员，可以屏蔽继承的函数成员。请记住，签名由名称和参数列表组成，不包括返回类型。</li>
<li>要让编译器知道你在故意屏蔽继承的成员，可使用 new 修饰符。否则，程序可以成功编译，但编译器会警告你隐藏了一个继承的成员。</li>
<li>也可以屏蔽静态成员。</li>
</ul>
</li>
</ol>
<h3 id="2-虚方法和覆写方法"><a href="#2-虚方法和覆写方法" class="headerlink" title="2. 虚方法和覆写方法"></a>2. 虚方法和覆写方法</h3><ol>
<li>虚方法可以使基类的引用访问“升至”派生类内。可以使用基类引用调用派上类的方法，只需满足下面的条件。<ul>
<li>派生类的方法和基类的方法有相同的签名和返回类型。</li>
<li>基类的方法使用 virtual 标注。</li>
<li>派生类的方法使用 override 标注。</li>
</ul>
</li>
<li>其他关于 virtual 和 override 修饰符的重要信息如下。<ul>
<li>覆写和被覆写的方法必须有相同的可访问性。例如，这种情况是不可以的：被覆写的方<br>法是 private 的，而覆写方法是 public 的。</li>
<li>不能覆写 static 方法或非虚方法。</li>
<li>方法、属性和索引器，以及另一种成员类型一事件，都可以被声明为 virtual 和 override.</li>
</ul>
</li>
</ol>
<h3 id="3-构造函数的执行"><a href="#3-构造函数的执行" class="headerlink" title="3. 构造函数的执行"></a>3. 构造函数的执行</h3><ol>
<li><p>要创建对象的基类部分，需要隐式调用基类的某个构造函数。继承层次链中的每个类在执行它自己的构造函数体之前执行它的基类构造函数。<br><img src="http://lgqimg.changzer.cn/image-20220917205056606.png" alt="image-20220917205056606"></p>
</li>
<li><p>默认情况下，在构造对象时，将调用基类的无参数构造函数。但构造函数可以重载，所以基类可能有一个以上的构造函数。如果希望派生类使用一个指定的基类构造函数而不是无参数构造函数，必须在构造函数初始化语句中指定它。<br>有两种形式的构造函数初始化语句。</p>
<ul>
<li>第一种形式使用关键字 base 并指明使用哪一个基类构造函数。</li>
<li>第二种形式使用关键字 this 并指明应该使用当前类的哪一个构造函数。</li>
</ul>
<p>基类构造函数初始化语句放在冒号后面，跟在类的构造函数声明的参数列表后面。构造函数始化语句由关键字 base 和要调用的基类构造函数的参数列表组成。</p>
</li>
</ol>
<h3 id="4-类访问修饰符"><a href="#4-类访问修饰符" class="headerlink" title="4. 类访问修饰符"></a>4. 类访问修饰符</h3><p>可访问（accessible)有时也称为可见（visible),它们可以互换使用。类的可访问性有两个级别：public 和 internal。</p>
<ul>
<li><p>标记为 pub1ic 的类可以被系统内任何程序集中的代码访问。要使一个类对其他程序集可见，使用 pub1ic 访问修饰符，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标记为 internal 的类只能被它自已所在的程序集内的类看到。</p>
<ul>
<li>这是默认的可访问级别，所以，.除非在类的声明中显式地指定修饰符 pub1ic,否则程<br>序集外部的代码不能访问该类。</li>
<li>可以使用 internal 访问修饰符显式地声明一个类为内部的。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-修饰符的可访问性"><a href="#5-修饰符的可访问性" class="headerlink" title="5. 修饰符的可访问性"></a>5. 修饰符的可访问性</h3><ol>
<li>public 访问级别是限制最少的。所有的类，包括程序集内部的类和外部的类都可以自由地访问成员。</li>
<li>private 访问级别是限制最严格的。private 类成员只能被它自己的类的成员访问。它不能被其他的类访问，包括继承它的类。然而，private 成员能被嵌套在它的类中的类成员访问。</li>
<li>protected 访问级别如同 private 访问级别，但它允许派生自该类的类访问该成员。注意，即使程序集外部继承该类的类也能访问该成员。</li>
<li>标记为 internal 的成员对程序集内部的所有类可见，但对程序集外部的类不可见。</li>
<li>标记为 protected internal 的成员对所有继承该类的类以及程序集内部的所有类可见。注意，允许访问的集合是 protected 修饰符允许访问的类的集合加上 internal 修饰符允许访问的类的集合。注意，这是 protected 和 internal 的并集，不是交集。</li>
</ol>
<p><img src="http://lgqimg.changzer.cn/image-20220917210313358.png" alt="image-20220917210313358"></p>
<p><img src="http://lgqimg.changzer.cn/image-20220917210349590.png" alt="image-20220917210349590"></p>
<h3 id="6-抽象成员"><a href="#6-抽象成员" class="headerlink" title="6. 抽象成员"></a>6. 抽象成员</h3><ol>
<li><p>抽象成员是指设计为被覆写的函数成员。抽象成员有以下特征。</p>
<ul>
<li>必须是一个函数成员。也就是说，字段和常量不能为抽象成员。</li>
<li>必须用 abstract 修饰符标记。</li>
<li>不能有实现代码块。抽象成员的代码用分号表示。</li>
</ul>
</li>
<li><p>抽象成员只可以在抽象类中声明，下一节中会讨论。一共有 4 种类型的成员可以声明为抽象的：</p>
<ul>
<li>方法；</li>
<li>属性；</li>
<li>事件；</li>
<li>索引器。</li>
</ul>
<p>关于抽象成员的其他重要事项如下。</p>
<ul>
<li>尽管抽象成员必须在派生类中用相应的成员覆写，但不能把 virtual 修饰符附加到 abstract 修饰符。</li>
<li>类似于虚成员，派生类中抽象成员的实现必须指定 override 修饰符。</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220917210712470.png" alt="image-20220917210712470"></p>
</li>
</ol>
<h3 id="7-静态类"><a href="#7-静态类" class="headerlink" title="7. 静态类"></a>7. 静态类</h3><ol>
<li>静态类中所有成员都是静态的。静态类用于存放不受实例数据影响的数据和函数。静态类的一个常见用途可能是创建一个包含一组数学方法和值的数学库。<ul>
<li>类本身必须标记为 static。</li>
<li>类的所有成员必须是静态的。</li>
<li>类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例。</li>
<li>静态类是隐式密封的，也就是说，不能继承静态类。</li>
</ul>
</li>
</ol>
<h2 id="五、运算符"><a href="#五、运算符" class="headerlink" title="五、运算符"></a>五、运算符</h2><h3 id="1-运算符重载"><a href="#1-运算符重载" class="headerlink" title="1. 运算符重载"></a>1. 运算符重载</h3><ol>
<li><p>运算符重载允许你定义 C#运算符应该如何操作自定义类型的操作数。</p>
<ul>
<li>运算符重载只能用于类和结构</li>
<li>为类或结构重载一个运算符 x,可以声明一个名称为 operator× 的方法并实现它的行为<ul>
<li>一元运算符的重载方法带一个单独的 class 或 struct 类型的参数。</li>
<li>二元运算符的重载方法带两个参数，其中至少有一个必须是 class 或 struct 类型。</li>
</ul>
</li>
<li>声明必须同时使用 static 和 public 的修饰符；</li>
<li>运算符必须是要操作的类或结构的成员。</li>
</ul>
</li>
<li><p>运算符重载限制</p>
<p><img src="http://lgqimg.changzer.cn/image-20220917212812990.png" alt="image-20220917212812990"></p>
<ul>
<li>运算符重载不能：<ul>
<li>创建新运算符；</li>
<li>改变运算符的语法；</li>
<li>重新定义运算符如何处理预定义类型；</li>
<li>改变运算符的优先级或结合性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-typeof运算符和-nameof-运算符"><a href="#2-typeof运算符和-nameof-运算符" class="headerlink" title="2. typeof运算符和 nameof 运算符"></a>2. <strong>typeof</strong>运算符和 nameof 运算符</h3><ol>
<li><p>typeof 运算符返回作为其参数的任何类型的 System.Type 对象。通过这个对象，可以了解类型的特征。</p>
<p>typeof 运算符是一元运算符。</p>
</li>
<li><p>nameof 运算符返回一个表示传人参数的字符串。</p>
</li>
</ol>
<h2 id="六、委托"><a href="#六、委托" class="headerlink" title="六、委托"></a>六、委托</h2><h3 id="1-委托概述"><a href="#1-委托概述" class="headerlink" title="1.委托概述"></a>1.委托概述</h3><p>委托和类一样，是一种用户用户自定义类型。但类表示的是数据和方法的集合，而委托则持有一个或多个方法，以及一系列预定义操作。</p>
<ul>
<li>声明一个委托类型。委托声明看上去和方法声明类似，只是没有实现块。</li>
<li>使用该委托类型声明一个委托变量。</li>
<li>创建一个委托类型的对象，并把它赋值给委托变量。新的委托对象包含指向某个方法的引用，这个方法的签名和返回类型必须跟第一步中定义的委托类型一致。</li>
<li>可以选择为委托对象添加其他方法。这些方法的签名和返回类型必须与第一部中定义的委托类型相同。</li>
<li>可以像调用方法一样调用委托。在调用委托的时候，其包含的每一个方法都会被执行。</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220921194159165.png" alt="image-20220921194159165"></p>
<ul>
<li><p>方法的列表称为调用列表</p>
</li>
<li><p>委托持有的方法可以来自任何类或结构，只要它们在下面两方面匹配：</p>
<ul>
<li>委托的返回类型；</li>
<li>委托的签名(包括 ref 和 out 修饰符)</li>
</ul>
</li>
<li><p>在调用列表中的方法可以是实例方法也可以是静态方法。</p>
</li>
<li><p>在调用委托的时候，会执行其调用列表中的所有方法。</p>
<p><img src="http://lgqimg.changzer.cn/image-20220921195045455.png" alt="image-20220921195045455"></p>
</li>
</ul>
<h3 id="2-声明委托类型"><a href="#2-声明委托类型" class="headerlink" title="2. 声明委托类型"></a>2. 声明委托类型</h3><ol>
<li><p>委托类型必须在创建变量以及类型的对象之前声明。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>委托类型声明在两个方面与方法不同。委托类型声明：</p>
<ul>
<li>以 delegate 关键字开头；</li>
<li>没有方法主体</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220921195755345.png" alt="image-20220921195755345"></p>
</li>
<li><p>委托是引用类型，因此有引用和对象。委托类型的变量声明：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel delVar;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建委托对象的方式有两种。</p>
<ul>
<li><p>第一种是使用 new 运算符的对象创建表达式。new 运算符的操作数组成如下。</p>
<ul>
<li>委托类型名。</li>
<li>一组圆括号，其中包含作为调用列表中第一个成员方法的名称。该方法可以是实例方法或静态方法。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delVar=<span class="keyword">new</span> MyDel(myInsObj.MyM1);</span><br><span class="line">dVar=<span class="keyword">new</span> MyDel(SClass.OtherM2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以使用快捷语法，它仅由方法说明符构成。这种快捷语法能够工作是因为方法名称和其相应的委托类型之间存在隐式转换。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delVar =MyInsObj.MyM1;</span><br><span class="line">dVar =SClass.OtherM2;</span><br></pre></td></tr></table></figure>

<p>除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表。</p>
</li>
</ul>
</li>
<li><p>由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的引用。旧的委托对象会被垃圾回收器回收。</p>
</li>
<li><p>委托可以使用额外的运算符来“组合”。这个运算会创建一个新的委托，并调用列表连接了作为操作数的两个委托的调用列表副本。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyDel delA=myInstObj.MyM1;</span><br><span class="line">MyDel delB=SClass.OtherM2;</span><br><span class="line"></span><br><span class="line">MyDel delC=delA + delB;</span><br></pre></td></tr></table></figure>

<p><strong>委托是恒定的。委托对象被创建后不能在被改变。</strong></p>
</li>
</ol>
<h3 id="3-委托的添加方法和移除方法"><a href="#3-委托的添加方法和移除方法" class="headerlink" title="3. 委托的添加方法和移除方法"></a>3. 委托的添加方法和移除方法</h3><ol>
<li><ol>
<li>C#可以为委托添加和移除方法，即使用**+&#x3D;<strong>和</strong>-&#x3D;**运算符。</li>
</ol>
<ul>
<li><p>添加方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel delVar =<span class="keyword">new</span> inst.MyM1;</span><br><span class="line">decVar +=SCL.m3;</span><br><span class="line">delVar +=X.Act;</span><br></pre></td></tr></table></figure>

<p><img src="http://lgqimg.changzer.cn/image-20220921204834993.png" alt="image-20220921204834993"></p>
<p>在使用+&#x3D;运算符时，实际发生的是创建了一个新的委托，其调用列表是左边的委托加上右边的方法的组合。然后将这个新的委托赋值给 delVar。每次添加都会在调用列表创建一个新的元素。</p>
</li>
<li><p>移除方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decVar -=SCL.m3;</span><br></pre></td></tr></table></figure>

<p><img src="http://lgqimg.changzer.cn/image-20220921205038288.png" alt="image-20220921205038288"></p>
<p>与为委托添加方法一样，其实是创建了一个新的委托。新的委托是旧的委托的副本—只是没有被有了已经被移除的方法。</p>
<p>移除委托需要记住的一些事项，</p>
<ul>
<li>如果在调用列表中的方法有多个实例，**-&#x3D;**运算符将从列表的最后开始索引，并且移除第一个与方法匹配的实例。</li>
<li>试图删除委托中不存在的方法将无效。</li>
<li>试图调用空委托会抛出异常。可以通过将委托和 null 进行比较来判断委托的调用列表是否为空。如果调用列表为空，则委托是 null。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-委托的调用"><a href="#4-委托的调用" class="headerlink" title="4. 委托的调用"></a>4. 委托的调用</h3><ol>
<li><p>委托调用的重要事项。</p>
<ul>
<li>可以通过两种方式调用委托。一种是调用方法一样调用委托，另一种是使用委托的 Invoke 方法。</li>
<li>可以将参数放在调用的圆括号内。用于调用委托的参数作用于调用列表中的每个方法(除非其中一个参数是输出参数)。</li>
<li>调用时委托不能为空(null),否则将引发异常。可以使用 if 语句进行检查，也可以使用空条件运算符和 Invoke 方法。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyDel delVar inst.MyM1;</span><br><span class="line">delvar+=SC1.m3;</span><br><span class="line">delvar+=X.Act;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delVar !=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    de1var(<span class="number">55</span>);			<span class="comment">//调用委托</span></span><br><span class="line">&#125;</span><br><span class="line">delVar?.Invoke(<span class="number">65</span>);		<span class="comment">//使用Invoke和空条件运算符</span></span><br></pre></td></tr></table></figure>

<p><img src="http://lgqimg.changzer.cn/image-20220921211205874.png" alt="image-20220921211205874"></p>
</li>
<li><p>调用带返回值的委托<br>如果委托有返回值并且在调用列表中有一个以上的方法，会放生下面的 qingkuang</p>
<ul>
<li>调用列表中最后一个方法返回的值就是委托调用返回的值。</li>
<li>调用列表中所有其他方法的返回值都会被忽略。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span>()</span>;							<span class="comment">//声明有返回位的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> IntValue <span class="number">5</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add2</span>()</span>&#123;IntValue +<span class="number">2</span>;<span class="keyword">return</span> IntValue;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add3</span>()</span>&#123;IntValue +<span class="number">3</span>;<span class="keyword">return</span> IntValue;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="function">MyClass mc <span class="keyword">new</span> <span class="title">Myclass</span>()</span>;</span><br><span class="line">		MyDel mDel mc.Add2;							<span class="comment">//创建并初始化委托</span></span><br><span class="line">		mDel +mc.Add3;								<span class="comment">//增加方法</span></span><br><span class="line">		mDel +mc.Add2;								<span class="comment">//增加方法</span></span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;Value:mDel()&#125;&quot;</span>);		<span class="comment">//调用委托并使用返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="http://lgqimg.changzer.cn/image-20220927194547963.png" alt="image-20220927194547963"></p>
</li>
<li><p>调用带引用参数的委托<br>如果委托带有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span>;						<span class="comment">//声明有返回位的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> IntValue <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add2</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span>&#123;x += <span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add3</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span>&#123;x += <span class="number">3</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MyClass mc <span class="keyword">new</span> <span class="title">Myclass</span>()</span>;</span><br><span class="line">		MyDel mDel mc.Add2;</span><br><span class="line">		mDel +mc.Add3;</span><br><span class="line">		mDel +mc.Add2;</span><br><span class="line"></span><br><span class="line">    	<span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line">    	mDel(<span class="keyword">ref</span> x);</span><br><span class="line"></span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;Value:<span class="subst">&#123;x&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="F:\笔记\image-20220927195618833.png" alt="image-20220927195618833"></p>
</li>
</ol>
<h3 id="5-匿名方法"><a href="#5-匿名方法" class="headerlink" title="5. 匿名方法"></a>5. 匿名方法</h3><ol>
<li><p>匿名方法让我们无须使用独立的具名方法。匿名方法(anonymous method)是在实例化委托时内联(inline)声明的方法。例如，图 14-l2<br>演示了同一个类的两个版本。左边的版本声明并使用了一个名为 Add20 的方法。右边的版本使用匿名方法。没有底色的代码部分对于两个版本是一样的。<br><img src="http://lgqimg.changzer.cn/image-20220927200005598.png" alt="image-20220927200005598"><br>输出结果为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用匿名方法</p>
<ul>
<li>声明委托变量作为初始化表达方法。</li>
<li>组合委托时在赋值语句的右边。</li>
<li>为委托增加事件时在赋值语句的右边。</li>
</ul>
<p>匿名方法表达式的语法</p>
<ul>
<li>delegate 类型关键字</li>
<li>参数列表，如果语句块没有使用任何参数列表则可以省略</li>
<li>语句块，它包含了匿名方法的代码</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220927200408061.png" alt="image-20220927200408061"></p>
<ol>
<li><p>返回类型<br>匿名方法不会显式声明返回值。然而，实现代码本身的行为必须通过返回一个与委托的返回类型相同的值来匹配委托的返回类型。如果委托有 Void 类型的返回值，匿名方法就不能返回值。</p>
</li>
<li><p>参数<br>除了数组参数，匿名方法的参数列表必须在如下 3 方面与委托匹配：·</p>
<ul>
<li>参数数量；</li>
<li>参数类型及位置；</li>
<li>修饰符。</li>
</ul>
<p>可以通过使圆括号为空或省略圆括号来简化匿名方法的参数列表，但必须满足以下两个条件：</p>
<ul>
<li>委托的参数列表不包含任何 out 参数；</li>
<li>匿名方法不使用任何参数。</li>
</ul>
</li>
<li><p>params 参数</p>
<p>如果委托声明的参数列表包含了 params 参数，那么匿名方法的参数列表将忽略 params 关键字。</p>
<ul>
<li>委托类型声明指定最后一个参数为 params 类型的参数；</li>
<li>然而，匿名方法参数列表必须省略 params 关键字。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>变量和参数的作用域<br>参数以及声明在匿名方法内部的局部变量的作用域限制在实现代码的主题之内。<br><img src="http://lgqimg.changzer.cn/image-20220927202320950.png" alt="image-20220927202320950"></p>
<ul>
<li><p>外部变量<br>与委托的具名方法不同，匿名方法可以访问它们外围作用域的局部变量和环境。</p>
<ul>
<li>外围作用域的变量叫做外部变量(outer variable)。</li>
<li>用在匿名方法实现代码中的外部变量称为方法捕获。</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220927211036778.png" alt="image-20220927211036778"></p>
</li>
<li><p>捕获变量的生命周期的拓展<br>只要捕获方法是委托的一部分，即使变量已经离开了作用域，捕获的外部变量也会一直有效。</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-Lambda-表达式"><a href="#6-Lambda-表达式" class="headerlink" title="6. Lambda 表达式"></a>6. Lambda 表达式</h3><p>使用 Lambda 表达式来代替匿名方法。<br>匿名方法转换为 Lambda 表达式：</p>
<ul>
<li>删除 delegate 关键字；</li>
<li>在参数列表和匿名方法主体之间放置 Lambda 运算符&#x3D;&gt;。Lamnda 运算符读作“goes to”。</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220927212306117.png" alt="image-20220927212306117"></p>
<p>编译器可以从 lambda 表达式中推断更多信息。</p>
<ul>
<li>编译器还可以从委托的声明中知道委托的参数的类型，因此 lambda 表达式允许省略类型参数。<ul>
<li>带有类型的参数列表被称为显式类型。</li>
<li>省略类型的参数列表被称为隐式类型。</li>
<li>如果只有一个隐式类型参数，我们可以省略两端的圆括号。</li>
<li>最后，Lambda 表达式允许表达式的主体是语句块或表达式。如果语句块包含了一个返回语句，我们可以将语句替换为 return 关键字后的表达式。</li>
</ul>
</li>
</ul>
<p>Lambda 表达式的参数列表要点：</p>
<ul>
<li>Lambda 表达式参数列表中的参数必须要在参数数量、类型和位置上与委托相同。</li>
<li>表达式的参数列表中的参数不一定需要包含类型(隐式类型)，除非委托有 ref 或 out 参数—此时必须注明类型(显式类型)。</li>
<li>如果只有一个参数，并且是隐式类型的，则两端的圆括号可以省略，否则必须有括号。</li>
<li>如果没有参数，必须使用一组空的圆括号。</li>
</ul>
<h2 id="七、事件"><a href="#七、事件" class="headerlink" title="七、事件"></a>七、事件</h2><h3 id="1-发布者和订阅者"><a href="#1-发布者和订阅者" class="headerlink" title="1. 发布者和订阅者"></a>1. 发布者和订阅者</h3><ol>
<li><p>发布者&#x2F;订阅者模式（publisher&#x2F;subscriber pattern)可以满足这种需求。在这种模式中，发布者类定义了一系列程序的其他部分可能感兴趣的事件。其他类可以“注册”，以便在这些事件发生时收到发布者的通知。这些订阅者类通过向发布者提供一个方法来“注册”以获取通知。当事件发生时，发布者“触发事件”，然后执行订阅者提交的所有事件。</p>
<p>由订阅者提供的方法称为回调方法，因为发布者通过执行这些方法来“往回调用订阅者的方法”。还可以将它们称为事件处理程序，因为它们是为处理事件而调用的代码。<br><img src="http://lgqimg.changzer.cn/image-20220928193604069.png" alt="image-20220928193604069"></p>
</li>
<li><p>关于事件的重要事项。</p>
<ul>
<li><strong>发布者</strong> 发布某个事件的类或结构，其他类可以在该事件发生时得到通知</li>
<li><strong>订阅者</strong> 注册并在事件发生时得到通知的类或结构</li>
<li><strong>事件处理程序</strong> 由订阅者注册事件的方法，在发布者 出发事件时执行。事件处理程序方法可以定义在事件所在的类或结构中，也可以定义在不同的类或结构中。</li>
<li><strong>触发事件</strong> 调用或触发事件的术语。当事件被触发时，所有注册到它的方法都会被一次调用。</li>
</ul>
</li>
<li><p>事件包含了一个私有的委托。<br>事件的私有委托注意事项：</p>
<ul>
<li>事件提供了对它的私有控制委托的结构化访问。也就是说，你无法直接访问委托。</li>
<li>事件中可用的操作比委托要少，对于事件我们只能添加、删除或调用事件处理程序。</li>
<li>事件被触发时，它调用委托来依次调用调用列表中的方法。</li>
</ul>
</li>
</ol>
<h3 id="2-源代码组件概览"><a href="#2-源代码组件概览" class="headerlink" title="2. 源代码组件概览"></a>2. 源代码组件概览</h3><ol>
<li><p>事件中使用的代码有 5 部分</p>
<ul>
<li><strong>委托类型声明</strong> 事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。</li>
<li><strong>事件处理程序声明</strong> 订阅者类中会在事件触发时执行的方法声明。它们不一定是显式命名的方法，还可以是匿名方法或 Lambda 表达式。</li>
<li><strong>事件声明</strong> 发布者类必须声明一个订阅者类可以注册的事件成员。当类声明的事件为 public 时，称为发布了事件。</li>
<li><strong>事件注册</strong> 订阅者必须注册事件才能在事件被触发时得到通知。这是将事件处理程序与事件相连的代码。</li>
<li><strong>触发事件的代码</strong> 发布者类中“触发”事件并导致调用注册的所有事件处理程序的代码。</li>
</ul>
<p><img src="http://lgqimg.changzer.cn/image-20220928195921778.png" alt="image-20220928195921778"></p>
</li>
</ol>
<h3 id="3-声明事件"><a href="#3-声明事件" class="headerlink" title="3. 声明事件"></a>3. 声明事件</h3><ol>
<li><p>声明事件的语法<br><img src="http://lgqimg.changzer.cn/image-20220928200248183.png" alt="image-20220928200248183"><br>关于事件声明的内容：</p>
<ul>
<li>事件声明在一个类中。</li>
<li>它需要委托类型的名称，任何附加到事件(如注册)的处理程序都必须与委托类型的签名和返回类型匹配。</li>
<li>它声明为 public，这样其他类和结构可以在它上面注册事件处理程序。</li>
<li>不能使用对象创建表达式(new 表达式)创建它的对象。</li>
</ul>
<p>使用使用逗号分隔创建多个事件：<br><img src="http://lgqimg.changzer.cn/image-20220928200724245.png" alt="image-20220928200724245"></p>
<p>也可以可以使用 static 关键字让事件变为静态：<br><img src="http://lgqimg.changzer.cn/image-20220928200800904.png" alt="image-20220928200800904"></p>
</li>
<li><p>事件是成员<br>事件的特性</p>
<ul>
<li>由于事件的成员：<ul>
<li>我们不能在一段可执行代码中声明事件；</li>
<li>它必须声明在类或者结构中，和其他成员一样。</li>
</ul>
</li>
<li>事件成员被隐式自动初始化为 null；</li>
</ul>
</li>
</ol>
<h3 id="4-订阅事件"><a href="#4-订阅事件" class="headerlink" title="4. 订阅事件"></a>4. 订阅事件</h3><ol>
<li>订阅者向事件添加事件处理程序。对于一个要添加到事件的事件处理程序来说，它必须具有与事件的委托相同的返回类型和签名。<ul>
<li>使用+&#x3D;运算符来为事件添加事件处理程序。事件处理程序位于该运算符的右边。</li>
<li>事件处理程序的规范可以是以下任意的一种：<ul>
<li>实例方法的名称；</li>
<li>静态方法的名称；</li>
<li>匿名方法；</li>
<li>Lambda 表达式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-触发事件"><a href="#5-触发事件" class="headerlink" title="5. 触发事件"></a>5. 触发事件</h3><ol>
<li><p>事件成员本身只是保存了需要被调用的事件处理程序。如果事件没有被触发，什么都不会发生。我们需要确保有代码在合适的时候做这件事情。</p>
<ul>
<li>在触发事件之前和 null 进行比较，从而查看事件是否包含事件处理程序。如果事件是 nu11,则表示没有事件处理程序，不能执行。</li>
<li>触发 l 事件的语法和调用方法一样：<ul>
<li>使用事件名称，后面跟着参数列表（包含在圆括号中)：</li>
<li>参数列表必须与事件的委托类型相匹配。</li>
</ul>
</li>
</ul>
</li>
<li><p>标准事件的用法</p>
<p>事件的使用，NET 框架提供了一个标准模式。该标准模式的基础就是 System 命名空间中声明的 EventHandler 委托类型。EventHandler 委托类型的声明如以下代码所示。关于该声明需要注意以下几点。</p>
<ul>
<li><p>第一个参数用来保存触发事件的对象的引用。由于它是 object 类型的，所以可以匹配任何类型的实例。</p>
</li>
<li><p>第二个参数用来保存状态信息，指明什么类型适用于该应用程序。</p>
</li>
<li><p>返回类型是 void。</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender,EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>EventHandler 委托类型的第二个参数是 EventArgs 类的对象，它声明在 System 命名空间中。</p>
<ul>
<li>EventArgs 不能传递任何数据，它用于不需要传递数据的事件处理程序-通常会被忽略。</li>
<li>如果你希望传递数据，必须声明一个派生自 EventArgs 的类，并使用合适的字段来保存需要传递的数据。</li>
</ul>
</li>
<li><p>拓展 EventArgs 来传递数据<br>声明一个派生自 EventArgs 的自定义类，它可以保存我们需要传入的数据。类的名称应以 EventArgs 结尾。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IncrementerEvenrArgs</span>:<span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IterationCount&#123;<span class="keyword">get</span>:<span class="keyword">set</span>;&#125;  <span class="comment">//存储一个整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用泛型委托：<code>EventHandler&lt;&gt;</code></p>
<ul>
<li>将自定义类的名称放在尖括号内。</li>
<li>在需要使用自定义委托类型的地方使用整个字符串。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;IncreamentEventArgs&gt; CountedADozen;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除事件处理程序</p>
<p>在用完事件处理程序之后，可以从事件中把它移除。可以利用-&#x3D;运算符把事件处理程序从事件中移除，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.SimpleEvent -= s.MethdB;    <span class="comment">//移除事件处理程序MethodB</span></span><br></pre></td></tr></table></figure>

<p>如果一个处理程序向事件注册了多次，那么当执行命令移除处理程序时，将只移除列表中该处理程序的最后一个实例。</p>
</li>
</ol>
<h3 id="6-事件访问器"><a href="#6-事件访问器" class="headerlink" title="6. 事件访问器"></a>6. 事件访问器</h3><ol>
<li><p>事件只允许+&#x3D;和-&#x3D;运算符。我们可以修改这两个运算符的行为，在使用时让事件执行任何我们希望的自定义代码。<br>要改变这两个运算符的操作，必须为事件定义事件访问器：</p>
<ul>
<li>有两个访问器：<strong>add</strong>和<strong>remove</strong>。</li>
<li>声明事件的访问器看上去和声明属性差不多。</li>
</ul>
<p>两个访问器都有叫作 value 的隐式值参数，它连受实例或静态方法的引用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...				<span class="comment">//执行+=运算符的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">remove</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...				<span class="comment">//执行-=运算符的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明了事件访问器之后，事件不包含任何内嵌委托对象。我们必须实现自己的机制来存储和移除事件注册的方法。<br>事件访问器表现为 void 方法，也就是不能使用返回值的 return 语句。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://maplelearc.github.io">Maple</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://maplelearc.github.io/2022/10/03/%E3%80%8ACS%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9/">https://maplelearc.github.io/2022/10/03/《CS图解教程》阅读记忆点/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://maplelearc.github.io" target="_blank">Maple Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AC-%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">《C#图解教程》阅读记忆点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 栈和堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B5%8C%E5%A5%97%E5%BF%AB%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 嵌套快中的局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">二、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E5%92%8C%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 方法的引用参数和值参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%80%BC%E5%8F%82%E6%95%B0%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 引用类型作为值参数和引用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 输出参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 参数数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8Cref%E8%BF%94%E5%9B%9E"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. ref局部变量和ref返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 命名参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.7.</span> <span class="toc-text">7. 可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%A0%88%E5%B8%A7"><span class="toc-number">1.2.8.</span> <span class="toc-text">8. 栈帧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">三、深入理解类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 静态字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 静态函数成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 成员常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.静态构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 对象初始化和析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-readonly%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. readonly修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">1.3.8.</span> <span class="toc-text">8. 索引器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%AE%BF%E9%97%AE%E5%99%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.9.</span> <span class="toc-text">9. 访问器的访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%86%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E5%B8%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.10.</span> <span class="toc-text">10. 分部类和分布类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.11.</span> <span class="toc-text">11. 分部方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.</span> <span class="toc-text">四、类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B1%8F%E8%94%BD%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 屏蔽基类的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E8%A6%86%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 虚方法和覆写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 构造函数的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 类访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. 修饰符的可访问性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98"><span class="toc-number">1.4.6.</span> <span class="toc-text">6. 抽象成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-number">1.4.7.</span> <span class="toc-text">7. 静态类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">五、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-typeof%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-nameof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. typeof运算符和 nameof 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A7%94%E6%89%98"><span class="toc-number">1.6.</span> <span class="toc-text">六、委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A7%94%E6%89%98%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.委托概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 声明委托类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A7%94%E6%89%98%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 委托的添加方法和移除方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A7%94%E6%89%98%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 委托的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. 匿名方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. Lambda 表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.7.</span> <span class="toc-text">七、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 发布者和订阅者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 源代码组件概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 声明事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 订阅事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 触发事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%8B%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 事件访问器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #DCDCDC"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Maple</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>