<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lua入门学习</title>
      <link href="/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/08/Lua%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="lua-入门学习"><a class="anchor" href="#lua-入门学习">#</a> Lua 入门学习</h1><hr /><h2 id="lua-基本语法"><a class="anchor" href="#lua-基本语法">#</a> 🍁Lua 基本语法</h2><h3 id="交互式编程"><a class="anchor" href="#交互式编程">#</a> 交互式编程</h3><p>Lua 提供了人交互式编程模式。可以在命令行中输出程序并立即查看效果<br /> Lua 交互式编程通过命令 lua -i 或 lua 来启用：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ lua <span class="token parameter variable">-i</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ lua Lua <span class="token number">5.3</span>.0  Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">1994</span>-2015 Lua.org, PUC-Rio</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">></span></pre></td></tr></table></figure><p>在命令行中，输入以下命令：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">></span> print<span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>按下回车，得到以下结果：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">></span> print<span class="token punctuation">(</span><span class="token string">"Hello World！"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Hello World！</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">></span></pre></td></tr></table></figure><h3 id="脚本编程"><a class="anchor" href="#脚本编程">#</a> 脚本编程</h3><p>我们可以将 Lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，如我们将如下代码存储在名为 hello.lua 的脚本文件中：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>print<span class="token punctuation">(</span><span class="token string">"Hello World！"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>使用 lua 名执行以上脚本，输出结果为：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ lua test.lua</pre></td></tr><tr><td data-num="2"></td><td><pre>Hello World！</pre></td></tr></table></figure><p>我们也可以将代码修改为如下形式来执行脚本（在开头添加：#!/usr/local/bin/lua）：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token shebang important">#!/usr/local/bin/lua</span></pre></td></tr><tr><td data-num="2"></td><td><pre>print<span class="token punctuation">(</span><span class="token string">"Hello World！"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>以上代码中，我们指定了 Lua 的解释器 /usr/local/bin directory。加上 # 号标记解释器会忽略它。接下来我们为脚本添加可执行权限，并执行：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>./test.lua</pre></td></tr><tr><td data-num="2"></td><td><pre>Hello World！</pre></td></tr></table></figure><h3 id="注释"><a class="anchor" href="#注释">#</a> 注释</h3><h4 id="单行注释"><a class="anchor" href="#单行注释">#</a> 单行注释</h4><p>两个减号是单行注释</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--</span></pre></td></tr></table></figure><h4 id="多行注释"><a class="anchor" href="#多行注释">#</a> 多行注释</h4><pre><code>--[[多行注释多行注释--]]</code></pre><h3 id="标示符"><a class="anchor" href="#标示符">#</a> 标示符</h3><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。最好不要使用下划线加大写字母的标示符，因为 Lua 的保留字也是这样的。</p><p>Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Test 与 test 是两个不同的标示符。以下列出了一些正确的标示符：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>mohd         zara      abc     move_name    a_123</pre></td></tr><tr><td data-num="2"></td><td><pre>myname50     _temp     j       a23b9        retVal</pre></td></tr></table></figure><h4 id="关键词"><a class="anchor" href="#关键词">#</a> 关键词</h4><p>以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545745294943-c022acad-e773-4c4e-a469-fdf7b8517204.png" alt="img" /></p><p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p><h3 id="全局变量"><a class="anchor" href="#全局变量">#</a> 全局变量</h3><p>在默认情况下，变量总是认为是全局的。全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">></span> print<span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>nil</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">></span> <span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">10</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">></span> print<span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">10</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">></span></pre></td></tr></table></figure><p>如果你想删除一个全局变量，只需要将变量赋值为 nil。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>b <span class="token operator">=</span> nil</pre></td></tr><tr><td data-num="2"></td><td><pre>print<span class="token punctuation">(</span>b<span class="token punctuation">)</span>      --<span class="token operator">></span> nil</pre></td></tr></table></figure><p>这样变量 b 就好像从没被使用过一样。换句话说，当且仅当一个变量不等于 nil 时，这个变量即存在。</p><hr /><h2 id="lua-数据类型"><a class="anchor" href="#lua-数据类型">#</a> 🍁Lua 数据类型</h2><p>Lua 是动态数据类型语言，变量不要类型定义，只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p><p><img data-src="http://lgqimg.changzer.cn/img/1545746389947-7897ad1a-bbd1-4476-abe4-5f9ea9530fb0.png" alt="img" /></p><p>我们可以使用 type 函数测试给定变量或者值的类型：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">--> string</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">10.4</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment">--> number</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token comment">--> function</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment">--> function</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment">--> boolean</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">--> nil</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">--> string</span></pre></td></tr></table></figure><h3 id="nil空"><a class="anchor" href="#nil空">#</a> nil (空)</h3><p>nil 表示一个没有任何有效值，它只有一个值 --nil，例如打印一个没有赋值的变量，就会输出一个 nil 值：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">nil</span></pre></td></tr></table></figure><p>对于全局变量和 table，nil 还有一个 “删除” 作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>tab1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> key1 <span class="token operator">=</span> <span class="token string">"val1"</span><span class="token punctuation">,</span> key2 <span class="token operator">=</span> <span class="token string">"val2"</span><span class="token punctuation">,</span> <span class="token string">"val3"</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab1<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>k <span class="token operator">..</span> <span class="token string">" - "</span> <span class="token operator">..</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>tab1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab1<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>k <span class="token operator">..</span> <span class="token string">" - "</span> <span class="token operator">..</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1</span><span class="token operator">-</span>val3</pre></td></tr><tr><td data-num="2"></td><td><pre>key1<span class="token operator">-</span>val1</pre></td></tr><tr><td data-num="3"></td><td><pre>key2<span class="token operator">-</span>val2</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">1</span><span class="token operator">-</span>val3</pre></td></tr><tr><td data-num="7"></td><td><pre>key2<span class="token operator">-</span>val2</pre></td></tr></table></figure><p>nil 作比较时应该加上双引号 &quot;：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">type</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">type</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">nil</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">type</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">"nil"</span></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">nil</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">false</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">true</span></pre></td></tr></table></figure><h3 id="boolean"><a class="anchor" href="#boolean">#</a> boolean</h3><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 &quot;假&quot;，其他的都为 &quot;真&quot;:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> <span class="token keyword">false</span> <span class="token keyword">or</span> <span class="token keyword">nil</span> <span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"至少有一个是true"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"false和nil都为false"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>boolean</pre></td></tr><tr><td data-num="2"></td><td><pre>boolean</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">nil</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">false</span>和<span class="token keyword">nil</span>都为<span class="token keyword">false</span></pre></td></tr></table></figure><h3 id="number数字"><a class="anchor" href="#number数字">#</a> number (数字)</h3><p>Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">2e+1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">0.2e-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">7.8263692594256e-06</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>number</pre></td></tr><tr><td data-num="2"></td><td><pre>number</pre></td></tr><tr><td data-num="3"></td><td><pre>number</pre></td></tr><tr><td data-num="4"></td><td><pre>number</pre></td></tr><tr><td data-num="5"></td><td><pre>number</pre></td></tr><tr><td data-num="6"></td><td><pre>number</pre></td></tr></table></figure><h3 id="string字符串"><a class="anchor" href="#string字符串">#</a> string (字符串)</h3><p>字符串由一对双引号或单引号来表示。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>string1 <span class="token operator">=</span> <span class="token string">"this is string1"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>string2 <span class="token operator">=</span> <span class="token string">'this is string2'</span></pre></td></tr></table></figure><p>也可以用 2 个方括号 &quot;[[]]&quot; 来表示 &quot;一块&quot; 字符串</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>html <span class="token operator">=</span> <span class="token string">[[</pre></td></tr><tr><td data-num="2"></td><td><pre>&lt;html></pre></td></tr><tr><td data-num="3"></td><td><pre>&lt;head>&lt;/head></pre></td></tr><tr><td data-num="4"></td><td><pre>&lt;body></pre></td></tr><tr><td data-num="5"></td><td><pre>    &lt;a href="http://www.baidu.com/">百度&lt;/a></pre></td></tr><tr><td data-num="6"></td><td><pre>&lt;/body></pre></td></tr><tr><td data-num="7"></td><td><pre>&lt;/html></pre></td></tr><tr><td data-num="8"></td><td><pre>]]</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">&lt;</span>html<span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">&lt;</span>body<span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.baidu.com/"</span><span class="token operator">></span>百度<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></pre></td></tr></table></figure><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token operator">+</span><span class="token string">"6"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2+6"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"-2e2"</span><span class="token operator">*</span><span class="token string">"6"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行以上代码为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">8</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">8</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2</span><span class="token operator">+</span><span class="token number">6</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">-</span><span class="token number">1200</span></pre></td></tr></table></figure><p>若是执行下面的代码：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"error"</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>则会报错。Lua 中字符串连接使用的是 <code>..</code></p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a"</span> <span class="token operator">..</span> <span class="token string">'b'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">157</span> <span class="token operator">..</span> <span class="token number">428</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>ab</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">157428</span></pre></td></tr></table></figure><p>使用 **#** 来计算字符串的长度，放在字符串的前面：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>len <span class="token operator">=</span> <span class="token string">"www.baidu.com"</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">#</span>len<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">#</span><span class="token string">"ww.baidu.com"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">13</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">13</span></pre></td></tr></table></figure><h3 id="table表"><a class="anchor" href="#table表">#</a> table (表)</h3><p>在 Lua 里，table 的创建是通过 &quot;构造表达式&quot; 来完成，最简单构造表达式是 {}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 创建一个空的 table</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> tbl1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 直接初始表</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">local</span> tbl2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"pear"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"grape"</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>Lua 中的表（table）其实是一个 &quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"value"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>key <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="4"></td><td><pre>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">22</span></pre></td></tr><tr><td data-num="5"></td><td><pre>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">11</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>k <span class="token operator">..</span> <span class="token string">" : "</span> <span class="token operator">..</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>脚本执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>key <span class="token punctuation">:</span> value</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">10</span> <span class="token punctuation">:</span> <span class="token number">30</span></pre></td></tr></table></figure><p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">local</span> tbl <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"pear"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"grape"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tbl<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Key"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>脚本执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>Key    <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Key    <span class="token number">2</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Key    <span class="token number">3</span></pre></td></tr><tr><td data-num="4"></td><td><pre>Key    <span class="token number">4</span></pre></td></tr></table></figure><p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    a3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="5"></td><td><pre>a3<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"val"</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>a3<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>a3<span class="token punctuation">[</span><span class="token string">"none"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>脚本执行结果：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>val</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">nil</span></pre></td></tr></table></figure><h3 id="function函数"><a class="anchor" href="#function函数">#</a> function (函数)</h3><p>在 Lua 中，函数是被看作是 &quot;第一类值（First-Class Value）&quot;，函数可以存在变量里:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">factorial1</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial1</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">factorial1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>factorial2 <span class="token operator">=</span> factorial1</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">factorial2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>脚本执行结果为：</p><pre><code>120120</code></pre><p>function 可以以匿名函数（anonymous function）的方式通过参数传递:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">testFun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span>fun<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> k <span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fun</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>tab<span class="token operator">=</span><span class="token punctuation">&#123;</span>key1<span class="token operator">=</span><span class="token string">"val1"</span><span class="token punctuation">,</span>key2<span class="token operator">=</span><span class="token string">"val2"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">testFun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token comment">-- 匿名函数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> key<span class="token operator">..</span><span class="token string">"="</span><span class="token operator">..</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>脚本执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>key1 <span class="token operator">=</span> val1</pre></td></tr><tr><td data-num="2"></td><td><pre>key2 <span class="token operator">=</span> val2</pre></td></tr></table></figure><h3 id="thread线程"><a class="anchor" href="#thread线程">#</a> thread (线程)</h3><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p><p>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p><h3 id="userdata自定义类型"><a class="anchor" href="#userdata自定义类型">#</a> userdata (自定义类型)</h3><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><hr /><h2 id="lua-变量"><a class="anchor" href="#lua-变量">#</a> 🍁Lua 变量</h2><p>变量在使用前，必须在代码中进行声明，即创建该变量。</p><p>编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。</p><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p><ul><li><p>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p></li><li><p>局部变量的作用域为从声明位置开始到所在语句块结束。</p></li><li><p>变量的默认值均为 nil。</p></li></ul><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a <span class="token operator">=</span> <span class="token number">5</span>               <span class="token comment">-- 全局变量</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> b <span class="token operator">=</span> <span class="token number">5</span>         <span class="token comment">-- 局部变量</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">function</span> <span class="token function">joke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    c <span class="token operator">=</span> <span class="token number">5</span>           <span class="token comment">-- 全局变量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">local</span> d <span class="token operator">=</span> <span class="token number">6</span>     <span class="token comment">-- 局部变量</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">joke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span>          <span class="token comment">--> 5 nil</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token number">6</span>     <span class="token comment">-- 局部变量</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    b <span class="token operator">=</span> <span class="token number">6</span>           <span class="token comment">-- 对局部变量重新赋值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">--> 6 6</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>      <span class="token comment">--> 5 6</span></pre></td></tr></table></figure><p>执行以上实例输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">5</span>    <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">6</span>    <span class="token number">6</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">5</span>    <span class="token number">6</span></pre></td></tr></table></figure><h3 id="赋值语句"><a class="anchor" href="#赋值语句">#</a> 赋值语句</h3><p>赋值是改变一个变量的值和改变表域的最基本的方法。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">..</span> <span class="token string">"world"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>t<span class="token punctuation">.</span>n <span class="token operator">=</span> t<span class="token punctuation">.</span>n <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr></table></figure><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>x       <span class="token operator">&lt;</span><span class="token comment">-->       a=10; b=2*x</span></pre></td></tr></table></figure><p>遇到赋值语句 Lua 会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x                     <span class="token comment">-- swap 'x' for 'y'</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>         <span class="token comment">-- swap 'a[i]' for 'a[j]'</span></pre></td></tr></table></figure><p>当变量个数和值的个数不一致时，Lua 会一直以变量个数为基础采取以下策略：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token punctuation">.</span> 变量个数 <span class="token operator">></span> 值的个数             按变量个数补足<span class="token keyword">nil</span></pre></td></tr><tr><td data-num="2"></td><td><pre>b<span class="token punctuation">.</span> 变量个数 <span class="token operator">&lt;</span> 值的个数             多余的值会被忽略</pre></td></tr></table></figure><p>例如：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span>             <span class="token comment">--> 0   1   nil</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>a<span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">2</span>     <span class="token comment">-- value of b+2 is ignored</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>               <span class="token comment">--> 1   2</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span>             <span class="token comment">--> 0   nil   nil</span></pre></td></tr></table></figure><p>多值赋值经常用来交换变量，或将函数调用返回给变量：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>f () 返回两个值，第一个赋给 a，第二个赋给 b。</p><p>应该尽可能的使用局部变量，有两个好处：1. 避免命名冲突。2. 访问局部变量的速度比全局变量更快。</p><h3 id="索引"><a class="anchor" href="#索引">#</a> 索引</h3><p>对 table 的索引使用方括号 [];Lua 也提供了。操作。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>t<span class="token punctuation">.</span>i                 <span class="token comment">-- 当索引为字符串类型时的一种简化写法</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">gettable_event</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token punctuation">)</span> <span class="token comment">-- 采用索引访问本质上是一个类似这样的函数调用</span></pre></td></tr></table></figure><p>例如:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>site <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>site<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"www.baidu.cc"</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>site<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>site<span class="token punctuation">.</span>key<span class="token punctuation">)</span></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>cc</pre></td></tr><tr><td data-num="2"></td><td><pre>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>cc</pre></td></tr></table></figure><hr /><h2 id="lua-循环"><a class="anchor" href="#lua-循环">#</a> 🍁Lua 循环</h2><p>很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。</p><p>一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。</p><p>循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。</p><p>循环语句是由循环体及循环的终止条件两部分组成的。</p><p><img data-src="http://lgqimg.changzer.cn/img/1545793869721-221c9099-efbc-4138-a2b0-1d5ecb0710d9.png" alt="img" /></p><p>Lua 语言提供了以下几种循环处理方式：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545793890024-9bf3634c-bced-4a3b-a03b-8155d389d483.png" alt="img" /></p><p><strong>循环控制语句</strong></p><p>循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。</p><p>Lua 支持以下循环控制语句：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545793918054-299b32a1-7e74-465f-9ad6-6c46aa29ad3c.png" alt="img" /></p><p><strong>无限循环</strong></p><p>在循环体中如果条件永远为 true 循环语句就会永远执行下去，以下以 while 循环为例：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token keyword">true</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"循环将永远执行下去"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><h3 id="while-循环"><a class="anchor" href="#while-循环">#</a> while 循环</h3><h4 id="语法"><a class="anchor" href="#语法">#</a> 语法</h4><p>Lua 编程语言中 while 循环语法：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    statements</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>statements (循环体语句) 可以是一条或多条语句，condition (条件) 可以是任意表达式，在 condition (条件) 为 true 时执行循环体语句。 流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545794105298-442f3ac5-fbe0-4f54-87c0-324dd4c9c761.png" alt="img" /></p><p>在以上流程图中我们可以看出在 condition (条件) 为 false 时会跳过当前循环并开始脚本执行紧接着的语句。</p><h4 id="示例"><a class="anchor" href="#示例">#</a> 示例</h4><p>以下实例循环输出 a 的值：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token operator">=</span><span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span> a <span class="token operator">&lt;</span> <span class="token number">20</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为:"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   a <span class="token operator">=</span> a<span class="token operator">+</span><span class="token number">1</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>执行以上代码，输出结果如下：</p><pre><code>a 的值为:    10a 的值为:    11a 的值为:    12a 的值为:    13a 的值为:    14a 的值为:    15a 的值为:    16a 的值为:    17a 的值为:    18a 的值为:    19</code></pre><h3 id="for-循环"><a class="anchor" href="#for-循环">#</a> for 循环</h3><p>Lua 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。</p><p>Lua 编程语言中 for 语句有两大类：：</p><ul><li><p>数值 for 循环</p></li><li><p>泛型 for 循环</p></li></ul><h4 id="数值-for-循环"><a class="anchor" href="#数值-for-循环">#</a> 数值 for 循环</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> var<span class="token operator">=</span>exp1<span class="token punctuation">,</span>exp2<span class="token punctuation">,</span>exp3 <span class="token keyword">do</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">&lt;</span>执行体<span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为 1。</p><ul><li><code>var</code>  首先执行，执行一次。此步骤允许声明和初始化任何循环控制变量</li><li>接下来执行 <code>exp2</code> 。 这是循环继续执行的最大值或最小值。 它在内部创建条件检查，以比较初始值和最大 / 最小值。</li><li>在执行 <code>for</code>  循环体之后，控制流会跳回到 <code>exp3</code>  语句。此语句用于更新循环控制变量。</li><li>再次评估条件。 如果为真，则循环执行并且过程自身重复 (循环体，然后递增步骤，然后再次调节)。 条件变为 <code>false</code>  后， <code>for</code>  循环终止。</li></ul><h5 id="实例"><a class="anchor" href="#实例">#</a> 实例</h5><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>for 的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的 f (x) 只会在循环开始前执行一次，其结果用在后面的循环中。</p><p>验证如下:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"function"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> x<span class="token operator">*</span><span class="token number">2</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">3</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">5</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">6</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">7</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">8</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">9</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token number">10</span></pre></td></tr></table></figure><h4 id="泛型-for-循环"><a class="anchor" href="#泛型-for-循环">#</a> 泛型 for 循环</h4><p>泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach 语句。Lua 编程语言中泛型 for 循环语法格式:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 打印数组 a 的所有值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">do</span> <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>i 是数组索引值，v 是对应索引的数组元素值。ipairs 是 Lua 提供的一个迭代器函数，用来迭代数组。</p><h5 id="实例-2"><a class="anchor" href="#实例-2">#</a> 实例</h5><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>days <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Suanday"</span><span class="token punctuation">,</span><span class="token string">"Monday"</span><span class="token punctuation">,</span><span class="token string">"Tuesday"</span><span class="token punctuation">,</span><span class="token string">"Wednesday"</span><span class="token punctuation">,</span><span class="token string">"Thursday"</span><span class="token punctuation">,</span><span class="token string">"Friday"</span><span class="token punctuation">,</span><span class="token string">"Saturday"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>Suanday</pre></td></tr><tr><td data-num="2"></td><td><pre>Monday</pre></td></tr><tr><td data-num="3"></td><td><pre>Tuesday</pre></td></tr><tr><td data-num="4"></td><td><pre>Wednesday</pre></td></tr><tr><td data-num="5"></td><td><pre>Thursday</pre></td></tr><tr><td data-num="6"></td><td><pre>Friday</pre></td></tr><tr><td data-num="7"></td><td><pre>Saturday</pre></td></tr></table></figure><h3 id="repeatuntil-循环"><a class="anchor" href="#repeatuntil-循环">#</a> repeat...until 循环</h3><p>Lua 编程语言中 repeat...until 循环语句不同于 for 和 while 循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat...until 循环的条件语句在当前循环结束后判断。</p><h4 id="语法-2"><a class="anchor" href="#语法-2">#</a> 语法</h4><p>Lua 编程语言中 repeat...until 循环语法格式:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">repeat</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   statements</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">until</span><span class="token punctuation">(</span> condition <span class="token punctuation">)</span></pre></td></tr></table></figure><p>我们注意到循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。</p><p>如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行。</p><p>Lua repeat...until 循环流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795069201-5fce3157-e13f-4f9f-b0d0-e192ad94e769.png" alt="img" /></p><h4 id="实例-3"><a class="anchor" href="#实例-3">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[变量定义 --]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">--[执行循环 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">repeat</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a的值为:"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">until</span><span class="token punctuation">(</span> a <span class="token operator">></span> <span class="token number">15</span> ）</pre></td></tr></table></figure><p>执行以上代码，程序输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a的值为<span class="token punctuation">:</span>    <span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a的值为<span class="token punctuation">:</span>    <span class="token number">11</span></pre></td></tr><tr><td data-num="3"></td><td><pre>a的值为<span class="token punctuation">:</span>    <span class="token number">12</span></pre></td></tr><tr><td data-num="4"></td><td><pre>a的值为<span class="token punctuation">:</span>    <span class="token number">13</span></pre></td></tr><tr><td data-num="5"></td><td><pre>a的值为<span class="token punctuation">:</span>    <span class="token number">14</span></pre></td></tr><tr><td data-num="6"></td><td><pre>a的值为<span class="token punctuation">:</span>    <span class="token number">15</span></pre></td></tr></table></figure><h3 id="嵌套循环"><a class="anchor" href="#嵌套循环">#</a> 嵌套循环</h3><h4 id="语法-3"><a class="anchor" href="#语法-3">#</a> 语法</h4><p>Lua 编程语言中  <code>for</code>  循环嵌套语法格式:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> init<span class="token punctuation">,</span>max<span class="token operator">/</span>min value<span class="token punctuation">,</span> increment</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">for</span> init<span class="token punctuation">,</span>max<span class="token operator">/</span>min value<span class="token punctuation">,</span> increment</pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      statements</pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   statements</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>Lua 编程语言中  <code>while</code>  循环嵌套语法格式:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      statements</pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   statements</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>Lua 编程语言中  <code>repeat...until</code>  循环嵌套语法格式:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">repeat</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   statements</pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">repeat</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      statements</pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">until</span><span class="token punctuation">(</span> condition <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">until</span><span class="token punctuation">(</span> condition <span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="实例-4"><a class="anchor" href="#实例-4">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>j <span class="token operator">=</span><span class="token number">2</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">for</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token operator">/</span>j<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">not</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>         <span class="token keyword">break</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token punctuation">(</span>i<span class="token operator">/</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">then</span></pre></td></tr><tr><td data-num="9"></td><td><pre>         <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"i 的值为："</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">end</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>i 的值为：    <span class="token number">8</span></pre></td></tr><tr><td data-num="2"></td><td><pre>i 的值为：    <span class="token number">9</span></pre></td></tr><tr><td data-num="3"></td><td><pre>i 的值为：    <span class="token number">10</span></pre></td></tr></table></figure><h3 id="break-语句"><a class="anchor" href="#break-语句">#</a> break 语句</h3><p>Lua 编程语言 break 语句插入在循环体中，用于退出当前循环或语句，并开始脚本执行紧接着的语句。</p><p>如果你使用循环嵌套，break 语句将停止最内层循环的执行，并开始执行的外层的循环语句。</p><h4 id="语法-4"><a class="anchor" href="#语法-4">#</a> 语法</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">break</span></pre></td></tr></table></figure><p>流程图：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795441489-29359564-29c0-4153-9d50-4844cce2e22c.png" alt="img" /></p><h4 id="实例-5"><a class="anchor" href="#实例-5">#</a> 实例</h4><p>下实例执行 while 循环，在变量 a 小于 20 时输出 a 的值，并在 a 大于 15 时终止执行循环：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[定义变量 --]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">--[while 循环 --]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span> a <span class="token operator">&lt;</span> <span class="token number">20</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为:"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   a<span class="token operator">=</span>a<span class="token operator">+</span><span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">></span> <span class="token number">15</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token keyword">then</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token comment">--[使用 break 语句终止循环 --]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token keyword">break</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">11</span></pre></td></tr><tr><td data-num="3"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">12</span></pre></td></tr><tr><td data-num="4"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">13</span></pre></td></tr><tr><td data-num="5"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">14</span></pre></td></tr><tr><td data-num="6"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">15</span></pre></td></tr></table></figure><hr /><h2 id="lua-流程控制"><a class="anchor" href="#lua-流程控制">#</a> 🍁Lua 流程控制</h2><p>Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。</p><p>下图是典型的流程控制流程图：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795625575-64b9f249-ad85-4d9f-862a-5cd0ffcbb041.png" alt="img" /></p><p>控制结构的条件表达式结果可以是任何值，Lua 认为 false 和 nil 为假，true 和非 nil 为真。<br />要注意的是 Lua 中 0 为 true：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[0 为 true]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"0 为 true"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上代码输出结果为:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">0</span> 为 <span class="token keyword">true</span></pre></td></tr></table></figure><p>Lua 提供了以下控制结构语句：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795674871-1b606327-d0f9-42a6-b2d4-9d80989d0922.png" alt="img" /></p><h3 id="if-语句"><a class="anchor" href="#if-语句">#</a> if 语句</h3><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">--[在布尔表达式为 true 时执行的语句 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>在布尔表达式为 true 时会 if 中的代码块会被执行，在布尔表达式为 false 时，紧跟在 if 语句 end 之后的代码会被执行。Lua 认为 false 和 nil 为假，true 和非 nil 为真。要注意的是 Lua 中 0 为 true。</p><p>if 语句流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795704210-35cebb75-bc38-457b-98f5-648a9cb680d8.png" alt="img" /></p><h4 id="实例-6"><a class="anchor" href="#实例-6">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[定义变量 --]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">--[使用 if 语句 --]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">&lt;</span> <span class="token number">20</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token comment">--[if 条件为 true 时打印以下信息 --]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 小于 20"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为:"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a 小于 <span class="token number">20</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a 的值为<span class="token punctuation">:</span>    <span class="token number">10</span></pre></td></tr></table></figure><h3 id="ifelse-语句"><a class="anchor" href="#ifelse-语句">#</a> if...else 语句</h3><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">--[布尔表达式为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token comment">--[布尔表达式为 false 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>在布尔表达式为 true 时会 if 中的代码块会被执行，在布尔表达式为 false 时，else 的代码块会被执行。Lua 认为 false 和 nil 为假，true 和非 nil 为真。要注意的是 Lua 中 0 为 true。</p><p>if 语句流程图如下：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545795776591-cf111597-927b-4ea3-af19-15f56fee05b2.png" alt="img" /></p><h4 id="实例-7"><a class="anchor" href="#实例-7">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[定义变量 --]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">--[检查条件 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">&lt;</span> <span class="token number">20</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token comment">--[if 条件为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 小于 20"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token comment">--[if 条件为 false 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 大于 20"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为 :"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a 大于 <span class="token number">20</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a 的值为 <span class="token punctuation">:</span>    <span class="token number">100</span></pre></td></tr></table></figure><h3 id="ifelse-ifelse-语句"><a class="anchor" href="#ifelse-ifelse-语句">#</a> if...else if...else 语句</h3><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span> 布尔表达式 <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">--[在布尔表达式 1 为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">elseif</span><span class="token punctuation">(</span> 布尔表达式 <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token comment">--[在布尔表达式 2 为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">elseif</span><span class="token punctuation">(</span> 布尔表达式 <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">--[在布尔表达式 3 为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token comment">--[如果以上布尔表达式都不为 true 则执行该语句块 --]</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><h4 id="实例-8"><a class="anchor" href="#实例-8">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[定义变量 --]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">100</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">--[检查布尔条件 --]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">10</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token comment">--[如果条件为 true 打印以下信息 --]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为 10"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">elseif</span><span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">20</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">--[if else if 条件为 true 时打印以下信息 --]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为 20"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">elseif</span><span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">30</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token comment">--[if else if condition 条件为 true 时打印以下信息 --]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为 30"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   <span class="token comment">--[以上条件语句没有一个为 true 时打印以下信息 --]</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"没有匹配 a 的值"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的真实值为: "</span><span class="token punctuation">,</span> a <span class="token punctuation">)</span></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>没有匹配 a 的值</pre></td></tr><tr><td data-num="2"></td><td><pre>a 的真实值为<span class="token punctuation">:</span>     <span class="token number">100</span></pre></td></tr></table></figure><h3 id="if-嵌套语句"><a class="anchor" href="#if-嵌套语句">#</a> if 嵌套语句</h3><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span> 布尔表达式 <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">--[布尔表达式 1 为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式 <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token comment">--[布尔表达式 2 为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><h4 id="实例-9"><a class="anchor" href="#实例-9">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[定义变量 --]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">--[检查条件 --]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">100</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">--[if 条件为 true 时执行以下 if 条件判断 --]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token keyword">if</span><span class="token punctuation">(</span> b <span class="token operator">==</span> <span class="token number">200</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token keyword">then</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token comment">--[if 条件为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为 100 b 的值为 200"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a 的值为 :"</span><span class="token punctuation">,</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"b 的值为 :"</span><span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a 的值为 <span class="token number">100</span> b 的值为 <span class="token number">200</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a 的值为 <span class="token punctuation">:</span>    <span class="token number">100</span></pre></td></tr><tr><td data-num="3"></td><td><pre>b 的值为 <span class="token punctuation">:</span>    <span class="token number">200</span></pre></td></tr></table></figure><hr /><h2 id="lua-函数"><a class="anchor" href="#lua-函数">#</a> 🍁Lua 函数</h2><p>在 Lua 中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如 print () 函数可以将传入的参数打印在控制台上。</p><p>Lua 函数主要有两种用途：</p><ul><li><p>1. 完成指定的任务，这种情况下函数作为调用语句使用；</p></li><li><p>2. 计算并返回值，这种情况下函数作为赋值语句的表达式使用。</p></li></ul><h3 id="函数定义"><a class="anchor" href="#函数定义">#</a> 函数定义</h3><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>optional_function_scope <span class="token keyword">function</span> <span class="token function">function_name</span><span class="token punctuation">(</span> argument1<span class="token punctuation">,</span> argument2<span class="token punctuation">,</span> argument3<span class="token punctuation">...</span><span class="token punctuation">,</span> argumentn<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    function_body</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> result_params_comma_separated</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>解析</p><ul><li><p>optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</p></li><li><p>function_name: 指定函数名称。</p></li><li><p>argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</p></li><li><p>function_body: 函数体，函数中需要执行的代码语句块。</p></li><li><p>result_params_comma_separated: 函数返回值，Lua 语言函数可以返回多个值，每个值以逗号隔开。</p></li></ul><h4 id="实例-10"><a class="anchor" href="#实例-10">#</a> 实例</h4><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--[[函数返回两个值的最大值 --]]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">max</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">if</span> <span class="token punctuation">(</span>num1 <span class="token operator">></span> num2<span class="token punctuation">)</span> <span class="token keyword">then</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      result <span class="token operator">=</span> num1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">else</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      result <span class="token operator">=</span> num2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">-- 调用函数</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"两值比较最大值为 "</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"两值比较最大值为 "</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>两值比较最大值为     <span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre>两值比较最大值为     <span class="token number">6</span></pre></td></tr></table></figure><p>Lua 中我们可以将函数作为参数传递给函数，如下实例：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>myprint <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"这是打印函数 -   ##"</span><span class="token punctuation">,</span>param<span class="token punctuation">,</span><span class="token string">"##"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span>num2<span class="token punctuation">,</span>functionPrint<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2</pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token comment">-- 调用传递的函数参数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token function">functionPrint</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">myprint</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">-- myprint 函数作为参数传递</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>myprint<span class="token punctuation">)</span></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>这是打印函数 <span class="token operator">-</span>   <span class="token operator">#</span><span class="token operator">#</span>    <span class="token number">10</span>    <span class="token operator">#</span><span class="token operator">#</span></pre></td></tr><tr><td data-num="2"></td><td><pre>这是打印函数 <span class="token operator">-</span>   <span class="token operator">#</span><span class="token operator">#</span>    <span class="token number">7</span>    <span class="token operator">#</span><span class="token operator">#</span></pre></td></tr></table></figure><h3 id="多返回值"><a class="anchor" href="#多返回值">#</a> 多返回值</h3><p>Lua 函数可以返回多个结果值，比如 string.find，其返回匹配串 &quot;开始和结束的下标&quot;（如果不存在匹配串返回 nil）。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>s<span class="token punctuation">,</span> e <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">,</span> <span class="token string">"baidu"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">)</span></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">5</span>    <span class="token number">9</span></pre></td></tr></table></figure><p>Lua 函数中，在 return 后列出要返回的值得列表即可返回多值，如</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">maximum</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">local</span> mi <span class="token operator">=</span> <span class="token number">1</span>             <span class="token comment">-- 最大值索引</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">local</span> m <span class="token operator">=</span> a<span class="token punctuation">[</span>mi<span class="token punctuation">]</span>          <span class="token comment">-- 最大值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> i<span class="token punctuation">,</span>val <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>       <span class="token keyword">if</span> val <span class="token operator">></span> m <span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>           mi <span class="token operator">=</span> i</pre></td></tr><tr><td data-num="7"></td><td><pre>           m <span class="token operator">=</span> val</pre></td></tr><tr><td data-num="8"></td><td><pre>       <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> m<span class="token punctuation">,</span> mi</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">23</span>    <span class="token number">3</span></pre></td></tr></table></figure><h3 id="可变参数"><a class="anchor" href="#可变参数">#</a> 可变参数</h3><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 ... 表示函数有可变的参数。</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> s <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">&#123;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span> <span class="token keyword">do</span>   <span class="token comment">--> &#123;...&#125; 表示一个由所有变长参数构成的数组</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    s <span class="token operator">=</span> s <span class="token operator">+</span> v</pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">end</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">return</span> s</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">--->25</span></pre></td></tr></table></figure><p>我们可以将可变参数赋值给一个变量。例如，我们计算几个数的平均值：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   result <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">local</span> arg<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span>    <span class="token comment">--> arg 为一个表，局部变量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      result <span class="token operator">=</span> result <span class="token operator">+</span> v</pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"总共传入 "</span> <span class="token operator">..</span> <span class="token operator">#</span>arg <span class="token operator">..</span> <span class="token string">" 个数"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">return</span> result<span class="token operator">/</span><span class="token operator">#</span>arg</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"平均值为"</span><span class="token punctuation">,</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">25</span></pre></td></tr></table></figure><p>我们也可以通过 select (&quot;#&quot;,...) 来获取可变参数的数量:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   result <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">local</span> arg<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      result <span class="token operator">=</span> result <span class="token operator">+</span> v</pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"总共传入 "</span> <span class="token operator">..</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">,</span><span class="token punctuation">...</span><span class="token punctuation">)</span> <span class="token operator">..</span> <span class="token string">" 个数"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">return</span> result<span class="token operator">/</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">,</span><span class="token punctuation">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"平均值为"</span><span class="token punctuation">,</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">fwrite</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span>  <span class="token comment">---> 固定的参数 fmt</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token string">"runoob\n"</span><span class="token punctuation">)</span>       <span class="token comment">--->fmt = "runoob", 没有变长参数。</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token string">"%d%d\n"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">--->fmt = "% d% d", 变长参数为 1 和 1</span></pre></td></tr></table></figure><p>通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select ('#', …) 或者 select (n, …)</p><ul><li><p>select ('#', …) 返回可变参数的长度</p></li><li><p>select (n, …) 用于访问 n 到 select ('#',…) 的参数</p></li></ul><p>调用 select 时，必须传入一个固定实参 selector (选择开关) 和一系列变长参数。如果 selector 为数字 n, 那么 select 返回它的第 n 个可变实参，否则只能为字符串 &quot;#&quot;, 这样 select 会返回变长参数的总数。例子代码：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token comment">--> 获取参数总数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">local</span> arg <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">--> 读取参数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"arg"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>arg    <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>arg    <span class="token number">2</span></pre></td></tr><tr><td data-num="3"></td><td><pre>arg    <span class="token number">3</span></pre></td></tr><tr><td data-num="4"></td><td><pre>arg    <span class="token number">4</span></pre></td></tr></table></figure><hr /><h2 id="lua-运算符"><a class="anchor" href="#lua-运算符">#</a> 🍁Lua 运算符</h2><p>运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua 提供了以下几种运算符类型：</p><ul><li><p>算术运算符</p></li><li><p>关系运算符</p></li><li><p>逻辑运算符</p></li><li><p>其他运算符</p></li></ul><h3 id="算数运算符"><a class="anchor" href="#算数运算符">#</a> 算数运算符</h3><p>下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为 10，B 的值为 20：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796915099-182b544e-343b-4338-827b-16d5ce9807ff.png" alt="img" /></p><h3 id="关系运算符"><a class="anchor" href="#关系运算符">#</a> 关系运算符</h3><p>下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为 10，B 的值为 20：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796934445-08762e3c-8245-4964-ba85-d2469ae31630.png" alt="img" /></p><h3 id="逻辑运算符"><a class="anchor" href="#逻辑运算符">#</a> 逻辑运算符</h3><p>下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796955997-b3a7dee8-81f8-42ce-9631-1f0e30b15143.png" alt="img" /></p><h3 id="其他运算符"><a class="anchor" href="#其他运算符">#</a> 其他运算符</h3><p>下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545796993558-cd2c7425-bff9-46c2-96f7-40ab6574733b.png" alt="img" /></p><h3 id="运算符优先级"><a class="anchor" href="#运算符优先级">#</a> 运算符优先级</h3><p>从高到低的顺序：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">^</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">not</span>    <span class="token operator">-</span> <span class="token punctuation">(</span>unary<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">*</span>      <span class="token operator">/</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">+</span>      <span class="token operator">-</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">..</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">&lt;</span>      <span class="token operator">></span>      <span class="token operator">&lt;=</span>     <span class="token operator">>=</span>     <span class="token operator">~=</span>     <span class="token operator">==</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">and</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">or</span></pre></td></tr></table></figure><p>除了 ^ 和.. 外所有的二元运算符都是左连接的</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token operator">+</span>i <span class="token operator">&lt;</span> b<span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span>          <span class="token operator">&lt;</span><span class="token comment">-->       (a+i) &lt; ((b/2)+1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">5</span><span class="token operator">+</span>x<span class="token operator">^</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">8</span>              <span class="token operator">&lt;</span><span class="token comment">-->       5+((x^2)*8)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>a <span class="token operator">&lt;</span> y <span class="token keyword">and</span> y <span class="token operator">&lt;=</span> z     <span class="token operator">&lt;</span><span class="token comment">-->       (a &lt; y) and (y &lt;= z)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">-</span>x<span class="token operator">^</span><span class="token number">2</span>                 <span class="token operator">&lt;</span><span class="token comment">-->       -(x^2)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>x<span class="token operator">^</span>y<span class="token operator">^</span>z                <span class="token operator">&lt;</span><span class="token comment">-->       x^(y^z)</span></pre></td></tr></table></figure><hr /><h2 id="lua-字符串"><a class="anchor" href="#lua-字符串">#</a> 🍁Lua 字符串</h2><p>字符串或串 (String) 是由数字、字母、下划线组成的一串字符</p><p>Lua 语言中字符串可以使用以下三种方式来表示：</p><ul><li><p>单引号间的一串字符</p></li><li><p>双引号的一串字符</p></li><li><p>[[和]] 间的一串字符</p></li></ul><p>以上三种方式的字符串实例如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>string1 <span class="token operator">=</span> <span class="token string">"Lua"</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\"字符串 1 是\""</span><span class="token punctuation">,</span>string1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>string2 <span class="token operator">=</span> <span class="token string">'runoob.com'</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"字符串 2 是"</span><span class="token punctuation">,</span>string2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>string3 <span class="token operator">=</span> <span class="token string">[["Lua 教程"]]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"字符串 3 是"</span><span class="token punctuation">,</span>string3<span class="token punctuation">)</span></pre></td></tr></table></figure><p>以上代码执行输出结果是：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token string">"字符串 1 是"</span>    Lua</pre></td></tr><tr><td data-num="2"></td><td><pre>字符串 <span class="token number">2</span> 是    runoob<span class="token punctuation">.</span>com</pre></td></tr><tr><td data-num="3"></td><td><pre>字符串 <span class="token number">3</span> 是    <span class="token string">"Lua 教程"</span></pre></td></tr></table></figure><p>转义字符用于表示不能直接显示的字符，比如后退键，回车键，等。如在字符串转换双引号可以使用 &quot;&quot;&quot;。所有的转义字符和所对应的意义：</p><p><img data-src="http://lgqimg.changzer.cn/img/1545799061644-a6952d51-146a-4331-a0f6-2eeb9c40ac00.png" alt="img" /></p><h3 id="字符串操作"><a class="anchor" href="#字符串操作">#</a> 字符串操作</h3><p><img data-src="http://lgqimg.changzer.cn/img/1545799123960-edb58671-3992-4e1c-9e3d-4c84aac76664.png" alt="img" /></p><h3 id="字符串格式化"><a class="anchor" href="#字符串格式化">#</a> 字符串格式化</h3><p>Lua 提供了 string.format () 函数来生成具有特定格式的字符串，函数的第一个参数是格式，之后是对应格式中每个代号的各种数据。</p><p>由于格式字符串的存在，使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf ()。</p><p>以下实例演示了如何对字符串进行格式化操作：格式字符串可能包含以下的转义码:</p><ul><li><p>% c - 接受一个数字，并将其转化为 ASCII 码表中对应的字符</p></li><li><p>% d, % i - 接受一个数字并将其转化为有符号的整数格式</p></li><li><p>% o - 接受一个数字并将其转化为八进制数格式</p></li><li><p>% u - 接受一个数字并将其转化为无符号整数格式</p></li><li><p>% x - 接受一个数字并将其转化为十六进制数格式，使用小写字母</p></li><li><p>% X - 接受一个数字并将其转化为十六进制数格式，使用大写字母</p></li><li><p>% e - 接受一个数字并将其转化为科学记数法格式，使用小写字母 e</p></li><li><p>% E - 接受一个数字并将其转化为科学记数法格式，使用大写字母 E</p></li><li><p>% f - 接受一个数字并将其转化为浮点数格式</p></li><li><p>% g (% G) - 接受一个数字并将其转化为 % e (% E, 对应 % G) 及 % f 中较短的一种格式</p></li><li><p>% q - 接受一个字符串并将其转化为可安全被 Lua 编译器读入的格式</p></li><li><p>% s - 接受一个字符串并按照给定的参数格式化该字符串</p></li></ul><p>为进一步细化格式，可以在 % 号后添加参数。参数将以如下的顺序读入:</p><ul><li>(1) 符号：一个 + 号表示其后的数字转义符将让正数显示正号。默认情况下只有负数显示符号.</li><li>(2) 占位符：一个 0, 在后面指定了字串宽度时占位用。不填时的默认占位符是空格.</li><li>(3) 对齐标识：在指定了字串宽度时，默认为右对齐，增加 - 号可以改为左对齐.</li><li>(4) 宽度数值</li><li>(5) 小数位数 / 字串裁切：在宽度数值后增加的小数部分 n, 若后接 f (浮点数转义符，如 %6.3f) 则设定该浮点数的小数只保留 n 位，若后接 s (字符串转义符，如 %5.3s) 则设定该字符串只显示前 n 位.</li></ul><hr /><h2 id="lua数组"><a class="anchor" href="#lua数组">#</a> 🍁Lua 数组</h2><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。</p><h3 id="一维数组"><a class="anchor" href="#一维数组">#</a> 一维数组</h3><p>一维数组是最简单的数组，其逻辑结构是线性表。一维数组可以用 for 循环出数组中的元素，如下实例：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>array<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"Lua"</span><span class="token punctuation">,</span><span class="token string">"Tutorial"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上代码执行输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">nil</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Lua</pre></td></tr><tr><td data-num="3"></td><td><pre>Tutorial</pre></td></tr></table></figure><p>正如你所看到的，我们可以使用整数索引来访问数组元素，如果知道的索引没有值则返回 nil。在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始。除此外我们还可以以负数为数组索引值：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span><span class="token number">2</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">-</span><span class="token number">4</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">-</span><span class="token number">2</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4</span></pre></td></tr></table></figure><h3 id="多纬数组"><a class="anchor" href="#多纬数组">#</a> 多纬数组</h3><p>多维数组即数组中包含数组或一维数组的索引键对应一个数组。以下是一个三行三列的阵列多维数组：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 初始化数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre>array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">for</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="6"></td><td><pre>         array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">*</span>j</pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">-- 访问数组</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token keyword">for</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>不同索引键的三行三列阵列多维数组：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 初始化数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre>array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>maxRows <span class="token operator">=</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="4"></td><td><pre>maxColumns <span class="token operator">=</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> row<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>maxRows <span class="token keyword">do</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">for</span> col<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>maxColumns <span class="token keyword">do</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      array<span class="token punctuation">[</span>row<span class="token operator">*</span>maxColumns <span class="token operator">+</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> row<span class="token operator">*</span>col</pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">-- 访问数组</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">for</span> row<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>maxRows <span class="token keyword">do</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">for</span> col<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>maxColumns <span class="token keyword">do</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>row<span class="token operator">*</span>maxColumns <span class="token operator">+</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上代码执行输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">3</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">6</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">3</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">6</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">9</span></pre></td></tr></table></figure><p>如你所看到的，以上的实例中，数组设定了指定的索引值，这样可以避免出现 nil 值，有利于节省内存空间。</p><hr /><h2 id="lua垃圾回收"><a class="anchor" href="#lua垃圾回收">#</a> 🍁Lua 垃圾回收</h2><p>Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p><p>Lua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p><p>Lua 实现了一个<ins class="" dot="">增量标记 - 扫描收集器</ins>。 它使用这两个数字来控制垃圾收集循环： <ins class="" dot="">垃圾收集器间歇率和垃圾收集器步进倍率</ins>。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p><p>垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</p><p>垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的 &quot;两倍&quot; 速工作。</p><p>如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。</p><h3 id="垃圾回收器函数"><a class="anchor" href="#垃圾回收器函数">#</a> 垃圾回收器函数</h3><p>Lua 提供了以下函数 collectgarbage ([opt [, arg]]) 用来控制自动内存管理:</p><ul><li><p><code>collectgarbage(&quot;collect&quot;)</code> : 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</p></li><li><p><code>collectgarbage(&quot;count&quot;)</code> : 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</p></li><li><p><code>collectgarbage(&quot;restart&quot;)</code> : 重启垃圾收集器的自动运行。</p></li><li><p><code>collectgarbage(&quot;setpause&quot;)</code> : 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。</p></li><li><p><code>collectgarbage(&quot;setstepmul&quot;)</code> : 返回 步进倍率 的前一个值。</p></li><li><p><code>collectgarbage(&quot;step&quot;)</code> : 单步运行垃圾收集器。 步长 &quot;大小&quot; 由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</p></li><li><p><code>collectgarbage(&quot;stop&quot;)</code> : 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行</p></li></ul><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>mytable <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">collectgarbage</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>mytable <span class="token operator">=</span> <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">collectgarbage</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">collectgarbage</span><span class="token punctuation">(</span><span class="token string">"collect"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">collectgarbage</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>执行以上程序，输出结果如下 (注意内存使用的变化)：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">20.9560546875</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">20.9853515625</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">19.4111328125</span></pre></td></tr></table></figure><hr /><h2 id="lua数据库访问"><a class="anchor" href="#lua数据库访问">#</a> 🍁Lua 数据库访问</h2><p>Lua 数据库的操作库为：LuaSQL。它是开源的，支持的数据库有：ODBC、ADO、Oracle、MySQL、SQLite 和 PostgreSQL。</p><p>LuaSQL 可以使用 LuaRocks 来安装可以根据需要安装你需要的数据库驱动。LuaRocks 安装方法：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">wget</span> http://luarocks.org/releases/luarocks-2.2.1.tar.gz</pre></td></tr><tr><td data-num="2"></td><td><pre>$ <span class="token function">tar</span> zxpf luarocks-2.2.1.tar.gz</pre></td></tr><tr><td data-num="3"></td><td><pre>$ <span class="token builtin class-name">cd</span> luarocks-2.2.1</pre></td></tr><tr><td data-num="4"></td><td><pre>$ ./configure<span class="token punctuation">;</span> <span class="token function">sudo</span> <span class="token function">make</span> bootstrap</pre></td></tr><tr><td data-num="5"></td><td><pre>$ <span class="token function">sudo</span> luarocks <span class="token function">install</span> luasocket</pre></td></tr><tr><td data-num="6"></td><td><pre>$ lua</pre></td></tr><tr><td data-num="7"></td><td><pre>Lua <span class="token number">5.3</span>.0 Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">1994</span>-2015 Lua.org, PUC-Rio</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token operator">></span> require <span class="token string">"socket"</span></pre></td></tr></table></figure><p>Window 下安装 LuaRocks：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlcGxlcnByb2plY3QvbHVhcm9ja3Mvd2lraS9JbnN0YWxsYXRpb24taW5zdHJ1Y3Rpb25zLWZvci1XaW5kb3dz">https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows</span></p><p>安装不同数据库驱动：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>luarocks <span class="token function">install</span> luasql-sqlite3</pre></td></tr><tr><td data-num="2"></td><td><pre>luarocks <span class="token function">install</span> luasql-postgres</pre></td></tr><tr><td data-num="3"></td><td><pre>luarocks <span class="token function">install</span> luasql-mysql</pre></td></tr><tr><td data-num="4"></td><td><pre>luarocks <span class="token function">install</span> luasql-sqlite</pre></td></tr><tr><td data-num="5"></td><td><pre>luarocks <span class="token function">install</span> luasql-odbc</pre></td></tr></table></figure><p>你也可以使用源码安装方式，Lua Github 源码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlcGxlcnByb2plY3QvbHVhc3Fs">https://github.com/keplerproject/luasql</span></p><p>Lua 连接 MySql 数据库：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>require <span class="token string">"luasql.mysql"</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 创建环境对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre>env <span class="token operator">=</span> luasql<span class="token punctuation">.</span><span class="token function">mysql</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">-- 连接数据库</span></pre></td></tr><tr><td data-num="7"></td><td><pre>conn <span class="token operator">=</span> env<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token string">"数据库名"</span><span class="token punctuation">,</span><span class="token string">"用户名"</span><span class="token punctuation">,</span><span class="token string">"密码"</span><span class="token punctuation">,</span><span class="token string">"IP地址"</span><span class="token punctuation">,</span>端口<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">-- 设置数据库的编码格式</span></pre></td></tr><tr><td data-num="10"></td><td><pre>conn<span class="token punctuation">:</span>execute<span class="token string">"SET NAMES UTF8"</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">-- 执行数据库操作</span></pre></td></tr><tr><td data-num="13"></td><td><pre>cur <span class="token operator">=</span> conn<span class="token punctuation">:</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">"select * from role"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>row <span class="token operator">=</span> cur<span class="token punctuation">:</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">-- 文件对象的创建</span></pre></td></tr><tr><td data-num="18"></td><td><pre>file <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"role.txt"</span><span class="token punctuation">,</span><span class="token string">"w+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">while</span> row <span class="token keyword">do</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    var <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d %s\n"</span><span class="token punctuation">,</span> row<span class="token punctuation">.</span>id<span class="token punctuation">,</span> row<span class="token punctuation">.</span>name<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    file<span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    row <span class="token operator">=</span> cur<span class="token punctuation">:</span><span class="token function">fetch</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>file<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">-- 关闭文件对象</span></pre></td></tr><tr><td data-num="32"></td><td><pre>conn<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">-- 关闭数据库连接</span></pre></td></tr><tr><td data-num="33"></td><td><pre>env<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">-- 关闭数据库环境</span></pre></td></tr></table></figure><hr /><h2 id="lua迭代器"><a class="anchor" href="#lua迭代器">#</a> 🍁Lua 迭代器</h2><p>迭代器 (iterator) 是一种对象，它能够用来遍历标准模版库容器的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p><p>在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p><h3 id="泛型for迭代器"><a class="anchor" href="#泛型for迭代器">#</a> 泛型 for 迭代器</h3><p>泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>上面代码中，k 和 v 为变量列表；pairs (t) 为表达式列表。查看如下实例：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Lua"</span><span class="token punctuation">,</span> <span class="token string">"Tutorial"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上代码执行输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1</span>  Lua</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2</span>  Tutorial</pre></td></tr></table></figure><p>以上实例中我们使用了 Lua 默认提供的迭代函数 ipairs。</p><p>下面我们看看泛型 for 的执行过程：</p><ul><li><p>首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。</p></li><li><p>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</p></li><li><p>第三，将迭代函数返回的值赋给变量列表。</p></li><li><p>第四，如果返回的第一个值为 nil 循环结束，否则执行循环体。第五，回到第二步再次调用迭代函数</p></li></ul><h3 id="无状态的迭代器"><a class="anchor" href="#无状态的迭代器">#</a> 无状态的迭代器</h3><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。</p><p>以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>iteratorMaxCount<span class="token punctuation">,</span>currentNumber<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token keyword">if</span> currentNumber<span class="token operator">&lt;</span>iteratorMaxCount</pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">then</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      currentNumber <span class="token operator">=</span> currentNumber<span class="token operator">+</span><span class="token number">1</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">return</span> currentNumber<span class="token punctuation">,</span> currentNumber<span class="token operator">*</span>currentNumber</pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">for</span> i<span class="token punctuation">,</span>n <span class="token keyword">in</span> square<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1</span>    <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2</span>    <span class="token number">4</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">3</span>    <span class="token number">9</span></pre></td></tr></table></figure><p>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs 和迭代函数都很简单，我们在 Lua 中可以这样实现：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">iter</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">local</span> v <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> v <span class="token keyword">then</span></pre></td></tr><tr><td data-num="5"></td><td><pre>       <span class="token keyword">return</span> i<span class="token punctuation">,</span> v</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="8"></td><td><pre> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">function</span> <span class="token function">ipairs</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> iter<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><h3 id="多状态的迭代器"><a class="anchor" href="#多状态的迭代器">#</a> 多状态的迭代器</h3><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p><p>以下实例我们创建了自己的迭代器：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>array <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Lua"</span><span class="token punctuation">,</span> <span class="token string">"Tutorial"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">function</span> <span class="token function">elementIterator</span> <span class="token punctuation">(</span>collection<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">local</span> index <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">local</span> count <span class="token operator">=</span> <span class="token operator">#</span>collection</pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token comment">-- 闭包函数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      index <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token keyword">if</span> index <span class="token operator">&lt;=</span> count</pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">then</span></pre></td></tr><tr><td data-num="11"></td><td><pre>         <span class="token comment">--  返回迭代器的当前元素</span></pre></td></tr><tr><td data-num="12"></td><td><pre>         <span class="token keyword">return</span> collection<span class="token punctuation">[</span>index<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">end</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token function">elementIterator</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>Lua</pre></td></tr><tr><td data-num="2"></td><td><pre>Tutorial</pre></td></tr></table></figure><p>以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。</p><hr />]]></content>
      
      
      <categories>
          
          <category> 计算机语言学习 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP:第一章</title>
      <link href="/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/"/>
      <url>/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="csapp第一章"><a class="anchor" href="#csapp第一章">#</a> 《CSAPP：第一章》</h1><h2 id="11-信息就是位上下文"><a class="anchor" href="#11-信息就是位上下文">#</a> 1.1 信息就是位 + 上下文</h2><p>程序的生命周期从源程序 (源文件) 开始。源程序实际上就是由 0 和 1 组成的位序列。</p><p>一般 ASCII 标准来表示文本字符，实际上是用一个字节的整数值来表示一种字符。</p><p>源文件中每个文本行都是以看不见的 '\n' 结束的。</p><p>只由 ASCII 字符组成的文件成为<strong>文本文件</strong>，其他都是<strong>二进制文件</strong>。.cpp 文件就是文本文件。</p><p>系统中的所有信息都是由一串比特（bit：位）表示的，区分不同数据对象的<strong>唯一方法</strong>就是根据上下文。</p><p><strong>C 语言的特点</strong></p><ol><li>C 语言小而简单</li><li>C 语言是为了实现 unix 而设计的</li><li>C 语言与 unix 关系密切</li></ol><p>C 语言是系统级编程的首选，也非常适用于应用级程序。</p><h2 id="12-程序被其他程序翻译成不同的格式"><a class="anchor" href="#12-程序被其他程序翻译成不同的格式">#</a> <strong>1.2</strong> 程序被其他程序翻译成不同的格式</h2><p>从源程序到目标程序要经历<strong>四个步骤：</strong></p><ol><li>源程序被<strong>预处理器</strong>处理得到<strong>修改了的源程序</strong>（文本文件，hello.i）</li><li>再由<strong>编译器</strong>处理得到<strong>汇编程序</strong>（文本文件，hello.s）</li><li>汇编程序由<strong>汇编器</strong>处理得到<strong>可重定位目标程序</strong>（二进制文件，hello.o）</li><li>最后由<strong>链接器</strong>链接得到<strong>可执行目标程序</strong>（二进制文件，hello）</li></ol><p><strong>预处理阶段</strong></p><p>预处理器根据 # 开头的命令修改原始的 c 程序。比如根据 #include 命令把头文件 stdio.h 的内容直接插入到程序文件中</p><p><strong>编译阶段</strong></p><p><strong>汇编阶段</strong></p><p><strong>链接阶段</strong></p><p>比如 printf 函数是一个标准 C 库函数，存在于 printf.o 中，这是一个单独的预编译好了的目标文件。链接器将其与汇编得到的二进制文件合并得到可执行目标文件。</p><h2 id="13-了解编译系统如何工作是大有用处的"><a class="anchor" href="#13-了解编译系统如何工作是大有用处的">#</a> 1.3 了解编译系统如何工作是大有用处的</h2><p>用处：</p><ol><li>优化程序性能</li><li>理解链接时出现的错误</li><li>避免安全漏洞</li></ol><h2 id="14-处理器读并解释储存在内存中的指令"><a class="anchor" href="#14-处理器读并解释储存在内存中的指令">#</a> 1.4 处理器读并解释储存在内存中的指令</h2><p>shell 是一个命令行解释器，它输出一个提示符（&gt;&gt;），等待输入一个命令行，然后执行命令。如果输入的是可执行文件的名字，就运行该文件。</p><h3 id="141-系统的硬件组成"><a class="anchor" href="#141-系统的硬件组成">#</a> 1.4.1 系统的硬件组成</h3><p>主要包括<strong>总线、I/O 设备、处理器、主存储器 **** 四个部分</strong></p><ol><li><p><strong>总线</strong></p><p>总线一次可以传输一个定长的字节块，称为字。64 位系统即总线一次可以传输 64 位（8 字节），这里一个字就是 8 字节</p></li><li><p><strong>I/O 设备</strong></p><p>每个 I/O 设备通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I/O 总线相连。</p><p><strong>控制器</strong>是 I/O 设备本身或主板上的芯片组，<strong>适配器</strong>则是一块插在主板上的卡。</p></li><li><p><strong>主存</strong></p><p>主存是由一组 ** 动态随机存取内存（DRAM）** 组成的。</p><p>从逻辑上看，存储器是一个线性的字节数组，每个字节都有唯一的地址。</p></li><li><p><strong>处理器</strong></p><p>处理器是<strong>解释存储在主存中指令</strong>的引擎。</p><p>处理器的<strong>核心</strong>是一个<strong>程序计数器（PC)</strong></p><p>程序计数器是一个大小为<strong>一个字</strong>的存储设备，存储 CPU 即将执行的<strong>下一条指令的地址</strong>。</p><p>处理器就是在不断执行程序计数器指向的指令。每执行一条，程序计数器更新一次，指向下一条指令。</p><p>处理器会按照 ** 指令执行模型（指令集架构）** 解释指令中的位并执行相应操作。</p><p>每条指令的操作是围绕 ** 主存、寄存器文件、算数 / 逻辑单元（ALU）** 进行的。</p></li><li><p><strong>寄存器文件</strong>：单个字长，有唯一的名字。</p></li><li><p>**ALU：** 计算新的数据和地址值。</p></li><li><p>几个简单指令的操作：</p><ul><li><em>加载</em> *：从主存复制一个字或字节到寄存器，覆盖原来内容 **</li><li>存储 **：从寄存器复制一个字或字节到主存，覆盖原来内容 **</li><li>操作 **：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并把结果存到一个寄存器中 **</li><li>跳转 **：从指令中抽取一个字复制到程序计数器中，覆盖原来内容。</li></ul></li></ol><p>区分处理器指令集架构和微体系架构：</p><ul><li>** 指令集架构：** 每条机器指令的效果</li><li>** 微体系架构：** 处理器实际上是如何实现的</li></ul><h3 id="142-运行-hello-程序"><a class="anchor" href="#142-运行-hello-程序">#</a> <strong>1.4.2 运行 hello 程序</strong></h3><p>执行目标文件时，shell 程序将位于磁盘目标文件中的字符逐个读入寄存器，然后放到主存中。之后处理器就开始执行目标文件的机器语言指令，从 main 程序开始。</p><p>利用 ** 直接存储器存取（DMA）** 可以不通过寄存器，直接将数据从磁盘到达内存。</p><p>以输出打印 hello world 为例，处理器将 hello world 的字节复制到寄存器，然后再复制到显示器，最后显示在屏幕上。</p><p>** 整个流程：**<strong> 读取文件字符到寄存器 → 存储到主存  → 执行指令</strong>  →  <strong>加载 helloworld 到寄存器 → 复制到显示器 → 显示</strong></p><h2 id="15-高速缓存至关重要"><a class="anchor" href="#15-高速缓存至关重要">#</a> <strong>1.5 高速缓存至关重要</strong></h2><p>从主存读取一个字比磁盘快 <strong>1000 万</strong>倍。</p><p>从寄存器文件读取比主存块 <strong>100 倍</strong>，并且差距还在加大。</p><p>高速缓存（cache）用来解决处理器与主存间的差异。</p><p><strong>L1 高速缓存</strong>位于 <strong>CPU</strong> 上，容量为数万字节（<strong>几十 MB</strong>）。L1 比 L2 快 <strong>5</strong> 倍。</p><p><strong>L2 高速缓存</strong>通过<strong>一条特殊的总线</strong>与 CPU 连接，容量为数十万到数百万字节（<strong>几百 MB 到 几 GB</strong>）。L2 比 主存快 <strong>5~10</strong> 倍</p><p>新的系统还有 L3。</p><p>通过让高速缓存里存放可能经常访问的数据，让大部分的内存操作都在高速缓存中完成。</p><h2 id="16-存储设备形成层次结构"><a class="anchor" href="#16-存储设备形成层次结构">#</a> <strong>1.6 存储设备形成层次结构</strong></h2><p>存储器层次结构共 7 层，<strong>主要思想</strong>是上一层的存储器作为低一层的高速缓存。</p><p>从上到下，容量更大，运行更慢，每字节价格更便宜。</p><ul><li>0 层：寄存器</li><li>1 层：L1 高速缓存 (SRAM)</li><li>2 层：L2 高速缓存 (SRAM)</li><li>3 层：L3 高速缓存（SRAM）</li><li>4 层：主存（DRAM）</li><li>5 层：本地二级存储（本地磁盘）</li><li>6 层：远程二级存储（分布式文件系统，Web 服务器）</li></ul><h2 id="17-操作系统管理硬件"><a class="anchor" href="#17-操作系统管理硬件">#</a> <strong>1.7 操作系统管理硬件</strong></h2><p>操作系统的<strong>两个基本功能：</strong></p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂的低级硬件设备</li></ol><p>操作系统所应用的<strong>三个基本的抽象概念：</strong></p><ol><li><strong>进程</strong>：对处理器、主存和 I/O 设备的抽象表示</li><li><strong>虚拟内存</strong>：对主存和磁盘的抽象表示</li><li><strong>文件</strong>：对 I/O 设备的抽象表示</li></ol><h3 id="171-进程"><a class="anchor" href="#171-进程">#</a> <strong>1.7.1 进程</strong></h3><p>** 进程：** 对操作系统正在运行的程序的一种抽象。</p><p>** 并发运行：** 一个进程的指令和另一个进程的指令是交错执行的。</p><p>一个系统可以同时运行多个进程，实际上这些进程是并发运行的。</p><p>操作系统通过<strong>上下文切换</strong>来实现并发运行。上下文是跟踪进程运行所需的所有<strong>状态信息</strong>，可能存在于 PC、寄存器文件、主存等地方。</p><p><strong>任何时刻，单处理器只能执行一个进程的代码。</strong></p><p>操作系统<strong>内核</strong>是操作系统代码常驻主存的部分，从一个进程到另一个进程的转换是由内核管理的。</p><p>内核不是一个独立的进程，是一系列代码和数据结构的集合。</p><p>当应用程序需要操作系统的某些操作时，就把控制权传递给内核，内核执行完操作后返回应用程序。</p><h3 id="172-线程"><a class="anchor" href="#172-线程">#</a> <strong>1.7.2 线程</strong></h3><p><strong>一个进程由多个线程组成</strong>，每个线程都运行在进程的上下文中，共享同样的代码和全局数据。</p><p>多线程之间比多进程之间更容易共享数据，且线程一般来说比进程更高效。</p><h3 id="173-虚拟内存"><a class="anchor" href="#173-虚拟内存">#</a> <strong>1.7.3 虚拟内存</strong></h3><p>机器级程序将内存视为一个庞大的字节数组，称为<strong>虚拟内存</strong>。</p><p>内存的每个字节由地址来标识，所有可能地址的集合就是<strong>虚拟地址空间。</strong></p><p>虚拟内存使每个进程都以为自己独占了主存。每个进程看到的内存都是<strong>一致的</strong>，即<strong>虚拟地址空间</strong>。</p><p>在 linux 中，每个进程看到的虚拟地址空间由以下几个部分组成：</p><ol><li><strong>程序代码和数据</strong></li><li><strong>堆（运行时堆）</strong></li><li><strong>共享库</strong></li><li><strong>栈（用户栈）</strong></li><li><strong>内核虚拟内存</strong></li></ol><p>地址从低到高，最高层的<strong>内核虚拟内存</strong>保存的是操作系统中的代码和数据，这部分每个进程都一样。</p><p><em>程序代码和数据</em> *</p><p>对所有进程来说，代码都是从同一个固定地址开始，紧接着是与全局变量对应的数据区。代码和数据区都是按照可执行文件的内容初始化的。代码和数据区在进程开始运行时就被指定了大小。</p><p><strong>堆</strong></p><p>而运行时堆是根据 malloc 和 free 函数的调用在运行时<strong>动态地</strong>扩展和收缩的。</p><p><strong>共享库</strong></p><p>地址空间的中间部分用来存放共享库的代码和数据。如 C 标准库、数学库等都属于共享库</p><p><strong>栈</strong></p><p>用户栈和堆一样，在程序执行期间可以<strong>动态的扩展和收缩</strong>，编译器用它来<strong>实现函数调用</strong>。当调用函数时，栈增长，从函数返回时，栈收缩</p><h3 id="174-文件"><a class="anchor" href="#174-文件">#</a> <strong>1.7.4 文件</strong></h3><p>文件就是<strong>字节序列</strong>，仅此而已。</p><p>每个 I/O 设备，包括磁盘、键盘、显示器、网络，都可以看成是文件。</p><h2 id="18-系统之间利用网络通信"><a class="anchor" href="#18-系统之间利用网络通信">#</a> <strong>1.8 系统之间利用网络通信</strong></h2><p>从一个单独的系统而言，网络可以视为一个 I/O 设备。</p><p>以在一个远端服务器运行程序为例，在本地输入，在远端执行，执行结果发送回本地输出。</p><h2 id="19-重要主题"><a class="anchor" href="#19-重要主题">#</a> <strong>1.9 重要主题</strong></h2><h3 id="191-amdahl-定律"><a class="anchor" href="#191-amdahl-定律">#</a> <strong>1.9.1 Amdahl 定律</strong></h3><p>Amdahl 定律的主要观点：要加速整个系统，必须提升全系统中相当大的部分。</p><h3 id="192-并发和并行"><a class="anchor" href="#192-并发和并行">#</a> <strong>1.9.2 并发和并行</strong></h3><p>区分并发与并行：</p><ul><li>** 并发：** 一个通用的概念，指一个同时具有多个活动的系统</li><li>** 并行：** 用并发来使系统运行得更快</li></ul><p>并行可以在多个抽象层次上运用。从高到低有以下三个层次</p><p><strong>1. 线程级并行</strong></p><p>传统意义上的并发执行是通过单处理器在进程间快速切换<strong>模拟</strong>出来的。</p><p>多处理器系统由一个操作系统控制多个 CPU。结构如下</p><p>​    <img data-src="http://lgqimg.changzer.cn/image-20221005160155790.png" alt="image-20221005160155790" /></p><p>L1 高速缓存被分为两个部分：一个保存最近取到的指令，一个存放数据。</p><p><strong>超线程</strong>又称<strong>同时多线程</strong>，它允许一个 CPU 执行多个控制流。 CPU 有的硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件只有一份，比如浮点算术运算单元。常规 CPU 需要约 <strong>20000</strong> 个时钟周期来切换线程，超线程 CPU 可以在<strong>单个周期</strong>的基础上切换线程，比如一个线程在等待数据装在到高速缓存，CPU 就可以去执行另一个线程。</p><p>i7 处理器每个核执行两个线程，所以是 <strong>4 核 8 线程</strong>，8 个线程都并行执行。</p><p><strong>2. 指令级并行</strong></p><p>每条指令从开始到结束一般需要 20 个或更多的时钟周期，通过指令级并行，可以实现每个周期 2~4 条指令的执行速率。</p><p>如果比一个周期一条指令更快，就称为<strong>超标量处理器</strong>，现在一般都是超标量。</p><p><strong>3. 单指令、多数据并行</strong></p><p>在最低层次上，现代处理器允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行，即 SIMD 并行。</p><h3 id="193-计算机系统中抽象的重要性"><a class="anchor" href="#193-计算机系统中抽象的重要性">#</a> <strong>1.9.3 计算机系统中抽象的重要性</strong></h3><p>​    <img data-src="http://lgqimg.changzer.cn/image-20221005160217657.png" alt="image-20221005160217657" /></p><p><strong>指令集架构</strong>是对 CPU 硬件的抽象，使用这个抽象，CPU 看起来好像一次只执行机器代码程序的一条指令，实际上底层硬件并行地执行多条指令。</p><p><strong>虚拟机</strong>是对整个计算机系统的抽象，包括操作系统、处理器和程序。<strong>1.4.1 系统的硬件组成</strong></p><p>主要包括<strong>总线、I/O 设备、处理器、主存储器 **** 四个部分</strong></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入理解计算机系统 </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP:第二章</title>
      <link href="/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/"/>
      <url>/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="csapp第二章"><a class="anchor" href="#csapp第二章">#</a> CSAPP: 第二章</h1><h2 id="2-信息的表示和处理"><a class="anchor" href="#2-信息的表示和处理">#</a> <strong>2、信息的表示和处理</strong></h2><p>计算机使用二值信号存储和表示信息</p><p>当计算结果太大以至于不能表示时，就会产生<strong>溢出</strong>。</p><p>浮点数表示的精度有限，因而浮点运算是不可结合的。</p><p>整数的表示范围小但是精确，浮点数表示的范围大但是是近似的。</p><p>许多安全漏洞是由算术运算的微妙细节导致的。</p><h2 id="21-信息存储"><a class="anchor" href="#21-信息存储">#</a> <strong>2.1 信息存储</strong></h2><p>计算机一般使用字节作为最小的可寻址的内存单位。</p><p>在机器级程序中不包含关于数据类型的信息。</p><p>指针的值是某个存储块的第一个字节的<strong>虚拟地址</strong>。</p><p><strong>每个程序对象可以视为一个字节块。</strong></p><h3 id="211-十六进制表示法"><a class="anchor" href="#211-十六进制表示法">#</a> <strong>2.1.1 十六进制表示法</strong></h3><p>十六进制以 0x 开头。</p><p>A：10；C:12；F：15</p><h3 id="212-字数据大小"><a class="anchor" href="#212-字数据大小">#</a> <strong>2.1.2 字数据大小</strong></h3><p>每个计算机有对应的字长，虚拟地址用一个字来编码，所以<strong>字长决定了虚拟地址空间的大小</strong>。<strong>64 位机器的指针类型长度为 8 字节</strong></p><p>32 位机器的虚拟地址空间为 <strong>4GB</strong>，64 位字长的虚拟地址空间位 16 EB。</p><p><strong>int32_t</strong> 和 <strong>int64_t</strong> 类型分别为 4 字节和 8 字节，不受机器影响。使用确定大小的整数类型很有用。</p><p>对 32 位和 64 位机器而言，char、short、int、long long 长度都是一样的，为  1，2，4，8。long 的长度不一样。</p><p>float 和 double 的长度一样，分别为 4，8</p><p>程序对 char 有无符号一般不敏感。</p><h3 id="213-寻址和字节顺序"><a class="anchor" href="#213-寻址和字节顺序">#</a> <strong>2.1.3 寻址和字节顺序</strong></h3><p>对于跨越多字节的对象，它的地址是它所用字节中的<strong>最小地址</strong>。</p><p><strong>两种字节存储法：</strong></p><ul><li><strong>小端法</strong>：数字的低位在前（前就是最小地址）</li><li><strong>大端法</strong>：数字的高位在前</li></ul><p>大多数 Intel 都是小端法，不是所有。</p><h3 id="214-表示字符串"><a class="anchor" href="#214-表示字符串">#</a> <strong>2.1.4 表示字符串</strong></h3><p>C 语言字符串是以 null 字符结尾的字符数组，即 '\0'</p><p>ASCII 字符适合编码英文文档。</p><p>Unicode（UTF-8）使用 <strong>4 字节</strong>表示字符，一些常用的字符只需要 1 或 2 个字节。所有 ASCII 字符在 UTF-8 中是一样的。</p><p>JAVA 使用 UTF-8 来编码字符串。</p><h3 id="215-表示代码"><a class="anchor" href="#215-表示代码">#</a> <strong>2.1.5 表示代码</strong></h3><p>二进制代码是<strong>不兼容</strong>的，一般无法在不同机器间移植。</p><p>从机器的角度看，<strong>程序就是一个字节序列</strong>。</p><h3 id="216-布尔代数"><a class="anchor" href="#216-布尔代数">#</a> <strong>2.1.6 布尔代数</strong></h3><p><strong>布尔代数</strong>是在 0 和 1 基础上的定义</p><p>可以把字节看作是一个长为 8 的<strong>位向量</strong>。</p><p>位向量的一个应用是表示有限集合。如位向量 [0110 1001] 表示集合 A = {0,3,5,6}。</p><h3 id="217-c-语言中的位级运算"><a class="anchor" href="#217-c-语言中的位级运算">#</a> <strong>2.1.7 C 语言中的位级运算</strong></h3><p>位运算的常见应用是实现<strong>掩码</strong>。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8 位。</p><p>表达式 <strong>~0</strong> 可以生成一个全 1 的掩码，不管机器的字大小是多少。</p><h3 id="218-c-语言中的逻辑运算"><a class="anchor" href="#218-c-语言中的逻辑运算">#</a> <strong>2.1.8 C 语言中的逻辑运算</strong></h3><p>逻辑运算符 &amp;&amp; 和 || 如果第一个参数就能确定结果，就不再计算第二个参数</p><h3 id="219-c-语言中的移位运算"><a class="anchor" href="#219-c-语言中的移位运算">#</a> <strong>2.1.9 C 语言中的移位运算</strong></h3><p>左移 k 位丢掉最高的 k 位，并在右端补 k 个 0。</p><p>右移分为<strong>逻辑右移</strong>和<strong>算术右移</strong>。<strong>逻辑右移左端补 0，算术右移左端补最高有效位的值。</strong></p><p>一般都对有符号数使用算术右移，即补符号位的值。无符号数，<strong>只能是逻辑右移</strong>，即补 0</p><h2 id="22-整数表示"><a class="anchor" href="#22-整数表示">#</a> <strong>2.2 整数表示</strong></h2><p>无符号表示与补码表示</p><p>有符号数到无符号数的转换会产生漏洞，<strong>避免错误的方法之一是绝不使用无符号数</strong>。</p><p>除了 C 以外<strong>很少有语言支持无符号整数</strong>，Java 就只支持有符号数</p><h3 id="221-整数数据类型"><a class="anchor" href="#221-整数数据类型">#</a> <strong>2.2.1 整数数据类型</strong></h3><p>在 64 位系统上</p><ul><li>i<strong>nt</strong>：4 字节，可表示十进制数字位数：<strong>10 位（-20~20 亿以内）</strong></li><li><strong>long long</strong>：8 字节，可表示十进制数字位数：<strong>19 位（千亿亿级）</strong></li><li>long：8 字节</li><li><strong>double</strong>：8 字节，<strong>精度 15 位</strong>，可表示十进制数字位数<strong> 308 位</strong></li><li><strong>float</strong>：4 字节，<strong>精度 6 位</strong>，可表示十进制数字<strong> 38 位</strong></li><li><strong>char</strong>：<strong>-128~127</strong></li></ul><p>java 只支持有符号数。</p><h3 id="222-无符号数的编码"><a class="anchor" href="#222-无符号数的编码">#</a> <strong>2.2.2 无符号数的编码</strong></h3><p>无符号表示、补码表示与数据的映射都是双射，即一一对应。</p><h3 id="223-补码编码"><a class="anchor" href="#223-补码编码">#</a> <strong>2.2.3 补码编码</strong></h3><p>补码的定义实际就是<strong>将符号位解释为负权</strong>。</p><p>C 库头文件  定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、UINT_MAX</p><p>C 库头文件 中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数。</p><p><strong>### 2.2.4 有符号数和无符号数之间的转换</strong></p><p>在有符号数与无符号数之间进行强制类型转换的结果是<strong>保持位值不变，只改变解释位的方式。</strong></p><p><strong>补码 x 转无符号数</strong></p><ul><li>x &gt;= 0，值不变</li><li>x &lt; 0，转换后的值为 2^w + x</li></ul><p><strong>无符号数 x 转补码</strong></p><ul><li>x &lt;2^(w-1)，值不变</li><li>x &gt;= 2^(w-1)，转换后的值为 x - 2^w</li></ul><h3 id="225-c-语言中的有符号数和无符号数"><a class="anchor" href="#225-c-语言中的有符号数和无符号数">#</a> <strong>2.2.5 C 语言中的有符号数和无符号数</strong></h3><p>C 语言中有符号数和无符号数相加减，有符号被转换成无符号。</p><p><strong>### 2.2.6 扩展一个数字的位表示</strong></p><p>扩展无符号数使用零扩展，即在最高位前加 0</p><p>扩展有符号数使用符号扩展，即在最高位前加最高有效位的值</p><p><strong>### 2.2.7 截断数字</strong></p><p>对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。</p><p>对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。</p><h2 id="23-整数运算"><a class="anchor" href="#23-整数运算">#</a> <strong>2.3 整数运算</strong></h2><h3 id="231-无符号加法"><a class="anchor" href="#231-无符号加法">#</a> <strong>2.3.1 无符号加法</strong></h3><p>考虑溢出，C 语言不会将溢出作为错误发出信号</p><p>当 x+y &gt;= 2^w，实际结果为 s = x+y-2^w</p><p>对任意的 x+y，<strong>s = (x+y) % 2^w</strong></p><p>** 溢出的结果：** 和小于两个加数</p><p>** 检验溢出的方式：** 如果 <strong>s，说明溢出</strong></p><p><strong>无符号数的非</strong>：~x = 2^w - x (x&gt;0)</p><p><strong>### 2.3.2 补码加法</strong></p><p>当 x+y &gt;= 2^(w-1)， s = x+y-2^w</p><p>当 x+y &lt;-2^(w-1)，s = x+y+2^w</p><p><strong>正溢出的结果是负数，负溢出的结果是正数。</strong></p><p>** 检验溢出的方式：** 当 x,y&gt;0 而 s&lt;=0 是正溢出；当 x,y&lt;0 而 s&gt;=0 是负溢出</p><p><strong>### 2.3.3 补码的非</strong></p><p>当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x</p><p>** 补码非的位级表示：**<strong> 对每一位求补，结果再加 1</strong></p><p>** 计算补码非的第二种方法：** 假设 k 是最右边的 1 的位置，对 k 左边的所有位取反</p><p><strong>### 2.3.4 无符号乘法</strong></p><p><strong>无符号乘法的积</strong> <strong>m = (x*y) % 2^w</strong></p><h3 id="235-补码乘法"><a class="anchor" href="#235-补码乘法">#</a> <strong>2.3.5 补码乘法</strong></h3><p>可以认为补码乘法和无符号乘法的<strong>位级表示</strong>是一样的</p><p>C 语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释</p><p><strong>补码乘法的积</strong> <strong>m = (x*y) % 2^w</strong></p><p><strong>### 2.3.6 乘以常数</strong></p><p>大多数机器上，整数乘法需要 <strong>10 个或更多</strong>的时钟周期，而加法、减法、位级运算和移位只需要 1 个时钟周期</p><p><strong>编译器对整数乘法进行优化的方式</strong>：用<strong>移位和加法或减法</strong>运算的组合来代替常数因子的乘法。</p><p>左移 k 位等于乘以 2^k</p><p>如 x * 14  =  (x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)   =   (x&lt;&lt;4)-(x&lt;&lt;2)</p><p><strong>判断如何移动的方式</strong>很简单：14 的位级表示为 1110，所以分别左移 3，2，1</p><p><strong>### 2.3.7 除以 2 的幂</strong></p><p>大多数机器上，整数除法更慢，需要 <strong>30 个或更多</strong>的始终周期。</p><p>（只有）除以 2 的幂可以用移位运算来代替，<strong>无符号采用<strong><strong>逻辑右移</strong></strong>，补码采用 **** 算术右移</strong></p><p>对于有符号数而言，算术右移的结果相当于进行除法运算后<strong>向下舍入</strong></p><p>使用 <strong>(x+(1&lt;&gt;k</strong> 的结果相当于进行除法运算然后<strong>向零舍入</strong></p><p>代码实现</p><p>​                (x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k;</p><h3 id="238-关于整数运算的最后思考"><a class="anchor" href="#238-关于整数运算的最后思考">#</a> <strong>2.3.8 关于整数运算的最后思考</strong></h3><p><strong>补码使用了与无符号算术运算相同的位级实现</strong>，包括加法、减法、乘法甚至除法。都有完全一样或非常类似的位级行为。</p><h2 id="24-浮点数"><a class="anchor" href="#24-浮点数">#</a> <strong>2.4 浮点数</strong></h2><p>浮点数对于非常大，非常接近零，近似值计算都很有用</p><h3 id="241-二进制小数"><a class="anchor" href="#241-二进制小数">#</a> <strong>2.4.1 二进制小数</strong></h3><p>小数的二进制表示法只能表示那些能够写为 <strong>x * 2^w</strong> 的数，<strong>其他的数都是近似表示。x 必须可以由形如 2^i + 2^j + ... + 2^n 的多项式表示</strong></p><p>浮点运算的不精确性可能产生严重后果</p><p><strong>### 2.4.2 IEEE 浮点表示</strong></p><p><strong>IEEE 浮点标准</strong>的表示形式为：<strong>V = (-1)^S * M * 2^E</strong>，它分为三部分：</p><ol><li><strong>符号</strong>：<strong>S</strong> 决定是负数还是正数</li><li><strong>阶码</strong>：<strong>E</strong> 的作用是对浮点数加权</li><li><strong>尾数</strong>：<strong>M</strong> 是一个二进制小数，范围是 1~2-ε 或 0~1-ε</li></ol><p><strong>在对浮点数的位编码</strong>时：</p><ol><li>一个单独的符号位编码直接编码 S</li><li>k 位的<strong>阶码字段 e</strong> 编码 E；float 中 k=8，double 中 <strong>k=11</strong></li><li>n 位的<strong>小数字段 f</strong> 编码 M；float 中 n=23，double 中 <strong>n=52</strong></li></ol><p>E 和 M 的编码方式分为<strong>三种情况</strong>：</p><ol><li><p>** 规格化的值：** 阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）</p></li><li><ol><li>阶码字段解释方式：<strong>E = e - (2^(k-1)-1)</strong>；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127</li><li>小数字段解释方式：<strong>M = 1 + f</strong></li></ol></li><li><p><strong>非规格化的值</strong>：阶码字段全为 0 时属于非规格化形式</p></li><li><ol><li>阶码字段解释方式：<strong>E = 1 - (2^(k-1)-1)</strong>；<strong>与规格化值中 e = 1 时的 E 相同</strong></li><li>小数字段解释方式：<strong>M = f</strong></li></ol></li><li><p>** 特殊值：** 阶码字段全为 1 时，分两种情况：</p></li><li><ol><li><strong>小数字段全为 0：表示无穷</strong></li><li>** 小数字段非零：表示 NaN。** 比如 ∞-∞ 的结果就返回 NaN</li></ol></li></ol><h3 id="243-数字示例"><a class="anchor" href="#243-数字示例">#</a> <strong>2.4.3 数字示例</strong></h3><p>0 有 +0.0 和 -0.0 两种表示方式</p><p>最大非规格化数到最小规格化数的过渡是平滑的。</p><p>浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升序负数降序）。</p><p>浮点数可表示的数的分布是不均匀的，越接近零时越稠密</p><p><strong>几个特殊的值的位级表示：</strong></p><ol><li>+0.0 全为 0</li><li>** 最小的正非规格化值：** 最低有效位为 1，其他为 0</li><li>** 最大的非规格化值：** 小数字段全为 1，其他为 0</li><li>** 最小的正规格化值：** 阶码字段最低位为 1，其他为 0</li><li>** 最大的规格化值：** 阶码字段最低位为 0，符号位为 0，其他为 1</li></ol><h3 id="244-舍入"><a class="anchor" href="#244-舍入">#</a> <strong>2.4.4 舍入</strong></h3><p>因为范围和精度有限，浮点运算只能近似表示实数运算。</p><p>在浮点数的近似匹配上，IEEE 浮点格式定义了<strong>四种舍入方式（默认第一种）：</strong></p><ol><li><strong>向偶数舍入（向最接近的值舍入）</strong>：非中间值 (0.5) 四舍五入，中间值向偶数舍入。</li><li>向零舍入</li><li>向下舍入</li><li>向上舍入</li></ol><p>向偶数舍入可以计算一组数的平均数时避免统计偏差。</p><p>实际上这种舍入是发生在二进制小数上的。</p><h3 id="245-浮点运算"><a class="anchor" href="#245-浮点运算">#</a> <strong>2.4.5 浮点运算</strong></h3><p>IEEE 标准定义 1/-0 = -∞，1/+0 = +∞</p><p>浮点运算是<strong>可交换不可结合也不可分配</strong>的。</p><p>浮点加法满足<strong>加法和乘法上的单调性</strong>。如果 a&gt;=b，则 x+a &gt;= x+b</p><p>缺乏结合性和分配性会使一些简单问题变得很复杂</p><h3 id="246-c-语言中的浮点数"><a class="anchor" href="#246-c-语言中的浮点数">#</a> <strong>2.4.6 C 语言中的浮点数</strong></h3><p>在 int、float、double 间进行<strong>强制类型转换时的几种情况：</strong></p><ol><li>int 到 float：不会溢出，可能舍入</li><li>int 或 float 到 double：不会溢出也不会舍入</li><li>double 到 float：可能溢出和舍入</li><li>**float 或 double 到 int：** 向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，转变结果都为 [1000]，因此一个正浮点可能得到一个负整数</li></ol><p><strong>把大的浮点数转换为整数是一种常见的错误。</strong></p><p><strong>要小心地使用浮点运算。</strong></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入理解计算机系统 </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2022/10/04/Mysql/"/>
      <url>/2022/10/04/Mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql"><a class="anchor" href="#mysql">#</a> Mysql</h1><h2 id="1-sql语句"><a class="anchor" href="#1-sql语句">#</a> 1、Sql 语句</h2><h3 id="1-ddl数据定义语言用来定义数据库对象数据库-表-字段"><a class="anchor" href="#1-ddl数据定义语言用来定义数据库对象数据库-表-字段">#</a> (1) <strong>DDL—— 数据定义语言，用来定义数据库对象 (数据库、表、字段)</strong></h3><blockquote><ul><li>查询所有数据库</li></ul><pre><code class="language-SQL">show databases；</code></pre><ul><li>查询当前数据库</li></ul><pre><code class="language-SQL">select database();</code></pre><ul><li>创建数据库</li></ul><pre><code class="language-SQL">creat database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];--if not exists 表示若数据库存在，则不创建</code></pre><ul><li>删除数据库</li></ul><pre><code class="language-SQL">drop database[if exists]数据库名；--if exists 表示若数据库不存在，则不删除</code></pre><ul><li>使用数据库</li></ul><pre><code class="language-SQL">use 数据库名；</code></pre><ul><li>查询当前数据库所有表</li></ul><pre><code class="language-SQL">show tables；</code></pre><ul><li>查询表结构</li></ul><pre><code class="language-SQL">desc 表名；</code></pre><ul><li>查询指定表的建表语句</li></ul><pre><code class="language-SQL">show create table 表名；</code></pre><ul><li>表创建</li></ul><pre><code class="language-SQL">create table 表名(字段1 字段1类型[COMMENT 字段1注释],字段2 字段2类型[COMMEN+T 字段2注释],字段3 字段3类型[COMMENT 字段3注释],......字段n 字段n类型[COMMENT 字段n注释])[COMMENT 表注释];</code></pre><ul><li>添加表的字段</li></ul><pre><code class="language-SQL">alter table 表名 add 字段名 类型(长度)[COMMENT 注释][约束];</code></pre><ul><li>修改表的字段名和字段类型</li></ul><pre><code class="language-SQL">alter table 表名 change 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</code></pre><ul><li>修改字段的数据类型</li></ul><pre><code class="language-SQL">alter table 表名 modify 字段名 新数据类型;</code></pre><ul><li>修改表名</li></ul><pre><code class="language-SQL">alter table 表名 reanme to 新表名;</code></pre><ul><li>删除字段</li></ul><pre><code class="language-SQL">alter table 表名 drop 字段名;</code></pre><ul><li>删除表</li></ul><pre><code class="language-SQL">drop table[if exists] 表名;</code></pre><ul><li>删除指定表，并重新创建该表</li></ul><pre><code class="language-SQL">truncate table 表名;--删除表后，表中的数据也会删除</code></pre></blockquote><h3 id="2-dml数据操作语言用来对数据库表中的数据进行增删改"><a class="anchor" href="#2-dml数据操作语言用来对数据库表中的数据进行增删改">#</a> (2) <strong>DML—— 数据操作语言，用来对数据库表中的数据进行增删改</strong></h3><blockquote><ul><li>查询所有数据库</li></ul><pre><code class="language-SQL">show databases；</code></pre><ul><li>查询当前数据库</li></ul><pre><code class="language-SQL">select database();</code></pre><ul><li>创建数据库</li></ul><pre><code class="language-SQL">creat database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];--if not exists 表示若数据库存在，则不创建</code></pre><ul><li>删除数据库</li></ul><pre><code class="language-SQL">drop database[if exists]数据库名；--if exists 表示若数据库不存在，则不删除</code></pre><ul><li>使用数据库</li></ul><pre><code class="language-SQL">use 数据库名；</code></pre><ul><li>查询当前数据库所有表</li></ul><pre><code class="language-SQL">show tables；</code></pre><ul><li>查询表结构</li></ul><pre><code class="language-SQL">desc 表名；</code></pre><ul><li>查询指定表的建表语句</li></ul><pre><code class="language-SQL">show create table 表名；</code></pre><ul><li>表创建</li></ul><pre><code class="language-SQL">create table 表名(字段1 字段1类型[COMMENT 字段1注释],字段2 字段2类型[COMMENT 字段2注释],字段3 字段3类型[COMMENT 字段3注释],......字段n 字段n类型[COMMENT 字段n注释])[COMMENT 表注释];</code></pre><ul><li>添加表的字段</li></ul><pre><code class="language-SQL">alter table 表名 add 字段名 类型(长度)[COMMENT 注释][约束];</code></pre><ul><li>修改表的字段名和字段类型</li></ul><pre><code class="language-SQL">alter table 表名 change 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</code></pre><ul><li>修改字段的数据类型</li></ul><pre><code class="language-SQL">alter table 表名 modify 字段名 新数据类型;</code></pre><ul><li>修改表名</li></ul><pre><code class="language-SQL">alter table 表名 reanme to 新表名;</code></pre><ul><li>删除字段</li></ul><pre><code class="language-SQL">alter table 表名 drop 字段名;</code></pre><ul><li>删除表</li></ul><pre><code class="language-SQL">drop table[if exists] 表名;</code></pre><ul><li>删除指定表，并重新创建该表</li></ul><pre><code class="language-SQL">truncate table 表名;--删除表后，表中的数据也会删除</code></pre></blockquote><h3 id="3-dql数据查询语言用来查询数据库中的表的记录"><a class="anchor" href="#3-dql数据查询语言用来查询数据库中的表的记录">#</a> (3) <strong>DQL—— 数据查询语言，用来查询数据库中的表的记录</strong></h3><blockquote><ol><li>基本查询</li></ol><ul><li>查询多个字段</li></ul><pre><code class="language-SQL">select 字段1,字段2,字段3,... from 表名;select *from 表名;--查询整张表- 设置别名select 字段1[as 别名1],字段2[as 别名2],字段3[as 别名3],...from 表名;- 无处重复记录select distinct 字段列表 from 表名;</code></pre><ol><li>条件查询</li></ol><ul><li><p>语法</p><pre><code class="language-SQL">select 字段列表 from where 条件列表;</code></pre></li><li><p>条件</p><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226113100627.png" alt="image-20220226113100627" /></p></blockquote></li></ul><pre><code class="language-SQL">select 字段列表 from where 条件列表;</code></pre><ol><li>聚合函数</li></ol><ul><li><p>介绍</p><p>将一列数据作为一个整体，进行纵向计算。</p></li><li><p>常见聚合函数</p><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226112903488.png" alt="image-20220226112903488" /></p></blockquote></li><li><p>语法</p></li></ul><pre><code class="language-SQL">select 聚合函数(字段列表) from 表名;</code></pre><ol><li>分组查询</li></ol><ul><li>语法</li></ul><pre><code class="language-SQL">select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件]  - where和having区别      - 执行实际不同：where是分组之前进行过滤，不满条件where条件，不参与分组；having是分组之后对结果进行过滤。      - 判断条件不同：where不能对聚合函数进行判断，而having可以。</code></pre><ol><li>排序查询</li></ol><ul><li>语法</li></ul><pre><code class="language-SQL">select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方式2;</code></pre><ul><li>排序方式</li><li>ASC：升序 (默认值)</li><li>DESC：降序</li><li>如果是多字段排序，当第一个字段排序值相同时，才会根据第二个字段进行排序</li></ul><ol><li>分页查询</li></ol><ul><li>语法</li></ul><pre><code class="language-SQL">select 字段列表 from 表明 limit 起始索引,查询记录数;</code></pre><ul><li>注意</li><li>起始索引从 0 开始，起始索引 =(查询页码 - 1)* 咩野显示记录数。</li><li>分页茶树是数据库的方言，不同的数据库有不同的实现，Mysql 中是 LIMIT。</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为 [limit 查询记录数]。</li></ul><ol><li>语句执行顺序</li></ol><p><img data-src="http://lgqimg.changzer.cn/image-20220226130917300.png" alt="image-20220226130917300" /></p></blockquote><h3 id="4-dcl数据控制语言用来创建数据库用户-控制数据库的访问权限"><a class="anchor" href="#4-dcl数据控制语言用来创建数据库用户-控制数据库的访问权限">#</a> (4) <strong>DCL—— 数据控制语言，用来创建数据库用户、控制数据库的访问权限</strong></h3><blockquote><h3 id="1-管理用户"><a class="anchor" href="#1-管理用户">#</a> 1、管理用户</h3><ol><li>查询用户</li></ol><pre><code class="language-SQL">use mysql;select *from user;</code></pre><ol><li>创建用户</li></ol><pre><code class="language-SQL">create user '用户名'@'主机名' IDENTIFIED BY '密码'; </code></pre><ol><li>修改用户密码</li></ol><pre><code class="language-SQL">alter user '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';</code></pre><p>4. 删除用户</p><pre><code class="language-SQL">drop user '用户名'@'主机名';</code></pre><h2 id="2-权限管理"><a class="anchor" href="#2-权限管理">#</a> 2、权限管理</h2><p><img data-src="http://lgqimg.changzer.cn/image-20220226131018287.png" alt="image-20220226131018287" /></p><ol><li>查询权限</li></ol><pre><code class="language-SQL">show grants for '用户名'@'主机名';2. 授予权限grant 权限列表 on 数据库.表名 to '用户名'@'主机名'; 3. 撤销权限revoke 权限列表 on 数据库.表名 from '用户名'@'主机名';</code></pre><ul><li>多个权限之间，使用逗号分隔。</li><li>授权时，数据库名和表名可以使用 * 进行通配，代表所有。</li></ul></blockquote><h2 id="2-数据类型"><a class="anchor" href="#2-数据类型">#</a> 2、数据类型</h2><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226131551577.png" alt="image-20220226131551577" /></p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xncWltZy5jaGFuZ3plci5jbi9pbWFnZS0yMDIyMDIyNjEzMTY0MzM3OC5wbmc=">http://lgqimg.changzer.cn/image-20220226131643378.png</span>&quot; alt=&quot;image-20220226131643378&quot;  /&gt;</p><p><img data-src="http://lgqimg.changzer.cn/image-20220226131716446.png" alt="image-20220226131716446" /></p></blockquote><h2 id="3-函数"><a class="anchor" href="#3-函数">#</a> 3、函数</h2><blockquote><ul><li>语法</li></ul><pre><code class="language-SQL">select 函数(参数)；</code></pre><h3 id="1-字符串函数"><a class="anchor" href="#1-字符串函数">#</a> 1. 字符串函数</h3><p><img data-src="http://lgqimg.changzer.cn/image-20220226131918060.png" alt="image-20220226131918060" /></p><h3 id="2-数值函数"><a class="anchor" href="#2-数值函数">#</a> 2. 数值函数</h3><p><img data-src="http://lgqimg.changzer.cn/image-20220226131935009.png" alt="image-20220226131935009" /></p><h3 id="3-日期函数"><a class="anchor" href="#3-日期函数">#</a> 3. 日期函数</h3><p><img data-src="http://lgqimg.changzer.cn/image-20220226131952830.png" alt="image-20220226131952830" /></p><h3 id="4-流程函数"><a class="anchor" href="#4-流程函数">#</a> 4. 流程函数</h3><p><img data-src="http://lgqimg.changzer.cn/image-20220226132012231.png" alt="image-20220226132012231" /></p></blockquote><h2 id="4-约束"><a class="anchor" href="#4-约束">#</a> 4、约束</h2><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226132324447.png" alt="image-20220226132324447" /></p><ul><li>外键约束</li></ul><blockquote><ul><li>添加外键</li></ul><pre><code class="language-SQL">create table 表名(      字段名 数据类型,       ...       [constraint][外键名称] foreign key(外键字段名) references 主表(主表列名));alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);</code></pre><ul><li>删除外键</li></ul><pre><code class="language-SQL">alter table 表名 drop foreign key 外键名称;</code></pre><ul><li>删除 / 更新行为</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226132502323.png" alt="image-20220226132502323" /></p><ul><li>语法</li></ul><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">add</span> <span class="token keyword">constraint</span> 外键名称 <span class="token keyword">foreign</span><span class="token punctuation">(</span>外键字段<span class="token punctuation">)</span> <span class="token keyword">references</span> 主表名<span class="token punctuation">(</span>主表字段名<span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token keyword">update</span> 行为 <span class="token keyword">on</span> <span class="token keyword">delete</span> 行为<span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote></blockquote></blockquote></blockquote><h2 id="5-多表查询"><a class="anchor" href="#5-多表查询">#</a> 5、多表查询</h2><h3 id="51-多表关系"><a class="anchor" href="#51-多表关系">#</a> 5.1 多表关系</h3><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226132958716.png" alt="image-20220226132958716" /></p><ul><li>一对多 (多对一)</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226133130710.png" alt="image-20220226133130710" /></p></blockquote><ul><li>多对多</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226133149302.png" alt="image-20220226133149302" /></p></blockquote><ul><li>一对一</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226133214313.png" alt="image-20220226133214313" /></p></blockquote></blockquote><h3 id="52-多表查询概述"><a class="anchor" href="#52-多表查询概述">#</a> 5.2 多表查询概述</h3><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226133344586.png" alt="image-20220226133344586" /></p><ul><li>多表查询分类</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226133422287.png" alt="image-20220226133422287" /></p></blockquote></blockquote><h3 id="53内连接"><a class="anchor" href="#53内连接">#</a> 5.3 内连接</h3><blockquote><p>内连接查询的是两张表交集的部分</p><ul><li>隐式内连接</li></ul><pre><code class="language-SQL">select 字段列表 from 表1,表2 where 条件...;</code></pre><ul><li>显式内连接</li></ul><pre><code class="language-SQL">select 字段列表 from 表1[inner] join 表2 on 连接条件...; </code></pre></blockquote><h3 id="54-外连接"><a class="anchor" href="#54-外连接">#</a> 5.4 外连接、</h3><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226133657412.png" alt="image-20220226133657412" /></p><ul><li>左外连接</li></ul><pre><code class="language-SQL">select 字段列表 from 表1 left [outer] join 表2 on 条件...;</code></pre><ul><li>右外连接</li></ul><pre><code class="language-SQL">select 字段列表 from 表1 right [outer] join 表1 on 条件...;</code></pre></blockquote><h3 id="55-自连接"><a class="anchor" href="#55-自连接">#</a> 5.5 自连接、</h3><blockquote><ul><li>自连接查询法</li></ul><pre><code class="language-Sql">select 字段列表 from 表A 别名A join 表A 别名B on 条件...;</code></pre><ul><li>自连接查询，可以是内连接查询，也可以是外连接查询.</li></ul></blockquote><h3 id="56联合查询"><a class="anchor" href="#56联合查询">#</a> 5.6 联合查询</h3><blockquote><ul><li>对于 union 查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</li><li>语法</li></ul><pre><code class="language-SQL">select 字段列表 from 表Aunion [all]select 字段列表 from 表B;</code></pre><ul><li><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</strong></li><li><strong>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重</strong></li></ul></blockquote><h3 id="57-子查询"><a class="anchor" href="#57-子查询">#</a> 5.7 子查询</h3><blockquote><ul><li><p>概念 :SQL 语句中嵌套 select 语句，称为嵌套查询，又称子查询</p></li><li><p>语法</p></li></ul><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> column1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> column1 from2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li><strong>子查询外部的邮局可以是 insert/update/delete/select 的任何一个</strong></li></ul></blockquote><ul><li>分类</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226134245323.png" alt="image-20220226134245323" /></p></blockquote><ul><li>标量子查询</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226134338321.png" alt="image-20220226134338321" /></p></blockquote><ul><li>列子查询</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226134402934.png" alt="image-20220226134402934" /></p></blockquote><ul><li>行子查询</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226134418954.png" alt="image-20220226134418954" /></p></blockquote><ul><li>表子查询</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226134437994.png" alt="image-20220226134437994" /></p></blockquote></blockquote><h2 id="6-事务"><a class="anchor" href="#6-事务">#</a> 6、事务</h2><blockquote><ul><li>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销请求，即这些操作要么同时成功，要么同时失败。</li></ul><ul><li><p>事务操作</p></li><li><p>查看 / 设置事务提交方式</p><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> @<span class="token variable">@autocomit</span><span class="token punctuation">;</span><span class="token comment">-- 查看事务提交方式，1 为自动提交，0 为手动提交</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">set</span> @<span class="token variable">@sutiocomit</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">-- 设置提交方式，0 为手动提交</span></pre></td></tr></table></figure></blockquote></li><li><p>提交事务</p><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">commit</span><span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote></li><li><p>回滚事务</p><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">rollback</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>开启事务</li></ul><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">start</span> <span class="token keyword">transaction</span> 或 <span class="token keyword">begin</span><span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote></blockquote></li></ul><ul><li>事务的四大特性</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226135459363.png" alt="image-20220226135459363" /></p></blockquote><ul><li>并发事务问题</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226135518825.png" alt="image-20220226135518825" /></p></blockquote><ul><li>事务隔离级别</li></ul><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220226135534240.png" alt="image-20220226135534240" /></p><ul><li><p>查看事务隔离级别</p><blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote></li><li><p>设置事务隔离级别</p><blockquote><pre><code class="language-SQL">set [session|global] transaction isolation level &#123;read uncommitted|read committed|repeatable read|serializable&#125;;--session表示会话级别，表示当前客户端窗口有效--session global 表示所有客户端窗口有效</code></pre></blockquote></li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机语言学习 </category>
          
          <category> SQL语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法和数据结构</title>
      <link href="/2022/10/03/%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/03/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a class="anchor" href="#算法">#</a> 算法</h1><h2 id="一-排序升序"><a class="anchor" href="#一-排序升序">#</a> 一、排序（升序）</h2><ol><li>选择排序</li></ol><ul><li><p>寻找数组中最小的元素，将起与数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此，知道整个数组排完序。</p></li><li><p>对于长度为 N 的数组，选择排序需要打约<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span> 次比较和 N 次交换</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void selection_sort(T *array)&#123;    if(array.size()&lt;=1)        return;    else    &#123;          for(int i=0;i&lt;array.size();i++)      &#123;        int min=i;        for(int j=i+1;j&lt;array.size();j++)        &#123;            if(array[min]&gt;=array[j])            &#123;                min=j;            &#125;        &#125;        swap(array[min],array[j]);     &#125;    &#125;&#125;</code></pre></li></ul><ol start="2"><li>插入排序</li></ol><ul><li><p>在数组中，将数组元素插入到有序的数组元素之中，在插入之前，其余元素向右移一位</p></li><li><p>对于随机排列的长度为 N 的且主键不重复的数组，平均情况下插入排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span></span></span></span> 次比较以及～<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span></span></span></span> 次交换。最坏的情况下需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span> 次比较和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span> 交换，最好情况下需要 N-1 次比较和 0 次交换。</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void insertion_sort(T *array)&#123;    if(array.size()&lt;=1)        return;    else    &#123;        for(int i=0;i&lt;array.size();i++)        &#123;            for(int j=i;j&gt;0&amp;&amp;array[j]&lt;=array[j-1];j--)            &#123;                swap(array[j],array[j-1]);            &#125;        &#125;    &#125;&#125;</code></pre></li></ul><ol start="3"><li>希尔排序</li></ol><ul><li><p>将数组分为几个间隔为 h 的元素子数组，用插入排序为每个子数组进行排序，之后队 h 进行减少，再对分好的子数组进行插入排序，直到 h=1；</p></li><li><p>使用递增序列 1，4，13，40，121，364，…… 的希尔排序所需要的比较次数不会超出 N 的若干倍乘以递增序列的长度</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void shell_sort(T *array)&#123;    int N=array.size();    int h=1;    if(n&lt;=1)        return;    else    &#123;         while(h&lt;N/3) h=3*h+1；         while(h&gt;=1)         &#123;             for(int i=h;i&lt;N;i++)             &#123;                 for(int j=i;j&gt;=h&amp;&amp;array[j]&lt;=array[j-h];j-=h)                 &#123;                     swap(array[j],array[j-h]);                 &#125;             &#125;             h/=3;         &#125;    &#125;&#125;</code></pre></li></ul><ol start="4"><li>归并排序</li></ol><ul><li>将一个数组，递归地分成两半数组并排序，然后将结果归并起来。</li></ul><p>​ (1) 原地归并的抽象方法</p><ul><li><p>创建一个大小适当的数组，将两个数组的元素分别有序地放入这个数组中</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void merge(T *array)&#123;    int l=0;    int h=array.size()-1;    int mid=array.size()/2;    T auk[h-l+1];    for(int k=l;k&lt;=h;k++)    &#123;        auk[k]=array[k];    &#125;    int i=l;    int j=mid;    for(int k=l;k&lt;=h;k++)    &#123;        if(i&gt;mid)        &#123;            array[k]=auk[j++];        &#125;        else if(j&gt;h)        &#123;            array[k]=auk[i++];        &#125;        else if(auk[j]&lt;=auk[i])        &#123;            array[k]=auk[j++];        &#125;        else        &#123;            array[k]=auk[i++];        &#125;    &#125;&#125;</code></pre></li></ul><p>​ (2) 自顶向下的归并排序</p><ul><li><p>对于长度为 N 的任意数组，自定向下的归并方法需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1/2NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次比较，最多访问数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void merge_sort(T *array)&#123;    if(array.size()&lt;=1) return;    else    &#123;        int l=0;        int h=array.size()-1;        int mid=array.size()/2;        array.sort(l,mid);        ayrry.sort(mid+1,h);        merge(array);    &#125;&#125;</code></pre></li></ul><p>​ (3) 自底向上的归并排序</p><ul><li><p>将数组分递归分为两半数组，然后再对数组两两归并，四四归并，八八归并，一直下去。</p></li><li><p>对于长度为 N 的任意数组，自底向上的归并排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1/2NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次比较，最多访问数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void mergerBU(T *array,int len)&#123;    T *a = array;    T *b = new T[len];    for (int seg = 1; seg &lt; len; seg += seg) &#123;        for (int start = 0; start &lt; len; start += seg + seg) &#123;            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        T *temp = a;        a = b;        b = temp;    &#125;    if (a != arr) &#123;        for (int i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    &#125;    delete[] b;&#125;</code></pre></li></ul><ol start="5"><li>快速排序</li></ol><ul><li><p>寻找一个分界点 K，将分界点移动到恰当位置，将数组分为两个部分，左边部分全部小于 K，右边部分全部大于 K。对两部分的数组元素进行再进行分界，直到数组排序完成。</p></li><li><p>长度为 N 的无重复数组排序，快速排序平均需要～<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2NlnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次比较 (以及 1/6 的交换)。</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void quick_sort(T *arr, T l, T r)&#123;    if(l&lt;r)    &#123;         int i=0;         int j=arr.size()-1;        while(i&lt;j)        &#123;            while(j&gt;i&amp;&amp;arr[j]&gt;=l)            &#123;                j--;            &#125;            while(i&lt;j&amp;&amp;arr[i]&lt;l)            &#123;                i--;            &#125;            if(j&gt;i)            &#123;                T temp=arr[j];                arr[j]=arr[i];                arr[j]=temp;            &#125;        &#125;        arr[0]=arr[i];        arr[i]=l;        quick_sort(arr,l,i-1);        quick_sort(arr,i+1,r);    &#125;&#125;</code></pre></li></ul><ol start="6"><li>冒泡排序</li></ol><ul><li><p>对每一对相邻的元素进行比较，较大的元素往后移动，小的元素往前移动，做完一步，最后的元素是最大的数，重复操作，直到排序完成</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void bubble_sort(T *arr)&#123;    for(int i=0;i&lt;arr.szie();i++)    &#123;        for(int j=0;i&lt;arr.szie()-1-i;j++)        &#123;            if(arr[j]&gt;arr[j+1])            &#123;                swap(arr[j],arr[j+1]);            &#125;        &#125;    &#125;&#125;</code></pre><p>优化版本</p><pre><code class="language-C++">template &lt;typename T&gt;void bubble_sort(T *arr)&#123;    int len=arr.size();    bool flag=false;    for(int i=0;i&lt;len-1;i++)    &#123;        for(int j=0;j&lt;len-1-i;j++)        &#123;            if(arr[j]&gt;arr[j+1])            &#123;                swap(arr[j],arr[j+1])                flag=true;            &#125;        &#125;        if(!flag) &#123;break;&#125;    &#125;&#125;</code></pre></li></ul><ol start="7"><li>计数排序</li></ol><ul><li><p>计数排序一般是基于对整数进行排序，且范围在 (0,k) 之间</p></li><li><p>计数排序通过对数组中的元素进行计数，并且创建辅助数组按元素顺序大小存储元素的个数，随后将辅助数组的元素序号和元素大小反向填充目标数组。</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;int* countSort(int* arr,int len)&#123;int max = arr[0];//记录数列的最大值int min = arr[0];//记录数列的最小值for(int i=0;i&lt;len-1;i++)&#123;if(arr[i]&gt;max)&#123;max = arr[i];&#125;if(arr[i]&lt;min)&#123;min = arr[i];&#125;&#125;int l = max-min;//计算出数列最大最小值得差值int* couarr = new int[l+1];for(int i=0;i&lt;len;i++)&#123;couarr[arr[i]-min]++;//统计元素个数&#125;int sum = 0;for(int i=0;i&lt;l+1;i++)//统计数组做变形，后面的元素等于前面元素的和&#123;sum += couarr[i];couarr[i]=sum;&#125;int* sortarr = new int[len];for(int i=len-1;i&gt;=0;i--)//倒序遍历原始数组，从统计数组中找到正确位置&#123;sortarr[couarr[arr[i]-min]-1]=arr[i];couarr[arr[i]-min]--;&#125;delete couarr;return sortarr;&#125;</code></pre></li></ul><ol start="8"><li>堆排序</li></ol><ul><li><p>堆</p><ul><li><p>堆是一棵完全二叉树</p></li><li><p>堆中的每一个父节点要大于其每一个子节点</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void heapify(T * arr,int n,int i) //对于父节点为i的堆的修复&#123;     if(i&gt;=n) &#123;return;&#125;    int lchild=2*i+1;    int rchild=2*i+2;    int max=i;    if(lchild&gt;n&amp;&amp;arr[lchild]&gt;arr[max])    &#123;        max=lchild;    &#125;     if(rchild&gt;n&amp;&amp;arr[rchild]&gt;arr[max])    &#123;        max=rchild;    &#125;    if(max!=i)    &#123;        swap(arr[max],arr[i]);        heapify(arr,n,max);    &#125;&#125;template &lt;typename T&gt;void build_heap(T *arr,n)&#123;    int last_node=n-1;    int parent=(last_node-1)/2;    foe(int i=parent;i&gt;=0;i--)    &#123;        hapify(arr,n,i);    &#125;&#125;</code></pre></li></ul></li><li><p>将堆中的最后一个节点与根节点进行交换，将最后一个节点取出，再将二叉树中复原成堆，将堆中的最后一个节点与根节点进行交换，将最后一个节点取出，再复原堆，继续执行，直到二叉树中的节点全部取出。</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void heap_sort(T * arr,n)&#123;    build_heap(arr,n);    for(int i=n-1;i&gt;=0;i--)    &#123;        swap(arr[i],arr[0]);        heapify(arr,i,0);    &#125;&#125;</code></pre></li></ul><ol start="9"><li>桶排序</li></ol><ul><li><p>设置一个定量的数组当作空桶子，寻访序列，并且把项目一个一个放到对应的桶子去。对每个不是空的桶子进行排序，从不是空的桶子里把项目再放回原来的序列中。</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;void bksort(T A[],int l,int h)&#123;    int size = h-l+1;    vector&lt;T&gt; b[size];//有size个数据，就分配size个桶    for(int i=l;i&lt;=h;i++)&#123;        int bi = size*A[i];//元素A[i]的桶编号        b[bi].push_back(A[i]);//将元素A[i]压入桶中    &#125;    for(int i=0;i&lt;size;i++)        sort(b[i].begin(),b[i].end());//桶内排序    int idx = l;//指向数组A的下标    for(int i=0;i&lt;size;i++)&#123;//遍历桶        for(int j=0;j&lt;b[i].size();j++)&#123;//遍历桶内元素            A[idx++] = b[i][j];        &#125;    &#125;&#125;</code></pre></li></ul><ol start="10"><li>基数排序</li></ol><ul><li><p>对待排序的数字先按个位数排序，再按十位数排序，以此来推，直到待排序的数字每一位数都能进行排序。</p></li><li><p>代码</p><pre><code class="language-C++">template &lt;typename T&gt;int maxbit(T *arr,int n)&#123;    int maxData=data[0];    for(int i=1;i&lt;n;i++)    &#123;        if(arr[i]&gt;maxData)        &#123;            maxData=arr[i];        &#125;    &#125;    int d=1;int p=10;    while(maxData&gt;=p)    &#123;         maxData /= 10;        ++d;    &#125;    return d;&#125;template &lt;typename T&gt;void radix_sortT *arr, int n)&#123;    int d=maxbit(arr,n);    int *tmp=new int[n];    int *count=new int[10];    int i,j,k;    int radix=1;    for(i=1;i&lt;=d;i++)    &#123;        for(j=0;j&lt;10;j++)        &#123;            count[j]=0;        &#125;        for(j=0;j&lt;n;j++)        &#123;            k=(arr[j]/radix)%10;            count[k]++;        &#125;        for(j=1;j&lt;10;j++)        &#123;            count[j]=count[j-1]+count[j];        &#125;        for(j=n-1;j&gt;=0;j--)        &#123;             k=(arr[j]/radix)%10;            tmp[count[k]-1]=arr[j];            count[k]--;        &#125;        for(j=0;j&lt;n;j++)        &#123;            arr[j]=tmp[j];        &#125;        radix=radix*10;    &#125;    delete []tmp;    delete []count;&#125;</code></pre></li></ul><h2 id="二-贪心算法"><a class="anchor" href="#二-贪心算法">#</a> 二、贪心算法</h2><ol><li>思想</li></ol><ul><li>贪心算法总是做出在当前看来得最好选择，可以说，贪心算法并不从整体考虑最优，而是在某种意义上得局部最优选择。从而贪心算法得最终结果也是整体最优的。即使贪心算法不能得到整体最优解，其结果也是最优解的很好近似。</li></ul><ol start="2"><li>基本要素</li></ol><ul><li>贪心选择性质：贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。是贪心算法可行性的第一个基本要素，也是贪心与动态规划的主要区别。</li><li>当一个问题的最优解包含其子问题的最优解是，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划或是贪心算法求解的关键特征</li></ul><ol start="3"><li>基本思路</li></ol><ul><li><p>从问题的某一初始解逐步逼近给定目标，以尽可能快地求得更好地解 / 当到达算法中地某一步不能继续前进时，算法停止</p></li><li><p>算法存在问题：</p><ol><li>不能保证求得地最后解时最佳地</li><li>不能用来求最大或是最小解问题</li><li>只能求某些约束条件地可行解地 范围</li></ol></li><li><p>算法地实现过程：<br />while 能朝给定目标前进一步 do<br /> 求出可行解地一个解元素；<br />由所有解元素组合成问题地一个可行解</p></li><li><p>用背包问题来介绍贪心算法：</p><p>背包问题：有一个背包，背包容量是 M=150。有 7 个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p><p>​ 物品 A B C D E F G</p><p>​ 重量 35 30 60 50 40 10 25</p><p>​ 价值 10 40 30 50 35 40 30</p><p>分析如下</p><p>​ 目标函数： ∑pi 最大</p><p>约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M ( M=150)。</p><p>​ （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p><p>​ （2）每次挑选所占重量最小的物品装入是否能得到最优解？</p><p>​ （3）每次选取单位重量价值最大的物品，成为解本题的策略。</p><p>​ 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p><p>​ 贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p><p>​ 可惜的是，它需要证明后才能真正运用到题目的算法中。</p><p>​ 一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</p><p>​ 对于背包问题中的 3 种贪心策略，都是无法成立（无法被证明）的，解释如下：</p><p>​ 贪心策略：选取价值最大者。反例：</p><p>​ W=30</p><p>​ 物品：A B C</p><p>​ 重量：28 12 12</p><p>​ 价值：30 20 20</p><p>根据策略，首先选取物品 A，接下来就无法再选取了，可是，选取 B、C 则更好。</p><p>（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</p><p>（3）贪心策略：选取单位重量价值最大的物品。反例：</p><p>​ W=30</p><p>​ 物品：A B C</p><p>​ 重量：28 20 10</p><p>​ 价值：28 20 10</p><p>​ 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择 A，则答案错误。但是果在条件中加一句当遇见单位价值相同的时候，优先装重量小的，这样的问题就可以解决.</p><p>​ 贪心算法可以与随机化算法一起使用，具体的例子就不再多举了。（因为这一类算法普及性不高，而且技术含量是非常高的，需要通过一些反例确定随机的对象是什么，随机程度如何，但也是不能保证完全正确，只能是极大的几率正确）。</p><p>假设条件是什么？假设条件是上述几种反例的情况不存在的时候该如何求解:</p><pre><code class="language-c++">#include &lt;iostream&gt;using namespace std;struct Node&#123;float weight;float value;bool mark;char char_mark;float pre_weight_value;&#125;;int main(int argc, char* argv[])&#123;float Weight[7] = &#123;35,30,60,50,40,15,20&#125;;float Value [7] = &#123;10,40,30,50,35,40,30&#125;;Node array[7];for(int i=0; i&lt;7; i++)&#123;array[i].value = Value[i];array[i].weight = Weight[i];array[i].char_mark = 65 + i;array[i].mark = false;array[i].pre_weight_value = Value[i] / Weight[i];&#125;for(i=0;i&lt;7;i++)cout&lt;&lt;array[i].pre_weight_value&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;float weight_all=0.0;float value_all = 0.0;float max = 0.0;char charArray[7];int flag,n = 0;while(weight_all &lt;= 150)&#123;for(int index=0;index &lt; 7; ++index)&#123;if(array[index].pre_weight_value &gt; max &amp;&amp; array[index].mark == false)&#123;max = array[index].pre_weight_value ;flag = index;&#125;&#125;charArray[n++] = array[flag].char_mark;array[flag].mark = true;weight_all += array[flag].weight;value_all += array[flag].value;max = 0.0;&#125;for(i=0;i&lt;n-1;i++)cout&lt;&lt;charArray[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;cout&lt;&lt;&quot;weight_all:&quot;&lt;&lt;weight_all- array[n-1].weight&lt;&lt;endl;cout&lt;&lt;&quot;value_all:&quot;&lt;&lt;value_all&lt;&lt;endl;system(&quot;pause&quot;);return 0;&#125;</code></pre></li></ul><h2 id="三-动态规划"><a class="anchor" href="#三-动态规划">#</a> 三 、动态规划</h2><ol><li>思想</li></ol><ul><li>动态规划是通过拆分问题、定义问题状态与状态之间的关系，使得问题能够以递推 (或是分治) 的方法去解决。</li><li>动态规划规划算法的思想与分治算法的思想有些相似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</li></ul><ol start="2"><li>适用情况</li></ol><ul><li><p>能采用动态规划求解的问题的一般要具有 3 个性质：</p><ol><li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li><li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li><li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p></li></ol></li></ul><ol start="3"><li>求解步骤</li></ol><ul><li><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线 (通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如下图所示：</p><p>初始状态 →│ 决策 1│→│ 决策 2│→…→│ 决策 n│→ 结束状态</p></li><li><p>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p></li><li><p>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计：</p><ol><li>分析最优解的性质，并刻画其结构特征。</li><li>递归的定义最优解。</li><li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</li><li>根据计算最优值时得到的信息，构造问题的最优解</li></ol></li></ul><ol start="4"><li>实现步骤</li></ol><ul><li><p>动态规划的主要难点在于理论上的设计，也就是上面 4 个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段</p><p>（2）每个阶段的状态</p><p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p></li><li><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p></li><li><p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从 1 行 1 列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p></li><li f(n-1,m),="" f(n-1,m-w[n])+P(n,m)=""><p>f(n,m)=max</p><pre><code class="language-c++">for(j=1; j&lt;=m; j=j+1) // 第一个阶段   xn[j] = 初始值; for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段   for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式     xi[j]=j=max（或min）&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）&#123;     t = t-xi-1[ji];     for(j=1; j&gt;=f(i); j=j+1)        if(t=xi[ji])             break;&#125;</code></pre></li><li><p>自顶向下版本<br />按照自然递归的形式编写代码，过程中会保存每个子问题的解。当需要某个子问题的解时，过程会首先检查是否保存过此解。如果是，则直接返回保存的值。</p></li><li><p>自底向上版本</p><p>将子问题按照规模大小从小到大排序，进行求解。当求解某个问题时，它所依赖的子问题都已经得到求解，结果已经保存。每个子问题都只用求解一遍。</p></li></ul><h2 id="四-双指针"><a class="anchor" href="#四-双指针">#</a> 四、双指针</h2><ol><li>思想</li></ol><ul><li>双指针即用两个不同速度或不同方向的指针对<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTYlOTUlQjAlRTclQkIlODQmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">数组</span>或对象进行访问，通过两个不同指针的碰撞从而达到特定的目的。</li></ul><ol start="2"><li>快慢指针</li></ol><p>​ (1) 思想</p><ul><li>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为 <code>快指针（fast）</code> 和 <code>慢指针（slow）</code> ，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。</li></ul><p>​ (2) 用法</p><ul><li>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。<ol><li>判定链表中是否含有环</li><li>已知链表中含有环，返回这个环的起始位置</li><li>寻找链表的中点</li><li>寻找链表的倒数第 k 个元素</li></ol></li></ul><p>​ (3) 示例</p><ul><li><p>判定链表中是否含有环</p><ul><li><p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。</p><p>如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环</p><pre><code class="language-c++">bool hasCycle(ListNode *head) &#123;    while (head != null)        head = head-&gt;next;    return false;&#125;</code></pre><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。</p><p>经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会和慢指针相遇，说明链表含有环。</p></li></ul></li><li><p>已知链表中含有环，返回这个环的起始位置</p><ul><li><p><img data-src="http://lgqimg.changzer.cn/1566782-20190626075016458-1495003044.jpg" alt="img" /></p><p>代码：</p><pre><code class="language-c++">ListNode*  detectCycle(ListNode *head)&#123;    ListNode* fast, *slow;    fast = slow = head;    while (fast != null &amp;&amp; fast-&gt;next != null)    &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow)            break;    &#125;    slow = head;    while (slow != fast)    &#123;        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    return slow;&#125;</code></pre><p>当快慢指针相遇时，让其中任一个指针重新指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p></li></ul></li><li><p>寻找链表的中点</p><ul><li><p>我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><pre><code class="language-c++">ListNode* slow, *fast;slow = fast = head;while (fast != null &amp;&amp; fast.next != null) &#123;    fast = fast-&gt;next-&gt;next;    slow = slow-&gt;next;&#125;// slow 就在中间位置return slow;</code></pre><p>当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：</p><p><img data-src="http://lgqimg.changzer.cn/1566782-20190626075146010-1979098095.jpg" alt="img" /></p><p>寻找链表中点的一个重要作用是对链表进行归并排序。</p><p>回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p></li></ul></li><li><p>寻找链表的倒数第 k 个元素</p><ul><li><p>快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：</p><pre><code class="language-c++">ListNode *slow, *fast;slow = fast = head;while (k-- &gt; 0)    fast = fast-&gt;next;while (fast != null) &#123;    slow = slow-&gt;next;    fast = fast-&gt;next;&#125;return slow;</code></pre></li></ul></li></ul><ol start="3"><li><p>对撞指针</p><p>(1) 思想</p></li></ol><ul><li><p>对撞指针是指在数组中，将指向最左侧的索引定义为 <code>左指针(left)</code> ，最右侧的定义为 <code>右指针(right)</code> ，然后从两头向中间进行数组遍历。</p><p>(2) 用法</p></li><li><p>对撞数组适用于连续数组和字符串，也就是说当遇到题目给定连续数组和字符床时，应该第一时间想到用对撞指针解题</p></li><li><p>代码</p><pre><code class="language-C++">void find (int list[]) &#123;  auto left = 0;   auto right = list.length() - 1;  //遍历数组  while (left &lt;= right) &#123;    left++;    // 一些条件判断 和处理    ... ...    right--;  &#125;&#125;</code></pre></li></ul><ol start="4"><li>滑动窗口</li></ol><p>​ (1) 思想</p><ul><li>滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。</li><li>就是有一个大小可变的窗口，左右两端方向一致的向前滑动（右端固定，左端滑动；左端固定，右端滑动）</li></ul><p>​ (2) 用法</p><ol><li>一般是字符串或者列表</li><li>一般是要求最值（最大长度，最短长度等等）或者子序列</li></ol><p>​ (3) 实现</p><ol><li>在序列中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个窗口。</li><li>先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的序列符合要求。</li><li>此时，停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的序列不再符合要求。同时，每次增加 left 前，都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达序列的尽头。</li></ol><h2 id="五-数组"><a class="anchor" href="#五-数组">#</a> 五、数组</h2><ol><li><p>** 数组是存放在连续内存空间上的相同类型数据的集合。** 数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p></li><li><p>举一个字符数组的例子，如图所示：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" alt="算法通关数组" /></p><p>需要两点注意的是</p><ul><li><strong>数组下标都是从 0 开始的。</strong></li><li><strong>数组内存空间的地址是连续的</strong></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。</strong></p></li><li><p>二维数组在 C++ 中在地址空间上是连续的。在 Java 中数值也是 16 进制，这不是真正的地址，而是经过处理过后的数值了，每一行头结点的地址是没有规则的，更谈不上连续。</p></li></ol><h2 id="六-链表"><a class="anchor" href="#六-链表">#</a> 六、链表</h2><ol><li><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是 head。</p></li><li><p>类型</p><ul><li>单链表：<img data-src="http://lgqimg.changzer.cn/20200806194529815.png" alt="链表1" /></li><li>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表 既可以向前查询也可以向后查询。<br /><img data-src="http://lgqimg.changzer.cn/20200806194559317.png" alt="链表2" /></li><li>循环链表：循环链表，顾名思义，就是链表首尾相连。循环链表可以用来解决约瑟夫环问题。</li></ul></li><li><p>链表存储方式</p><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>如图所示：</p><p><img data-src="http://lgqimg.changzer.cn/20200806194613920.png" alt="链表3" /></p><p>这个链表起始节点为 2， 终止节点为 7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p></li><li><p>链表的定义<br /> C/C++ 的定义链表节点方式，如下所示：</p><pre><code class="language-C++">//单链表struct ListNode&#123;    int val;  //节点上存储的元素    ListNode *next;  //指向下一个节点的指针    ListNode(int x) : val(x), next(NULL)&#123;&#125;  //节点的构造函数&#125;;</code></pre></li><li><p>链表的操作</p><ul><li>删除节点：<img data-src="http://lgqimg.changzer.cn/20200806195114541.png" alt="链表-删除节点" /></li><li>添加节点<br /><img data-src="http://lgqimg.changzer.cn/20200806195134331.png" alt="链表-添加节点" /></li></ul></li><li><p>性能对比<br /><img data-src="http://lgqimg.changzer.cn/20200806195200276.png" alt="链表-链表与数据性能对比" /></p><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p></li></ol><h2 id="七-哈希表"><a class="anchor" href="#七-哈希表">#</a> 七、哈希表</h2><ol><li><p>哈希表是根据关键码的值而直接进行访问的数据结构。<br />哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：<br /><img data-src="http://lgqimg.changzer.cn/20210104234805168.png" alt="哈希表1" /><br /><strong> 哈希表一般都是用来快速判断一个元素是否出现集合里。</strong></p></li><li><p>哈希函数<br />哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过 hashCode 把名字转化为数值，一般 hashcode 是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img data-src="http://lgqimg.changzer.cn/2021010423484818.png" alt="哈希表2" /></p><p>如果 hashCode 得到的数值大于 哈希表的大小了，也就是大于 tableSize 了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p></li><li><p>哈希碰撞如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p><img data-src="http://lgqimg.changzer.cn/2021010423494884.png" alt="哈希表3" /></p><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><ul><li><p>拉链法</p><p>刚刚小李和小王在索引 1 的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img data-src="http://lgqimg.changzer.cn/20210104235015226.png" alt="哈希表4" /></p><p>（数据规模是 dataSize， 哈希表的大小为 tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p></li><li><p>线性探测法</p><p>使用线性探测法，一定要保证 tableSize 大于 dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求 tableSize 一定要大于 dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img data-src="http://lgqimg.changzer.cn/20210104235109950.png" alt="哈希表5" /></p></li></ul><ol start="4"><li><p>常见的三种哈希结构</p><ul><li>数组</li><li><strong>set</strong> (集合)</li><li><strong>map</strong> (映射)</li></ul><p>在 C++ 中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set 底层实现为哈希表，std::set 和 std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以 key 值是有序的，但 key 不可以修改，改动 key 值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key 有序</td><td>key 不可重复</td><td>key 不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key 有序</td><td>key 可重复</td><td>key 不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key 无序</td><td>key 不可重复</td><td>key 不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和 std::multimap 的底层实现是红黑树。同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用 unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用 set，如果要求不仅有序还要有重复数据的话，那么就用 multiset。</p><p>那么再来看一下 map ，在 map 是一个 key value 的数据结构，map 中，对 key 是有限制，对 value 没有限制的，因为 key 的存储方式使用红黑树实现的。</p><p>其他语言例如：java 里的 HashMap ，TreeMap 都是一样的原理。可以灵活贯通。</p><p>虽然 std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是 std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map 也是一样的道理。</p><p>这里在说一下，一些 C++ 的经典书籍上 例如 STL 源码剖析，说到了 hash_set hash_map，这个与 unordered_set，unordered_map 又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是 unordered_set 在 C<ins>11 的时候被引入标准库了，而 hash_set 并没有，所以建议还是使用 unordered_set 比较好，这就好比一个是官方认证的，hash_set，hash_map 是 C</ins>11 标准之前民间高手自发造的轮子。</p><p><img data-src="http://lgqimg.changzer.cn/20210104235134572.png" alt="哈希表6" /></p></li></ol></li></ol><h2 id="八-kmp-算法"><a class="anchor" href="#八-kmp-算法">#</a> 八、KMP 算法</h2><ol><li><p>KMP 主要应用早字符串匹配上。</p><p>KMP 算法的主要思想就是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配。</p></li><li><p>前缀表<br /><strong>前缀表是用来回退的，它记录了模式串与主串 (文本串) 不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p><strong>前缀表</strong>可以暂时理解为：<strong>字符串最长公共前缀后缀长度</strong>。<strong>记录下标 i 之前（包括 i）的字符串中，有多大长度的相同前缀后缀。</strong> &quot;前缀&quot; 指除了最后一个字符以外，一个字符串的全部头部组合；&quot;后缀&quot; 指除了第一个字符以外，一个字符串的全部尾部组合。字符串最长公共前缀后缀长度则表示在字符串的所有前缀和所有后缀中都出现的字符的长度。</p><p><strong>找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></p></li><li><p>计算前缀表</p><p>接下来就要说一说怎么计算前缀表。</p><p>如图：</p><p>&lt;img src='<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLXRoaW5raW5nLmNkbi5iY2Vib3MuY29tL3BpY3MvS01QJUU3JUIyJUJFJUU4JUFFJUIyNS5wbmc=">https://code-thinking.cdn.bcebos.com/pics/KMP 精讲 5.png</span>' width=600 alt='KMP 精讲 5'&gt; &lt;/img&gt;&lt;/div&gt;</p><p>长度为前 1 个字符的子串 <code>a</code> ，最长相同前后缀的长度为 0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p><p>&lt;img src='<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLXRoaW5raW5nLmNkbi5iY2Vib3MuY29tL3BpY3MvS01QJUU3JUIyJUJFJUU4JUFFJUIyNi5wbmc=">https://code-thinking.cdn.bcebos.com/pics/KMP 精讲 6.png</span>' width=600 alt='KMP 精讲 6'&gt; &lt;/img&gt;&lt;/div&gt;<br /> 长度为前 2 个字符的子串 <code>aa</code> ，最长相同前后缀的长度为 1。</p><p>&lt;img src='<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLXRoaW5raW5nLmNkbi5iY2Vib3MuY29tL3BpY3MvS01QJUU3JUIyJUJFJUU4JUFFJUIyNy5wbmc=">https://code-thinking.cdn.bcebos.com/pics/KMP 精讲 7.png</span>' width=600 alt='KMP 精讲 7'&gt; &lt;/img&gt;&lt;/div&gt;<br /> 长度为前 3 个字符的子串 <code>aab</code> ，最长相同前后缀的长度为 0。</p><p>以此类推：<br />长度为前 4 个字符的子串 <code>aaba</code> ，最长相同前后缀的长度为 1。<br />长度为前 5 个字符的子串 <code>aabaa</code> ，最长相同前后缀的长度为 2。<br />长度为前 6 个字符的子串 <code>aabaaf</code> ，最长相同前后缀的长度为 0。</p><p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：<br />&lt;img src='<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLXRoaW5raW5nLmNkbi5iY2Vib3MuY29tL3BpY3MvS01QJUU3JUIyJUJFJUU4JUFFJUIyOC5wbmc=">https://code-thinking.cdn.bcebos.com/pics/KMP 精讲 8.png</span>' width=600 alt='KMP 精讲 8'&gt; &lt;/img&gt;&lt;/div&gt;</p><p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标 i 之前（包括 i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p><p><img data-src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2" /></p><p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p><p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p><p>所以要看前一位的 前缀表的数值。</p><p>前一个字符的前缀表的数值是 2， 所有把下标移动到下标 2 的位置继续比配。 可以再反复看一下上面的动画。</p><p>最后就在文本串中找到了和模式串匹配的子串了。</p></li><li><p>前缀表与 next 数组</p><p>next 数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为 - 1）之后作为 next 数组。</p><p>其实<strong>这并不涉及到 KMP 的原理，而是具体实现，next 数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为 - 1）。</strong></p></li><li><p>构造 next 数组</p></li><li><p>我们定义一个函数 getNext 来构建 next 数组，函数参数为指向 next 数组的指针，和一个字符串。 代码如下：</p><pre><code>void getNext(int* next, const string&amp; s)</code></pre><p><strong>构造 next 数组其实就是计算模式串 s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><p>接下来我们详解详解一下。</p><ol><li>初始化：</li></ol><p>定义两个指针 i 和 j，j 指向前缀末尾位置，i 指向后缀末尾位置。</p><p>然后还要对 next 数组进行初始化赋值，如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr></table></figure><p>j 为什么要初始化为 -1 呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择 j 初始化为 - 1，下文我还会给出 j 不初始化为 - 1 的实现代码。</p><p>next [i] 表示 i（包括 i）之前最长相等的前后缀长度（其实就是 j）</p><p>所以初始化 next [0] = j 。</p><ol start="2"><li>处理前后缀不相同的情况</li></ol><p>因为 j 初始化为 - 1，那么 i 就从 1 开始，进行 s [i] 与 s [j+1] 的比较。</p><p>所以遍历模式串 s 的循环下标 i 要从 1 开始，代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr></table></figure><p>如果 s [i] 与 s [j+1] 不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p><p>怎么回退呢？</p><p>next [j] 就是记录着 j（包括 j）之前的子串的相同前后缀的长度。</p><p>那么 s [i] 与 s [j+1] 不相同，就要找 j+1 前一个元素在 next 数组里的值（就是 next [j]）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 前后缀不相同了</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>处理前后缀相同的情况</li></ol><p>如果 s [i]  与 s [j + 1] 相同，那么就同时向后移动 i 和 j 说明找到了相同的前后缀，同时还要将 j（前缀的长度）赋给 next [i], 因为 next [i] 要记录相同前后缀的长度。</p><p>代码如下：</p><pre><code>if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀    j++;&#125;next[i] = j</code></pre><p>最后整体构建 next 数组的函数代码如下：</p><pre><code class="language-CPP">void getNext(int* next, const string&amp; s)&#123;    int j = -1;    next[0] = j;    for(int i = 1; i &lt; s.size(); i++) &#123; // 注意i从1开始        while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了            j = next[j]; // 向前回退        &#125;        if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀            j++;        &#125;        next[i] = j; // 将j（前缀的长度）赋给next[i]    &#125;&#125;</code></pre><p>得到了 next 数组之后，就要用这个来做匹配了。</p><p>前缀表（不减一）实现：</p><pre><code class="language-c++">void getNext(int* next, const string&amp; s)&#123;        int j = 0;        next[0] = 0;        for(int i = 1; i &lt; s.size(); i++)        &#123;            while (j &gt; 0 &amp;&amp; s[i] != s[j])            &#123; // j要保证大于0，因为下面有取j-1作为数组下标的操作                j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了            &#125;            if (s[i] == s[j])            &#123;                j++;            &#125;            next[i] = j;        &#125;    &#125;</code></pre></li></ol><h2 id="九-栈"><a class="anchor" href="#九-栈">#</a> 九、栈</h2><ol><li>栈的定义<br />栈（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</li></ol><p><img data-src="http://lgqimg.changzer.cn/20210218204524571.png" alt="在这里插入图片描述" /></p><p>​ 栈顶（Top）：线性表允许进行插入删除的那一端。<br />​ 栈底（Bottom）：固定的，不允许进行插入和删除的另一端。<br />​ 空栈：不含任何元素的空表。</p><p>​ 栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构</p><ol start="2"><li><p>栈的常见基本操作</p><ul><li>InitStack (&amp;S)：初始化一个空栈 S。</li><li>StackEmpty (S)：判断一个栈是否为空，若栈为空则返回 true，否则返回 false。</li><li>Push (&amp;S, x)：进栈（栈的插入操作），若栈 S 未满，则将 x 加入使之成为新栈顶。</li><li>Pop (&amp;S, &amp;x)：出栈（栈的删除操作），若栈 S 非空，则弹出栈顶元素，并用 x 返回。</li><li>GetTop (S, &amp;x)：读栈顶元素，若栈 S 非空，则用 x 返回栈顶元素。</li><li>DestroyStack (&amp;S)：栈销毁，并释放 S 占用的存储空间（“&amp;” 表示引用调用）。</li></ul></li><li><p>栈的顺序存储结构</p><ul><li><p>栈的顺序存储<br />采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br />若存储栈的长度为 StackSize，则栈顶位置 top 必须小于 StackSize。当栈存在一个元素时，top 等于 0，因此通常把空栈的判断条件定位 top 等于 - 1。<br />栈的顺序存储结构可描述为：</p><pre><code class="language-c++">#define MAXSIZE 50  //定义栈中元素的最大个数typedef int ElemType;   //ElemType的类型根据实际情况而定，这里假定为inttypedef struct&#123;    ElemType data[MAXSIZE];    int top;    //用于栈顶指针&#125;SqStack;</code></pre><p>若现在有一个栈，StackSize 是 5，则栈的普通情况、空栈、满栈的情况分别如下图所示：</p><p><img data-src="http://lgqimg.changzer.cn/20210218225339549.png" alt="img" /></p></li><li><p>顺序栈的基本算法<br />（1）初始化<br /> void InitStack (SqStack *S){<br />S-&gt;top = -1; // 初始化栈顶指针<br />}</p><p>（2）判栈空</p><pre><code class="language-c++">bool StackEmpty(SqStack S)&#123;    if(S.top == -1)&#123;        return true;    //栈空    &#125;else&#123;        return false;   //不空    &#125;&#125;</code></pre><p>（3）进栈</p><p>进栈操作 push，代码如下：</p><pre><code class="language-c++">/*插入元素e为新的栈顶元素*/Status Push(SqStack *S, ElemType e)&#123;    //满栈    if(S-&gt;top == MAXSIZE-1)&#123;        return ERROR;    &#125;    S-&gt;top++;   //栈顶指针增加一    S-&gt;data[S-&gt;top] = e;    //将新插入元素赋值给栈顶空间    return OK;&#125;</code></pre><p>（4）出栈<br />出栈操作 pop，代码如下：</p><pre><code class="language-c++">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(SqStack *S, ElemType *e)&#123;    if(S-&gt;top == -1)&#123;        return ERROR;    &#125;    *e = S-&gt;data[S-&gt;top];   //将要删除的栈顶元素赋值给e    S-&gt;top--;   //栈顶指针减一    return OK;&#125;</code></pre><p>（5）读栈顶元素</p><pre><code class="language-c++">/*读栈顶元素*/Status GetTop(SqStack S, ElemType *e)&#123;    if(S-&gt;top == -1)&#123;   //栈空        return ERROR;    &#125;    *e = S-&gt;data[S-&gt;top];   //记录栈顶元素    return OK;&#125;</code></pre></li></ul></li><li><p>共享栈（两栈共享空间）</p><ul><li><p>共享栈概念<br />利用栈底位置相对不变的特征，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示：<br /><img data-src="http://lgqimg.changzer.cn/2021021909353762.png" alt="img" /></p><p>两个栈的栈顶指针都指向栈顶元素，top0=-1 时 0 号栈为空，top1=MaxSize 时 1 号栈为空；仅当两个栈顶指针相邻（top0+1=top1）时， 判断为栈满。当 0 号栈进栈时 top0 先加 1 再赋值，1 号栈进栈时 top1 先减一再赋值出栈时则刚好相反。</p></li><li><p>共享栈的空间结构<br />代码如下：</p><pre><code class="language-c++">/*两栈共享空间结构*/#define MAXSIZE 50  //定义栈中元素的最大个数typedef int ElemType;   //ElemType的类型根据实际情况而定，这里假定为int/*两栈共享空间结构*/typedef struct&#123;ElemType data[MAXSIZE];int top0;//栈0栈顶指针int top1;//栈1栈顶指针&#125;SqDoubleStack;</code></pre></li><li><p>共享栈进栈<br />对于两栈共享空间的 push 方法，我们除了要插入元素值参数外，还需要有一个判断是栈 0 还是栈 1 的栈号参数 stackNumber。<br />共享栈进栈的代码如下：</p><pre><code class="language-c++">/*插入元素e为新的栈顶元素*/Status Push(SqDoubleStack *S, Elemtype e, int stackNumber)&#123;    if(S-&gt;top0+1 == S-&gt;top1)&#123;   //栈满        return ERROR;    &#125;    if(stackNumber == 0)&#123;   //栈0有元素进栈        S-&gt;data[++S-&gt;top0] = e; //若栈0则先top0+1后给数组元素赋值    &#125;else if(satckNumber == 1)&#123; //栈1有元素进栈        S-&gt;data[--S-&gt;top1] = e; //若栈1则先top1-1后给数组元素赋值    &#125;    return OK;&#125;</code></pre></li><li><p>共享栈出栈</p><pre><code class="language-c++">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(SqDoubleStack *S, ElemType *e, int stackNumber)&#123;    if(stackNumber == 0)&#123;        if(S-&gt;top0 == -1)&#123;            return ERROR;   //说明栈0已经是空栈，溢出        &#125;        *e = S-&gt;data[S-&gt;top0--]; //将栈0的栈顶元素出栈，随后栈顶指针减1    &#125;else if(stackNumber == 1)&#123;        if(S-&gt;top1 == MAXSIZE)&#123;            return ERROR;   //说明栈1是空栈，溢出        &#125;        *e = S-&gt;data[S-&gt;top1++];    //将栈1的栈顶元素出栈，随后栈顶指针加1    &#125;    return OK;&#125;</code></pre></li></ul></li><li><p>栈的链式存储结构</p><ul><li><p>链栈<br />采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头节点，Lhead 指向栈顶元素，如下图所示。<br /><img data-src="http://lgqimg.changzer.cn/2021021910502017.png" alt="img" /></p><p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是 top=NULL 的时候。<br />链栈的结构代码如下：</p><pre><code class="language-c++">/*栈的链式存储结构*//*构造节点*/typedef struct StackNode&#123;    ElemType data;    struct StackNode *next;&#125;StackNode, *LinkStackPrt;/*构造链栈*/typedef struct LinkStack&#123;    LinkStackPrt top;    int count;&#125;LinkStack;</code></pre><ul><li><p>链栈的基本算法</p><ul><li>链栈的进栈<br />对于链栈的进栈 push 操作，假设元素值为 e 的新节点是 s，top 为栈顶指针，示意图如下：<br /><img data-src="http://lgqimg.changzer.cn/20210524215216496.png" alt="在这里插入图片描述" /></li></ul><p>代码如下：</p><pre><code class="language-c++">/*插入元素e为新的栈顶元素*/Status Push(LinkStack *S, ElemType e)&#123;    LinkStackPrt p = (LinkStackPrt)malloc(sizeof(StackNode));    p-&gt;data = e;    p-&gt;next = S-&gt;top;    //把当前的栈顶元素赋值给新节点的直接后继    S-&gt;top = p; //将新的结点S赋值给栈顶指针    S-&gt;count++;    return OK;&#125;</code></pre><ul><li><p>链栈的出栈<br />链栈的出栈 pop 操作，也是很简单的三句操作。假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移以为，最后释放 p 即可，如下图所示：<br /><img data-src="http://lgqimg.changzer.cn/20210219110743130.png" alt="img" /><br /> 代码如下：</p><pre><code class="language-c++">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/Status Pop(LinkStack *S, ElemType *e)&#123;    LinkStackPtr p;    if(StackEmpty(*S))&#123;        return ERROR;    &#125;    *e = S-&gt;top-&gt;data;    p = S-&gt;top; //将栈顶结点赋值给p    S-&gt;top = S-&gt;top-&gt;next;  //使得栈顶指针下移一位，指向后一结点    free(p);    //释放结点p    S-&gt;count--;    return OK;    &#125;</code></pre></li></ul></li></ul></li></ul></li><li><p>性能分析<br />链栈的进栈 push 和出栈 pop 操作都很简单，时间复杂度均为 O (1)。<br />对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为 O (1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p></li><li><p>栈的应用 —— 递归</p><ul><li><p>递归的定义<br />递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。<br />它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述岀解题过程所需要的多次重复计算，大大减少了程序的代码量但在通常情况下，它的效率并不是太高。</p></li><li><p>斐波那契数列<br />用程序实现时如下：</p><pre><code class="language-c++">/*斐波那契数列的实现*/int Fib(int n)&#123;    if(n == 0)&#123;        return 0;   //边界条件    &#125;else if(n == 1)&#123;        return 1;//边界条件    &#125;else&#123;        return Fib(n-1) + Fib(n-2); //递归表达式    &#125;&#125;</code></pre><p>必须注意递归模型不能是循环定义的，其必须满足下面的两个条件递归表达式 (递归体)<br /> 边界条件 (递归出口)<br /> 递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题<br />在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。下面以 n=5 为例，列出递归调用执行过程，如图所示：<br /><img data-src="http://lgqimg.changzer.cn/20210219115532873.png" alt="img" /> 如图可知，程序每往下递归一次，就会把运算结果放到栈中保存，直到程序执行到临界条件，然后便会把保存在栈中的值按照先进后出的顺序一个个返回，最终得出结果。</p></li></ul></li><li><p>栈的应用 —— 四则运算表达式求值</p><ul><li>后缀表达式计算结果<br />表达式求值是程序设计语言编译中一个最基本的问题，它的实现是栈应用的一个典型范例。中缀表达式不仅依赖运算符的优先级，而且还要处理括号。<em>后缀表达式的运算符在操作数后面，在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。例如中缀表达式 A + B ∗ (C − D) − E / F A+B</em> (C-D)-E/FA+B∗(C−D)−E/F 所对应的后缀表达式为 A B C D − ∗ + E F / − ABCD-<em>+EF/-ABCD−∗+EF/−。<br />后缀表达式计算规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进项运算，运算结果进栈，一直到最终获得结果。</em></li><li><em>中缀表达式转后缀表达式<br />我们把平时所用的标准四则运算表达式，即 a + b − a ∗ (( c + d) /e − f ) + g a+b-a</em> ((c+d)/e-f)+ga+b−a∗((c+d)/e−f)+g 叫做中缀<br />表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中缀到后缀的转化。规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后<br />缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号 (乘除优先加减) 则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络：自定向下》第一章：概述</title>
      <link href="/2022/10/03/NetWork/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/10/03/NetWork/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章概述"><a class="anchor" href="#第一章概述">#</a> 第一章：概述</h1><h3 id="1-介绍"><a class="anchor" href="#1-介绍">#</a> 1. 介绍</h3><ul><li><p>TCP：传输控制协议。提供面向连接的服务。基于 TCP 的传输可靠性高，能够传输准确、完整的信息，但是信息的实时性有失准确。</p></li><li><p>UDP：用户数据报协议。提供无连接的服务。基于 UDP 的传输能够传输实时信息，信息不会产生延迟，但是信息的可靠性不高。</p></li><li><p>协议：对等层实体在通信过程中应该遵守的规则和集合，包括语法、语义和时序。控制接收、发送信息</p></li><li><p>ISP：网络服务提供商</p></li><li><p>套接字接口 (Socket interface): 因特网发送程序必须遵守的规则集合。规定了两个不同端系统的两个程序在因特网基础设施交互数据的方式。</p></li><li><p>互联网子系统：网络核心、网络边缘、网络的接入</p></li><li><p>网络边缘由接入网连接到网络核心，从而能够完成不同端系统之间的信息交互，网络核心起到数据交换的作用。</p></li></ul><h3 id="2-网络边缘"><a class="anchor" href="#2-网络边缘">#</a> 2. 网络边缘</h3><ul><li><p>端系统：通常把与因特网相连的计算机和其他设备被称为端系统，处于因特网边缘，被称为端系统，也称为主机，主机容纳 (运行) 应用程序。主机又被分为：客户端和服务器。</p></li><li><p>网络边缘作用：运行应用程序。</p></li><li><p>客户段 / 服务器（C/S）模式：客户向服务器请求、接收服务。资源全部储存在服务器中。</p><blockquote><ul><li>服务器先运行，客户端后启动。客户端主动请求，服务器被动接收。</li><li>C/S 模式的可拓展性差，服务器达到一定阈值时，服务器性能断崖式下降，服务器接收不了请求。</li></ul></blockquote></li><li><p>对等 (peer to peer (p2p)) 模式</p><blockquote><ul><li>没有专门的服务器，每个节点既可以是客户端也可以是服务器，都统称为端系统</li><li>在一个端系统需要资源时，向其他已经建立连接、且拥有所请求资源片段的端系统发送资源请求，再整合获取的资源片段从而获得完整的资源</li></ul></blockquote></li><li><p>网络边缘：采用网络设施的面向连接服务</p><blockquote><ul><li><p>目标：在端系统之间传输数据</p></li><li><p>握手：在传输数据之前做好准备</p><blockquote><ul><li>两个通信主机之间为连接建立状态</li></ul></blockquote></li><li><p>TCP (Transmission Control Protocol):Internet 上的面向连接服务</p></li><li><p>TCP 服务 (RFC 793)</p><blockquote><ul><li>可靠地、按顺序地传送数据 —— 确认和重传</li><li>流量控制 —— 发送不会淹没接收方</li><li>拥塞控制 —— 当网络拥塞时，发送方降低发送速率</li></ul></blockquote></li></ul></blockquote></li></ul><h3 id="3-网络核心路由器的网状网络"><a class="anchor" href="#3-网络核心路由器的网状网络">#</a> 3. 网络核心：路由器的网状网络</h3><h4 id="1-电路交换"><a class="anchor" href="#1-电路交换">#</a> 1. 电路交换</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220319152750578.png" alt="image-20220319152750578" /></p></li><li><p>主机之间通过信令系统在通信之前建立起一条专用的通信通道，其他主机无法使用，易造成资源浪费，且连接建立时间长</p></li><li><p>电路交换不适用于计算机之间的通信</p><blockquote><ul><li><p>连接建立时间长</p></li><li><p>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多</p><blockquote><p>即使这个呼叫没有数据传递，其占据的片也不能够被别的呼叫使用</p></blockquote></li><li><p>可靠性不高</p></li></ul></blockquote><p>电路交换中的复用</p><ol><li>频分复用 (FDM)<ul><li>在两个主机的通信链路的有效通信频率范围内，将有效频段划分为多片小的频段，在通信时，每个主机在有效频率范围内，找到有空的一个频段。</li></ul></li><li>时分复用 (TDM)<ul><li>将时间划分为固定时间的多个帧，再将每个帧划分为相同的固定数量的时隙。在进行连接时，网络为其连接在每个帧中指定一个时隙。</li></ul></li><li>波分复用 (WDM): 用于光纤通信<ul><li>将主机通信之间的有效波段分为许多相同的更小的波段，每个用户使用其中的一个小波段</li></ul></li><li>码分复用 (CDM)</li></ol></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220319155836424.png" alt="image-20220319155836424" /></p></li></ul></blockquote><h4 id="2分组交换"><a class="anchor" href="#2分组交换">#</a> 2. 分组交换</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220319160624991.png" alt="image-20220319160624991" /></p></li><li><p>不会造成网络资源浪费，网络是共享的</p></li><li><p>分组发送与接受时间相同，分组交换的时间只能用发送或接收其中一个来计算。</p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220319163457589.png" alt="image-20220319163457589" /></p></li><li><p>存储转发时延：分组在到达分组交换机时，在此分组前还存在其他的分组先到达分组交换机，此分组只有在其他分组存储转发之后，才能够被分组交换机存储转发。</p></li><li><p>排队时延：分组交换机的到达速率 &gt; 输出速率，分组将会进行排队等待传输，形成排队时延</p></li><li><p>输出缓存 (输出队列): 分组交换机具有一个输出缓存，用于存储路由器准备发往下一条链路的分组</p></li><li><p>分组丢失 (丢包)：输出缓存是有限的，当缓存被其他等待的分组充满时，将会出现分组被抛弃的情况，被称为分组丢失 (丢包)，到达的分组或在排队的分组之一将会被丢弃</p></li><li><p>统计多路复用：主机之间的通信被分为多个片段，在不同的片段传输不同的分组，划分片段没有固定的模式</p></li><li><p>分组交换网络：</p><blockquote><p>分组的存储转发一段一段从源端传到目标端，按照有无网络层的连接，分成：</p><ul><li><p>数据报网络</p><blockquote><ul><li>主机之间的交换节点不需要建立通信状态，主机之间不需要握手</li><li>每个分组携带了目标主机的完整地址</li><li>每个分组都独立路由 (路径不一样，可能会失序)</li><li>路由器根据分组的目标地址进行路由</li><li>类似：问路</li><li>Internet</li><li>面向无连接的</li></ul></blockquote></li><li><p>虚电路网络</p><blockquote><ul><li>主机之间握手，交换节点建立通信状态，建立起一条虚电路</li><li>主机之间通过信令建立连接</li><li>每个分组接待一个虚电路号</li><li>每个分组按照虚电路号进行识别</li><li>面向连接的</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h4 id="3-网络核心的关键功能"><a class="anchor" href="#3-网络核心的关键功能">#</a> 3. 网络核心的关键功能</h4><p><img data-src="http://lgqimg.changzer.cn/image-20220319164935031.png" alt="image-20220319164935031" /></p><h4 id="4-分组交换-vs-电路交换"><a class="anchor" href="#4-分组交换-vs-电路交换">#</a> 4. 分组交换 VS 电路交换</h4><ul><li><ol><li>电路交换更具实时性</li><li>分组交换提供更好的带宽</li><li>分组交换更简单、更有效、成本更低</li></ol></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220319170908764.png" alt="image-20220319170908764" /></p></li><li><p>分组交换适合于突发式数据传输</p><ul><li>能够资源共享</li><li>简单，不必建立呼叫</li></ul></li><li><p>分组交换过度使用造成网络拥塞：分组延时和丢失</p><ul><li>对可靠地数据传输需要协议来约束：拥塞控制</li></ul></li></ul><h3 id="4-接入网和物理媒介"><a class="anchor" href="#4-接入网和物理媒介">#</a> 4. 接入网和物理媒介</h3><ul><li>接入网：将端系统接入到网络核心，让不同端系统之间实现连接</li></ul><h4 id="1-住宅接入网络"><a class="anchor" href="#1-住宅接入网络">#</a> 1 . 住宅接入网络</h4><h5 id="1-modem"><a class="anchor" href="#1-modem">#</a> (1). modem</h5><blockquote><ul><li>将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据调解出来；反之亦然；<ul><li>调频：不同频持续不同时间，代表 0 或 1</li><li>调幅：音频的幅度</li><li>调相位</li><li>综合调剂</li></ul></li><li>拨号调制解调器 (modem)<ul><li>调制解调解器，是调制器和解调器的缩写 ，一种<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkE=">计算机</span>硬件 ，它能把计算机的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTUlQUQlOTclRTQlQkYlQTElRTUlOEYlQjcvOTE1NjYz">数字信号</span>翻译成可沿普通<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOTQlQjUlRTglQUYlOUQlRTclQkElQkYvMzEzMzk4Mg==">电话线</span>传送的模拟信号，而这些模拟信号又可被线路另一端的另一个调制解调器接收，并译成计算机可懂的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUYlQUQlRTglQTglODAvMjI5MTA5NQ==">语言</span>。这一简单过程完成了两台计算机间的通信。</li><li>56Kbps 的速率直接接入路由器 (通常更低)</li><li>不能同时上网和打电话，不能同时在线，带宽窄</li></ul></li></ul></blockquote><h5 id="2dsldigital-subscriber-line"><a class="anchor" href="#2dsldigital-subscriber-line">#</a> (2).DSL(Digital Subscriber Line)</h5><blockquote><ul><li>&lt;4KHz 以下用于语音的通讯，4KHz 以上较小部分为下行数据，较大部分为上行数据，用调制解调的方式控制上行数据和下行数据进行上网工作<ul><li>上行数据：从终端节点向网络传送的数据</li><li>下行数据：从网络上向终端节点传送的数据</li></ul></li><li>采用现存到交换局 DSLAM 的电话线<ul><li>DSL 线路上的数据被传到互联网</li><li>DSL 线路上的语音被传到电话网</li></ul></li><li>&lt;2.5 Mbps 上行传输速率 (typically &lt; 1 Mbps)</li><li>&lt;24 Mbps 下行传输速率 (typically &lt; 10 Mbps)</li><li>可以同时上网和通话</li></ul></blockquote><h5 id="3-线缆网络"><a class="anchor" href="#3-线缆网络">#</a> (3). 线缆网络</h5><blockquote><ul><li>有线电视信号线缆双向改造</li><li>FDM：在不同频段传输不同信道的数据，数字电视和和上网数据 (上下行)</li><li>一些带宽用于上行，一些用于上行，一些用于电话，一些用控制，一些用于数字广播</li><li>HFC：Hybrid Fiber Coax<ul><li>非对称：最高 30Mbps 的下行传输速率，2Mbps 上行传输速率</li></ul></li><li>线缆和光纤网络将每个家庭用户接入到 ISP 路由器</li><li>各用户共享到线缆头端的接入网络<ul><li>与 DSL 不同，DSL 每个用户一个专用线路到 CO (Central Office)</li></ul></li></ul></blockquote><h5 id="4-电缆接入"><a class="anchor" href="#4-电缆接入">#</a> (4). 电缆接入</h5><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220320160500100.png" alt="image-20220320160500100" /></li></ul></blockquote><h4 id="2-企业接入网络"><a class="anchor" href="#2-企业接入网络">#</a> 2. 企业接入网络</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220322141323413.png" alt="image-20220322141323413" /></li></ul></blockquote><h4 id="3-无线接入网络"><a class="anchor" href="#3-无线接入网络">#</a> 3. 无线接入网络</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220322141620264.png" alt="image-20220322141620264" /></li></ul></blockquote><h4 id="4-物理媒体"><a class="anchor" href="#4-物理媒体">#</a> 4. 物理媒体</h4><blockquote><ul><li>Bit：在传输 — 接收对间传播</li><li>物理链路：在每个传输 — 接受对，跨越一种物理媒体</li><li>导引型媒体：信号沿着固体媒介被导引：<ul><li>同轴电缆</li><li>光纤</li><li>双绞线</li></ul></li><li>非导引型媒体：信号自由传播<ul><li>如无线电</li></ul></li></ul></blockquote><h5 id="1双绞线tp"><a class="anchor" href="#1双绞线tp">#</a> (1). 双绞线 (TP)</h5><blockquote><ul><li><p>两根绝缘铜线</p></li><li><p>5 类：100Mbps Enthernet、Gbps 、以太网</p></li><li><p>6 类：10Gbps</p></li></ul></blockquote><h5 id="2-同轴电缆"><a class="anchor" href="#2-同轴电缆">#</a> (2). 同轴电缆</h5><blockquote><ul><li>两根同心的铜导线</li><li>双向</li><li>亟待电缆<ul><li>电缆上一个单个信道</li><li>Ethernet</li></ul></li><li>宽带电缆<ul><li>电缆上有多个信道</li><li>HFC</li></ul></li></ul></blockquote><h5 id="3-光纤和光缆"><a class="anchor" href="#3-光纤和光缆">#</a> (3). 光纤和光缆</h5><blockquote><ul><li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输</li><li>告诉<ul><li>点到点高速传输 (如 10Gps-100Gps 传输速率)</li></ul></li><li>低误码率：再来个那个中继器之间可以有很长的距离；不受电磁噪声的干扰</li><li>安全</li></ul></blockquote><h5 id="4-无线链路"><a class="anchor" href="#4-无线链路">#</a> (4). 无线链路</h5><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220322144232075.png" alt="image-20220322144232075" /></p></blockquote><h3 id="5-internet-和-isp"><a class="anchor" href="#5-internet-和-isp">#</a> 5. Internet 和 ISP</h3><h4 id="1-互联网结构网络的网络"><a class="anchor" href="#1-互联网结构网络的网络">#</a> 1. 互联网结构：网络的网络</h4><blockquote><ul><li><p>端系统通过接入 ISP 连接到互联网</p><ul><li>住宅、公司和大学的 ISP</li></ul></li><li><p>接入的 ISP 必须时互联的</p><ul><li>因此任何 2 个端系统可相互发送分组到对方</li></ul></li><li><p>导致的 “网络的网络” 非常复杂</p><ul><li>发展和演化时通过经济的和国家的政策来驱动的</li></ul></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327160944289.png" alt="image-20220327160944289" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327161155632.png" alt="image-20220327161155632" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327161409978.png" alt="image-20220327161409978" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327161449434.png" alt="image-20220327161449434" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327161518566.png" alt="image-20220327161518566" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327161643734.png" alt="image-20220327161643734" /></p></li></ul></blockquote><h4 id="2-isp-之间的连接"><a class="anchor" href="#2-isp-之间的连接">#</a> 2. ISP 之间的连接</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220327161807562.png" alt="image-20220327161807562" /></li></ul></blockquote><h3 id="6分组延时-丢失和吞吐量"><a class="anchor" href="#6分组延时-丢失和吞吐量">#</a> 6. 分组延时、丢失和吞吐量</h3><ul><li><p>分组丢失和延时如何发生</p><blockquote><p>在路由器缓冲区的分组队列：</p><ul><li>分组到达链路的速率超过了链路输出的能力</li><li>分组等待排到队头、被传输</li><li><img data-src="http://lgqimg.changzer.cn/image-20220327163006889.png" alt="image-20220327163006889" /></li></ul></blockquote></li></ul><h4 id="1-四种分组延时"><a class="anchor" href="#1-四种分组延时">#</a> 1. 四种分组延时</h4><blockquote><ol><li><p>节点处理延时</p><ul><li>检查 bit 级差错</li><li>检查分组首部和决定将分组导向何处</li></ul></li><li><p>排队延时</p><ul><li>在输出链路上等待传输的时间</li><li>依赖于路由器的拥塞程度</li></ul></li><li><p>传输延时</p><ul><li>R = 链路带宽 (bps)</li><li>L = 分组长度 (bits)</li><li>将分组发送到链路上的时间 =$$L/R$$</li><li>存储转发延时</li></ul></li><li><p>传播延时</p><ul><li>d = 物理链路的长度</li><li>s = 在媒体上的传播速度 (~$$2*10^8 m/s$$)</li><li>传播延时 = d/s</li></ul></li><li><p><strong>节点延时</strong></p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220327165000049.png" alt="image-20220327165000049" /></p></li><li><p>因素</p><p><img data-src="http://lgqimg.changzer.cn/image-20220327165631946.png" alt="image-20220327165631946" /></p></li></ul></li></ol></blockquote><h4 id="2-吞吐量"><a class="anchor" href="#2-吞吐量">#</a> 2. 吞吐量</h4><blockquote><ul><li>在源端和目标端之间传输的有效数据量的速率 (数据量 / 单位时间)<ul><li>瞬间吞吐量：在一个时间点的速率</li><li>平均吞吐量：在一个长时间内平均值</li><li>瓶颈链路<ul><li>端到端路径上。限制端到端吞吐的链路</li></ul></li></ul></li></ul></blockquote><h3 id="7-协议层次和服务模型"><a class="anchor" href="#7-协议层次和服务模型">#</a> 7. 协议层次和服务模型</h3><h4 id="1-服务和服务点"><a class="anchor" href="#1-服务和服务点">#</a> 1. 服务和服务点</h4><blockquote><ol><li>服务 (Service)：低层实体向上层实体提供它们之间的通信的能力<ul><li>服务用户 (service user)</li><li>服务提供者 (service provider)</li></ul></li><li>原语 (primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的形式</li><li>服务访问点 SAP (Service Access Point)：使用下层提供的服务通过层间的接口 — 地点：<ul><li>例子：邮箱</li><li>地址 (address)：下层的一个实体支撑着上层的多个实体，SAP 有标志不同上层实体的作用</li><li>可以有不同的实现，队列</li><li>例子：传输层的 SAP：端口 (port)</li></ul></li></ol></blockquote><h4 id="2-服务类型"><a class="anchor" href="#2-服务类型">#</a> 2. 服务类型</h4><blockquote><ol><li>面向连接的服务<ul><li>连接 (Connection)：两个通信实体为进行通信而建立的一种结合</li><li>面向连接的服务通信的过程：建立连接、通信、拆除连接</li><li>面向连接的例子：网路层的连接被称为虚电路</li><li>适用范围：对于打数据块要传输，不适合小的零星报文</li><li>特点：保护</li><li>服务类型<ul><li>可靠的信息流：传送页面 (可靠的获得，通过接收方的确认)</li><li>可靠的字节流，远程登陆</li><li>不可靠的连接，数字化声音</li></ul></li></ul></li><li>面向无连接的服务 (Connection Service)<ul><li>无连接服务：两个对等层实体在通信前不需要建立一个连接，不可预留资源；不需要通信双方都是活跃：(例：寄信)</li><li>特点：不可靠、可能重复、可能失序</li><li>IP 分组，数据包</li><li>适用范围：适合传输零星数据</li><li>服务类型：<ul><li>不可靠的数据报，电子方式的函件</li><li>有确认的数据报、挂号信</li><li>请求回答、信息查询</li></ul></li></ul></li></ol></blockquote><h4 id="3-服务和协议"><a class="anchor" href="#3-服务和协议">#</a> 3. 服务和协议</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220327221853781.png" alt="image-20220327221853781" /></li><li>数据单元 (DU):<img data-src="http://lgqimg.changzer.cn/image-20220328203928045.png" alt="image-20220328203928045" /></li></ul></blockquote><h4 id="4分层对于复杂系统的好处"><a class="anchor" href="#4分层对于复杂系统的好处">#</a> 4. 分层对于复杂系统的好处</h4><blockquote><ul><li>*<img data-src="http://lgqimg.changzer.cn/image-20220329104256528.png" alt="image-20220329104256528" /></li></ul></blockquote><h4 id="5-internet-协议栈"><a class="anchor" href="#5-internet-协议栈">#</a> 5. Internet 协议栈</h4><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220329104527799.png" alt="image-20220329104527799" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220329110344965.png" alt="image-20220329110344965" /></p></blockquote><h4 id="6-封装与解封装"><a class="anchor" href="#6-封装与解封装">#</a> 6. 封装与解封装</h4><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220329111022155.png" alt="image-20220329111022155" /></p></blockquote><h4 id="7-各层次的数据单元"><a class="anchor" href="#7-各层次的数据单元">#</a> 7. 各层次的数据单元</h4><ul><li>应用层：报文 (Message)</li><li>传输层：报文段 (Segment)：TCP 端、UDP 数据报</li><li>网络层：分组 packet (无连接方式：数据报 datagram)</li><li>数据链路层：帧 (frame)</li><li>物理层：位 (bit)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络：自定向下》第三章：传输层</title>
      <link href="/2022/10/03/NetWork/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2022/10/03/NetWork/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章传输层"><a class="anchor" href="#第三章传输层">#</a> 第三章：传输层</h1><h3 id="1-概述和传输层服务"><a class="anchor" href="#1-概述和传输层服务">#</a> 1. 概述和传输层服务</h3><h4 id="1-传输协议和服务"><a class="anchor" href="#1-传输协议和服务">#</a> (1). 传输协议和服务</h4><blockquote><ul><li>为运行在不同和主机上的应用进程提供逻辑通信</li><li>传输协议运行在端系统<ul><li>发送方：将应用层的报文分成报文段，然后传递给网络层</li><li>接收方：将报文段重组成报文，然后传递给应用层</li></ul></li><li>有多个传输层协议可供应用选择<ul><li>Internet：TCP 和 UDP</li></ul></li></ul></blockquote><h4 id="2-传输层-vs-网络层"><a class="anchor" href="#2-传输层-vs-网络层">#</a> (2). 传输层 VS 网络层</h4><blockquote><ul><li>网络层服务：主机之间的逻辑通信</li><li>传输层服务：进程之间的逻辑通信<ul><li>依赖于网络层的服务<ul><li>延时、带宽</li></ul></li><li>并对网络层的服务进行增强<ul><li>数据丢失、顺序混乱、加密</li></ul></li></ul></li><li><img data-src="http://lgqimg.changzer.cn/image-20220418221316700.png" alt="image-20220418221316700" /></li></ul></blockquote><h4 id="3-internet-传输协议"><a class="anchor" href="#3-internet-传输协议">#</a> (3). Internet 传输协议</h4><blockquote><ul><li><p>可靠的、保序的传输：TCP</p><ul><li>多路复用、解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li></ul></li><li><p>不可靠、不保序的传输：UDP</p><ul><li><p>多路复用、解复用</p></li><li><p>没有为尽力而为的 IP 服务添加更多的其他额外服务</p></li></ul></li><li><p>都不提供的服务：</p><ul><li>延时保证</li><li>带宽保证</li></ul></li></ul></blockquote><h3 id="2-多路复用解复用"><a class="anchor" href="#2-多路复用解复用">#</a> 2. 多路复用 / 解复用</h3><blockquote><ul><li><p>在发送方主机多路复用</p><blockquote><p>从多个套接字接收来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</p></blockquote></li><li><p>在接收方主机解复用</p><blockquote><p>根据报文段的头部信息中的 IP 地址和端口号将收到的报文段发给正确的套接字 (和对应的应用进程)</p></blockquote></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419141823311.png" alt="image-20220419141823311" /></p></li></ul></blockquote><h3 id="3-无连接传输-udp"><a class="anchor" href="#3-无连接传输-udp">#</a> 3. 无连接传输 UDP</h3><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419143001305.png" alt="image-20220419143001305" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419143333624.png" alt="image-20220419143333624" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419143847516.png" alt="image-20220419143847516" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419144458370.png" alt="image-20220419144458370" /></p></li></ul></blockquote><h3 id="4-可靠数据传输rdt的原理"><a class="anchor" href="#4-可靠数据传输rdt的原理">#</a> 4. 可靠数据传输 (RDT) 的原理</h3><h4 id="1问题描述"><a class="anchor" href="#1问题描述">#</a> (1) 问题描述</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220419145440402.png" alt="image-20220419145440402" /></li></ul></blockquote><h4 id="2rdt"><a class="anchor" href="#2rdt">#</a> (2)RDT</h4><blockquote><ul><li><p>RDT 1.0** &gt; <img data-src="http://lgqimg.changzer.cn/image-20220419145959385.png" alt="image-20220419145959385" /></p></li><li><p><strong>RDT 2.0</strong> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220419150123327.png" alt="image-20220419150123327" /></p></li><li><p><strong>RDT 2.1</strong> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220419200802380.png" alt="image-20220419200802380" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220419201147064.png" alt="image-20220419201147064" /></p></li><li><p><strong>RDT 2.2</strong> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220419201737116.png" alt="image-20220419201737116" /></p></li><li><p><strong>RDT 3.0</strong> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220419203025590.png" alt="image-20220419203025590" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220419204200758.png" alt="image-20220419204200758" /></p></li></ul></blockquote><h4 id="3-流水协议"><a class="anchor" href="#3-流水协议">#</a> (3). 流水协议</h4><blockquote><ul><li><p>流水线协议<br /><img data-src="http://lgqimg.changzer.cn/image-20220419205119533.png" alt="image-20220419205119533" /></p></li><li><p>滑动窗口协议<br /><img data-src="http://lgqimg.changzer.cn/image-20220419205349368.png" alt="image-20220419205349368" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220419210028291.png" alt="image-20220419210028291" /></p><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220419210126707.png" alt="image-20220419210126707" /></li></ul></li></ul><p>​ <img data-src="http://lgqimg.changzer.cn/image-20220419210300325.png" alt="image-20220419210300325" /></p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419210609748.png" alt="image-20220419210609748" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220419211136539.png" alt="image-20220419211136539" /></p></li><li><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220419211729788.png" alt="image-20220419211729788" /></li></ul></li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220419212606597.png" alt="image-20220419212606597" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220419212646137.png" alt="image-20220419212646137" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220419212806202.png" alt="image-20220419212806202" /></p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419213042447.png" alt="image-20220419213042447" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419213559365.png" alt="image-20220419213559365" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220419213920016.png" alt="image-20220419213920016" /></p></li><li></li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220419214050639.png" alt="image-20220419214050639" /></p><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220419214152849.png" alt="image-20220419214152849" /></li></ul></blockquote><h3 id="5-面向连接的传输tcp"><a class="anchor" href="#5-面向连接的传输tcp">#</a> 5、面向连接的传输：TCP</h3><h4 id="1-tcp-概述"><a class="anchor" href="#1-tcp-概述">#</a> (1). TCP 概述</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220423155619410.png" alt="image-20220423155619410" /></li></ul></blockquote><h4 id="2-tcp-报文结构"><a class="anchor" href="#2-tcp-报文结构">#</a> (2). TCP 报文结构</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220423155829103.png" alt="image-20220423155829103" /><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220423161536259.png" alt="image-20220423161536259" /></li></ul></li></ul></blockquote><h4 id="3-往返时间的估计与超时"><a class="anchor" href="#3-往返时间的估计与超时">#</a> (3). 往返时间的估计与超时</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220423162303614.png" alt="image-20220423162303614" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220423162953639.png" alt="image-20220423162953639" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220423163025528.png" alt="image-20220423163025528" /></p></li></ul></blockquote><h4 id="4-可靠数据传输"><a class="anchor" href="#4-可靠数据传输">#</a> (4). 可靠数据传输</h4><blockquote><ul><li><p>TCP 在 IP 不可靠传输服务的基础上建立了 rdt</p><ul><li>管道化的报文段<ul><li>GBN or SR</li></ul></li><li>累积确认 (像 GBN)</li><li>单个冲传定时器</li><li>是否可以接收乱序的，没有规范</li></ul></li><li><p>通过以下时间出发重传</p><ul><li>超时 (只重发那个最早的未确认段：SR)</li><li>重复的确认<ul><li>例子：收到了 ACK50，之后又收到 3 个 ACK50</li></ul></li></ul></li><li><p>首先考虑简化的 TCP 发送方：</p><ul><li>忽略重复的确认</li><li>忽略流量控制和拥塞控制</li></ul></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220423164848094.png" alt="image-20220423164848094" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220423165414206.png" alt="image-20220423165414206" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220423165709674.png" alt="image-20220423165709674" /></p></li></ul></blockquote><h4 id="5-流量控制"><a class="anchor" href="#5-流量控制">#</a> (5). 流量控制</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220426135711627.png" alt="image-20220426135711627" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220426135903078.png" alt="image-20220426135903078" /></p></li></ul></blockquote><h4 id="6-连接管理"><a class="anchor" href="#6-连接管理">#</a> (6). 连接管理</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220426140218407.png" alt="image-20220426140218407" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220426142126406.png" alt="image-20220426142126406" /></p></li></ul></blockquote><h3 id="6-拥塞控制原理"><a class="anchor" href="#6-拥塞控制原理">#</a> 6、拥塞控制原理</h3><blockquote><ul><li><p>拥塞：</p><ul><li>非正常的定义：“太多的数据需要网络传输，超过了网络的处理能力”</li><li>与流量控制表现不同</li><li>拥塞的表现：<ul><li>分组丢失 (路由器缓冲区溢出)</li><li>分组经历比较长的延迟 (在路由器的队列中排队)</li></ul></li><li>网络中前 10 位的问题！</li></ul></li><li><p>原因：</p><ul><li><p>代价：1. 延迟大 2. 需要更大的输出速率 3. 在拥塞时，会重传许多不必要的分组，加速拥塞 4. 在拥塞时，有些分组上游的传输能力被浪费掉，无法进行传输</p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429135752212.png" alt="image-20220429135752212" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429135827382.png" alt="image-20220429135827382" /></p></li><li><p>死锁<img data-src="http://lgqimg.changzer.cn/image-20220429140524096.png" alt="image-20220429140524096" /></p></li></ul></li><li><p>拥塞控制方法</p><ol><li>端到端拥塞控制<ul><li>没有来自网络的显示反馈<br />端系统根据延迟和丢失事件推断是否拥有拥塞</li><li>TCP 采用的方法</li></ul></li><li>网络辅助的拥塞控制<ul><li>路由器提供给端系统以反馈信息<ul><li>单个 bit 置位，显示有拥塞 (SNA,DECbit,TCP/IP ECN,ATM)</li><li>显式提供发送端可以采用的速率</li></ul></li></ul></li></ol></li><li><p>案例：</p><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220429142719285.png" alt="image-20220429142719285" /></li></ul></li></ul></blockquote><h3 id="7-tcp-拥塞"><a class="anchor" href="#7-tcp-拥塞">#</a> 7、TCP 拥塞</h3><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429151155134.png" alt="image-20220429151155134" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429153002979.png" alt="image-20220429153002979" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220429153216660.png" alt="image-20220429153216660" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429153325916.png" alt="image-20220429153325916" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429153512487.png" alt="image-20220429153512487" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220429153530821.png" alt="image-20220429153530821" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220429154210009.png" alt="image-20220429154210009" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429154259596.png" alt="image-20220429154259596" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429154435255.png" alt="image-20220429154435255" /></p></li><li><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429154752232.png" alt="image-20220429154752232" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220429154816391.png" alt="image-20220429154816391" /></p><p><img data-src="C:%5CUsers%5C24191%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220429155146589.png" alt="image-20220429155146589" /></p></li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络：自定向下》第二章：应用层</title>
      <link href="/2022/10/03/NetWork/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2022/10/03/NetWork/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="二-第二章应用层"><a class="anchor" href="#二-第二章应用层">#</a> 二。第二章：应用层</h1><h3 id="1-应用层原理"><a class="anchor" href="#1-应用层原理">#</a> 1. 应用层原理</h3><h4 id="1创建一个新的网络应用"><a class="anchor" href="#1创建一个新的网络应用">#</a> (1). 创建一个新的网络应用</h4><blockquote><ul><li>编程：<ul><li>在不同的端系统上运行</li><li>通过网络基础设施提供的服务应用进程彼此通信</li><li>如 Web：<ul><li>Web 服务器软件与浏览器软件通信</li></ul></li></ul></li><li>网络核心中没有应用层软件<ul><li>网络核心中没有应用层功能</li><li>网络核心只有再端系统上存在，快速网络应用开发和部署</li></ul></li></ul></blockquote><h4 id="2-网络应用的体系加购"><a class="anchor" href="#2-网络应用的体系加购">#</a> (2). 网络应用的体系加购</h4><blockquote><ul><li>客户 — 服务器模式 (C/S：client/server)<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220329144808351.png" alt="image-20220329144808351" /></li></ul></li><li>对等模式 (P2P：Peer to Peer)<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220329145612589.png" alt="image-20220329145612589" /></li></ul></li><li>混合体：客户 — 服务器和对等体系结构<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220329145627990.png" alt="image-20220329145627990" /></li></ul></li></ul></blockquote><h4 id="3进程通信"><a class="anchor" href="#3进程通信">#</a> (3). 进程通信</h4><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220329151200910.png" alt="image-20220329151200910" /></p></blockquote><h4 id="4分布式进程需要解决的问题"><a class="anchor" href="#4分布式进程需要解决的问题">#</a> (4). 分布式进程需要解决的问题</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220329152821549.png" alt="image-20220329152821549" /></p></li><li><p>标识进程，需要定义两种信息：</p><ol><li>主机的地址<ul><li>主机由其 IP 地址标识</li></ul></li><li>再目的主机中指定接收进程的标识符<ul><li>用目的端口号来进行标识，特定的服务端拥有特定的端口号</li></ul></li></ol></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330155321152.png" alt="image-20220330155321152" /></p></li><li><p>TCP 之上的套接字 (socket)<br /><img data-src="http://lgqimg.changzer.cn/image-20220330161252934.png" alt="image-20220330161252934" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330162301890.png" alt="image-20220330162301890" /></p></li><li><p>UDP 之上的套接字 (socket)</p><p><img data-src="http://lgqimg.changzer.cn/image-20220330162620053.png" alt="image-20220330162620053" /></p></li><li><p>套接字<br /><img data-src="http://lgqimg.changzer.cn/image-20220330163759101.png" alt="image-20220330163759101" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330164041356.png" alt="image-20220330164041356" /></p></li><li><p>应用层协议<br /><img data-src="http://lgqimg.changzer.cn/image-20220330164225194.png" alt="image-20220330164225194" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330164638424.png" alt="image-20220330164638424" /></p></li><li><p>Internet 传输层提供的服务</p><ul><li>TCP 服务<ul><li>可靠的传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现用塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐保证和安全</li><li>面向连接：要求再客户端进程和服务器进程之间建立连接</li></ul></li><li>UDP 服务<ul><li>不可靠数据传输</li><li>不能提供的服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接</li><li><img data-src="http://lgqimg.changzer.cn/image-20220330165720561.png" alt="image-20220330165720561" /></li></ul></li></ul></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330170336021.png" alt="image-20220330170336021" /></p></li></ul></blockquote><h3 id="2-web-and-http"><a class="anchor" href="#2-web-and-http">#</a> 2. Web and HTTP</h3><h4 id="1-术语"><a class="anchor" href="#1-术语">#</a> (1). 术语</h4><blockquote><ul><li>Web 页：由一些对象组成</li><li>对象可以是 HTM 文件，JPEG 图像、Java 小程序、声音剪辑文件等</li><li>Web 也含有一个基本的 HTML 文件，该基本文件、又包含若干对象的引用 (链接)</li><li>通过 URL 对每个对象进行引用<ul><li>访问协议，用户名，口令字，端口等</li></ul></li><li>URL 格式：<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220330214913519.png" alt="image-20220330214913519" /></li></ul></li></ul></blockquote><h4 id="2-http-概况"><a class="anchor" href="#2-http-概况">#</a> (2). HTTP 概况</h4><blockquote><ul><li><p>HTTP：超文本传输协议</p></li><li><p>Web 的应用层协议</p></li><li><p>客户 / 服务器模式</p><ul><li>客户：请求、接收和显示 Web 对象的浏览器</li><li>服务器：对请求进行响应，发送对象的 Web 服务器</li></ul></li><li><p>HTTP 1.0：RFC 1945</p></li><li><p>HTTP 1.1：RFC 2068</p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330220029553.png" alt="image-20220330220029553" /></p></li><li><p>HTTP 使用在 TCP 上</p></li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220330220339190.png" alt="image-20220330220339190" /></p></blockquote><h4 id="3-http-链接"><a class="anchor" href="#3-http-链接">#</a> (3). HTTP 链接</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220330220924628.png" alt="image-20220330220924628" /></p></li><li><p>响应时间模型<br /><img data-src="http://lgqimg.changzer.cn/image-20220407193744947.png" alt="image-20220407193744947" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220407194224093.png" alt="image-20220407194224093" /></p></li></ul></blockquote><h4 id="4http-报文格式"><a class="anchor" href="#4http-报文格式">#</a> (4).HTTP 报文格式</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220407194357632.png" alt="image-20220407194357632" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220407194652014.png" alt="image-20220407194652014" /></p></li><li><p>提交表单输入</p><ol><li><p>POST 方式：</p><ul><li>网页通常包括表单输入</li><li>包含实体主体 (entity body) 中的输入被提交到服务器</li></ul></li><li><p>URL 方式：</p><ul><li>方法：GET・</li><li>输入通过请求行的 URL 字段上载</li></ul></li><li><p>方法类型：</p><p><img data-src="http://lgqimg.changzer.cn/image-20220407195838765.png" alt="image-20220407195838765" /></p></li></ol></li><li><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220407200305547.png" alt="image-20220407200305547" /><br />TCP 无边界，需要进程自己去区分前部 message 和后部 message。</li><li>HTTP 响应状态码：<br /><img data-src="http://lgqimg.changzer.cn/image-20220407201555007.png" alt="image-20220407201555007" /></li></ul></li></ul></blockquote><h4 id="5-用户服务器状态cookies"><a class="anchor" href="#5-用户服务器状态cookies">#</a> (5). 用户 — 服务器状态：Cookies</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220407215325951.png" alt="image-20220407215325951" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220407215851561.png" alt="image-20220407215851561" /></p></li></ul></blockquote><h4 id="6web-缓存代理服务器"><a class="anchor" href="#6web-缓存代理服务器">#</a> (6).Web 缓存 (代理服务器)</h4><blockquote><ul><li><ul><li>目标：不访问原时服务器，就满足客户的请求</li><li>用户设置浏览器：通过缓存访问 Web</li><li>浏览器将所有的 HTTP 请求发给缓存<ul><li>在缓存中的对象：缓存直接返回对象</li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul></li><li><img data-src="http://lgqimg.changzer.cn/image-20220407221951845.png" alt="image-20220407221951845" /></li></ul></li><li><ul><li>缓存既是客户端又是服务端</li><li>通常缓存是由 ISP 安装 (大学、公司、居民区 ISP)</li><li>Web 缓存的好处：<ul><li>降低客户端请求响应时间</li><li>可以大大减少一个机构内部网络与 Internet 接入链路上的流量</li><li>互联网大量采用缓存：额可以使较弱的 ICP 也能够有效提供内容</li></ul></li></ul></li><li>非 Web 缓存：<br /><img data-src="http://lgqimg.changzer.cn/image-20220409114955328.png" alt="image-20220409114955328" /></li><li>Web 缓存：<br /><img data-src="http://lgqimg.changzer.cn/image-20220409120235938.png" alt="image-20220409120235938" /></li></ul></blockquote><h4 id="7-条件-get-方法"><a class="anchor" href="#7-条件-get-方法">#</a> (7). 条件 GET 方法</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220409120801163.png" alt="image-20220409120801163" /></li></ul></blockquote><h3 id="3-ftp文件传输协议"><a class="anchor" href="#3-ftp文件传输协议">#</a> 3. FTP：文件传输协议</h3><blockquote><ul><li><p>向远程主机上传输文件或从远程主机接收文件</p></li><li><p>客户 / 服务器模式</p><ul><li>客户端：发起传输的一方</li><li>服务器：远程主机</li></ul></li><li><p>ftp：RFC 959</p></li><li><p>ftp 服务器：端口号为 21</p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220409172523400.png" alt="image-20220409172523400" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220409172853927.png" alt="image-20220409172853927" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220409173600878.png" alt="image-20220409173600878" /></p></li></ul></blockquote><h3 id="4-email"><a class="anchor" href="#4-email">#</a> 4. Email</h3><blockquote><ol><li><p>3 个主要组成部分：</p><ul><li><p>用户代理</p><ul><li>又名 “邮件阅读器”</li><li>撰写、编辑和阅读邮件</li><li>如 outlook、Foxmail</li><li>输出和输入邮件保存在服务器上</li></ul></li><li><p>邮件服务器</p><ul><li>邮箱中管理和维护发送给用户的邮件</li><li>输出报文队列保持待发送邮件报文</li><li>邮件服务器之间的 SMTP 协议：发送 email 报文<ul><li>客户：发送方邮件服务器</li><li>服务器：接收端邮件服务器</li></ul></li></ul></li><li><p>简单邮件传输协议：SMTP</p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410143108077.png" alt="image-20220410143108077" /></p></li><li><p><img data-src="C:%5CUsers%5C24191%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220410143758639.png" alt="image-20220410143758639" /></p></li></ul></li></ul></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410133046345.png" alt="image-20220410133046345" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410145028517.png" alt="image-20220410145028517" /></p></li><li><p>POP3 协议<br /><img data-src="http://lgqimg.changzer.cn/image-20220410144433916.png" alt="image-20220410144433916" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410144621340.png" alt="image-20220410144621340" /></p></li></ol></blockquote><h3 id="5-dns"><a class="anchor" href="#5-dns">#</a> 5. DNS</h3><h4 id="1-dns-必要性"><a class="anchor" href="#1-dns-必要性">#</a> (1). DNS 必要性</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220410150903728.png" alt="image-20220410150903728" /></li><li>DNS 完成域名到 IP 地址的转化</li></ul></blockquote><h4 id="2-dns-总体思路和目标"><a class="anchor" href="#2-dns-总体思路和目标">#</a> (2). DNS 总体思路和目标</h4><blockquote><ol><li>DNS 的主要思路<ul><li>分层的、基于域的命名方式，用于解决设备命名问题</li><li>若干分布式的数据库存储域名和相应 IP 地址，完成名字到 IP 地址的方式，解决域名到 IP 地址的问题</li><li>运行在 UDP 之上端口号为 53 的应用服务，DNS 的实现具有事务性特点，需要即时转换</li><li>核心的 Internet 功能，但以应用层协议实现，在网络边缘实现<ul><li>网路边缘处理复杂性</li></ul></li></ul></li><li>DNS 主要目的<ul><li>实现主机名 - IP 地址的转换 (name/IP translate)</li><li>其他目的<ul><li>主机别名到规范名字的转化：Host aliasing</li><li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing</li><li>负载均衡：Load Distribution</li></ul></li></ul></li></ol></blockquote><h4 id="3-dns-域名结构"><a class="anchor" href="#3-dns-域名结构">#</a> (3). DNS 域名结构</h4><blockquote><ul><li>一个层面命名设备会有很多重名</li><li>DNS 采用层次树状结构的命名方法，以倒着的树来命名</li><li>Internet 跟被划分为几百个顶级域 (top lever domains)<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220410155911558.png" alt="image-20220410155911558" /></li></ul></li><li>每个 (子) 域下面课可划分为若干个子域 (subdomains)</li><li>树叶是主机</li><li>全球共有 13 个根名字服务器</li></ul></blockquote><h4 id="4-dns-的名字空间"><a class="anchor" href="#4-dns-的名字空间">#</a> (4). DNS 的名字空间</h4><blockquote><ul><li>域名<ul><li>从本域网上，直到树根</li><li>中间使用 “.” 间隔不同的级别</li><li>例如：<span class="exturl" data-url="aHR0cDovL3VzdGMuZWR1LmNu">ustc.edu.cn</span> <span class="exturl" data-url="aHR0cDovL2F1dG8udXN0cy5lZHUuY24=">auto.usts.edu.cn</span></li><li>域的域名：可以用于表示一个域</li><li>主机的域名：一个域上的一个主机</li></ul></li><li>域名的管理<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220410161313729.png" alt="image-20220410161313729" /></li></ul></li><li>域与物理网络无关<ul><li>域遵从组织界限，而不是物理网络<ul><li>一个域的主机可以不在一个网络上</li><li>一个网络的主机可以不在一个域</li></ul></li><li>域的划分是逻辑的，而不是物理的</li></ul></li></ul></blockquote><h4 id="5-域名-ip-地址转化"><a class="anchor" href="#5-域名-ip-地址转化">#</a> (5). 域名 - IP 地址转化</h4><blockquote><ul><li><p>一个名字服务器的问题</p><ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库</li></ul></li><li><p>区域</p><ul><li>区域的划分有区域管理者自己决定</li><li>将 DNS 名字空间划分为互不相交的区域，每个区域都是树的一部分</li><li>名字服务器：<ul><li>每个区域都有一个名字服务器；维护着它所管辖区域的权威信息</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul></li><li><p>权威 DNS 服务器：组织机构的 DNS 服务器，提供组织机构服务器 (如 Web 和 mail) 可访问的主机和 IP 之间的映射。组织机构可以选择实现自己维护或某个服务提供商来维护。</p></li><li><p>顶级域 (TLD) 服务器：<br /><img data-src="http://lgqimg.changzer.cn/image-20220410211022227.png" alt="image-20220410211022227" /></p></li><li><p>区域名字服务器维护资源记录<br /><img data-src="http://lgqimg.changzer.cn/image-20220410211152953.png" alt="image-20220410211152953" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220410211757078.png" alt="image-20220410211757078" /></p></li></ul></blockquote><h4 id="6-dns-的大致工作过程"><a class="anchor" href="#6-dns-的大致工作过程">#</a> (6). DNS 的大致工作过程</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410215330879.png" alt="image-20220410215330879" /></p></li><li><p>本地名字服务器 (Local Name Server)<br /><img data-src="http://lgqimg.changzer.cn/image-20220410215735041.png" alt="image-20220410215735041" /></p></li><li><p>名字服务器</p><ul><li><p>当本地名字服务器拥有本地缓存时，直接返回</p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410215820227.png" alt="image-20220410215820227" /></p></li></ul></li><li><p>递归查询</p><ul><li>当本地服务器没有缓存，不能解析时，会顺着上一层次的服务器进行查询，</li><li><img data-src="http://lgqimg.changzer.cn/image-20220410220447168.png" alt="image-20220410220447168" /></li></ul></li><li><p>迭代查询</p><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220410220546365.png" alt="image-20220410220546365" /></li></ul></li></ul></blockquote><h4 id="7-dns-协议-报文"><a class="anchor" href="#7-dns-协议-报文">#</a> (7). DNS 协议、报文</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220410220829143.png" alt="image-20220410220829143" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220410221015919.png" alt="image-20220410221015919" /></p></li><li><p>提高性能<br /><img data-src="http://lgqimg.changzer.cn/image-20220410221105628.png" alt="image-20220410221105628" /></p></li><li><p>维护问题：新增一个域<br /><img data-src="http://lgqimg.changzer.cn/image-20220410221135331.png" alt="image-20220410221135331" /></p></li><li><p>攻击 DNS<br /><img data-src="http://lgqimg.changzer.cn/image-20220410221318811.png" alt="image-20220410221318811" /></p></li></ul></blockquote><h3 id="6-p2p-应用"><a class="anchor" href="#6-p2p-应用">#</a> 6. P2P 应用</h3><h4 id="1-纯-p2p-架构"><a class="anchor" href="#1-纯-p2p-架构">#</a> (1). 纯 P2P 架构</h4><blockquote><p><img data-src="http://lgqimg.changzer.cn/image-20220412103342009.png" alt="image-20220412103342009" /></p></blockquote><h4 id="2文件分发时间"><a class="anchor" href="#2文件分发时间">#</a> (2). 文件分发时间</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412103756158.png" alt="image-20220412103756158" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412104136824.png" alt="image-20220412104136824" /></p></li></ul></blockquote><h4 id="3p2p-文件分发"><a class="anchor" href="#3p2p-文件分发">#</a> (3).P2P 文件分发</h4><blockquote><ul><li><p>结构化 (DHT) 和非结构化 P2P</p><ul><li><p>覆盖网络：Peer 节点之间有逻辑撒上的网络连接，有数据上的交流，有 “边”，有邻居的关系</p></li><li><p>结构化：Peer 节点构成的的覆盖网络是有序的，像树，环类似的有序结构</p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412132002881.png" alt="image-20220412132002881" /></p></li><li><p>每一份资源都由一组关键字进行标识。系统对其中的每一个关键字进行 Hash，根据 Hash 的结果决定此关键字对应的那条信息（即资源索引中的一项）由哪个用户负责储存。</p></li></ul></li><li><p>非结构化：Peer 节点构成的的覆盖网络是无序的</p><ul><li><p>集中化目录</p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412110606345.png" alt="image-20220412110606345" /></p><ul><li><p>问题：</p><ul><li>单点故障</li><li>性能瓶颈</li><li>侵犯版权</li></ul></li><li><p>完全分布式</p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412110942921.png" alt="image-20220412110942921" /></p><ul><li>Gnutella：<ul><li>在已有的 TCP 连接上发送查询报文</li><li>对等方转发查询报文</li><li>以反方向返回查询命中报文</li></ul></li></ul></li><li><p>混合体</p><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412111705950.png" alt="image-20220412111705950" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412111754652.png" alt="image-20220412111754652" /></p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>BitTorrent：(非结构化代表)</p><ul><li><p>文件被分为一个个块 256KB，再使用另一张由每个 1bit 组成的 map 来表示是否拥有文件块。一个 bit 中 1 表示拥有，0 表示没有</p></li><li><p>网络中的这些 peer 发送接收文件块，相互服务</p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412105030898.png" alt="image-20220412105030898" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412125219735.png" alt="image-20220412125219735" /></p></li><li><p><img data-src="http://lgqimg.changzer.cn/image-20220412130809889.png" alt="image-20220412130809889" /></p></li></ul></li></ul></blockquote><h4 id="4-cdn"><a class="anchor" href="#4-cdn">#</a> (4). CDN</h4><blockquote><ul><li><p><img data-src="http://lgqimg.changzer.cn/image-20220414210941322.png" alt="image-20220414210941322" /></p></li><li><p>流化服务</p><ul><li>将视频为许多的流组成，在看视频时，一边播放视频一边加载后面的内容，而不是将整个视频先下载，再观看。这样大大减少了用户的等待时间</li><li>DASH<br /><img data-src="http://lgqimg.changzer.cn/image-20220414211902293.png" alt="image-20220414211902293" /> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220414212610023.png" alt="image-20220414212610023" /></li></ul></li><li><p>CND (内容分发网)</p><ul><li><p>CDN 原理</p><p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b980c458efa74acdbb98948a84d29f51~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" /></p><p>上图假设一个内容提供商 NetCinema 雇佣了第三方内容提供商 KingCDN 来分发视频，在 NetCinema 的 Web 网页上，它的每个视频都被指派了一个 URL，如<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cCUzQSUyRiUyRnZpZGVvLm5ldGNpbmVtYS5jb20lMkYyMzQyNTIzNQ=="> video.netcinema.com/23425235</span> ，接下来将会发生图中的 6 个步骤：</p><ol><li><span class="exturl" data-url="aHR0cDovL3huLS13d3ctNHg1ZjM5NGZvNTRhbzVvLk5ldENpbmVtYS5jb20=">用户访问 www.NetCinema.com</span> , 并返回<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cCUzQSUyRiUyRnZpZGVvLm5ldGNpbmVtYS5jb20lMkYyMzQyNTIzNQ=="> video.netcinema.com/23425235</span> ；</li><li>用户点击<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cCUzQSUyRiUyRnZpZGVvLm5ldGNpbmVtYS5jb20lMkYyMzQyNTIzNQ=="> video.netcinema.com/23425235</span> 时，该用户的主机发送了一个对于 <span class="exturl" data-url="aHR0cDovL3ZpZGVvLm5ldGNpbmVtYS5jb20=">video.netcinema.com</span> 的 DNS 请求</li><li>用户的本地 DNS 服务器（LDNS）将该 DNS 请求中继到一个用户 NetCinema 的权限 DNS 服务器，该服务器看到是 video，就将 DNS 请求移交给 KingCDN，NetCinema 权威 DNS 服务器不返回 IP 地址，而是返回一个 KingCDN 域的主机名，如 <span class="exturl" data-url="aHR0cDovLzEyMy5raW5nY2RuLmNvbQ==">123.kingcdn.com</span></li><li>当 LDNS 拿到 <span class="exturl" data-url="aHR0cDovLzEyMy5raW5nY2RuLmNvbQ==">123.kingcdn.com</span> 时，就去请求 KingCDN 权威 DNS 服务器，KingCDN 权威 DNS 服务器这时返回的才是 KindCDN 服务器的 IP 地址</li><li>LDNS 把 KindCDN 服务器的 IP 地址返回给用户</li><li>用户拿到 KindCDN 服务器的 IP 地址后，就发起连接请求，并获取资源</li></ol></li><li><p>集群选择策略</p><ul><li>任何 CDN 的部署，其集群选择策略很重要，因为关乎到用户体验和网络性能，用户选择太远的集群，就会造成网络损耗，所以集群选择策略有两种：<ul><li>基于地理位置最为临近的。这种可以根据用户 IP 作出选择，比如基于商用地理位置数据库可以查询到用户的地理位置</li><li>基于当前流量条件选择最优。这种需要对集群和客户之间的时延和丢包性能做周期性的实时测量</li></ul></li></ul></li></ul></li></ul></blockquote><h4 id="5-tcp-套接字编程"><a class="anchor" href="#5-tcp-套接字编程">#</a> (5). TCP 套接字编程</h4><blockquote><ul><li>2 种传输层服务的 socket 编程<ul><li>TCP：可靠的、字节流服务</li><li>UDP：不可靠 (数据 UDP 数据报) 服务</li></ul></li><li>套接字：应用进程与端到端船速协议 (TCP 或 UDP) 之间的门户</li><li>TCP 服务：从一个进程向另一个进程可靠地传输字节流</li><li>工作过程：<br /><img data-src="http://lgqimg.changzer.cn/image-20220417160025382.png" alt="image-20220417160025382" /></li><li>两种结构体<ul><li><img data-src="http://lgqimg.changzer.cn/image-20220417160815547.png" alt="image-20220417160815547" /></li><li><img data-src="http://lgqimg.changzer.cn/image-20220417160838113.png" alt="image-20220417160838113" /></li></ul></li><li><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220417162204843.png" alt="image-20220417162204843" /> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220417162414038.png" alt="image-20220417162414038" /></li><li><img data-src="http://lgqimg.changzer.cn/image-20220417162513540.png" alt="image-20220417162513540" /> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220417162527933.png" alt="image-20220417162527933" /></li></ul></li></ul></blockquote><h4 id="6-udp-套接字编程"><a class="anchor" href="#6-udp-套接字编程">#</a> (6). UDP 套接字编程</h4><blockquote><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220417162726140.png" alt="image-20220417162726140" /></li><li><ul><li><img data-src="http://lgqimg.changzer.cn/image-20220417163109859.png" alt="image-20220417163109859" /> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220417163128298.png" alt="image-20220417163128298" /></li><li><img data-src="http://lgqimg.changzer.cn/image-20220417163149229.png" alt="image-20220417163149229" /> &gt; <img data-src="http://lgqimg.changzer.cn/image-20220417163210315.png" alt="image-20220417163210315" /></li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C#图解教程》阅读记忆点</title>
      <link href="/2022/10/03/%E3%80%8ACS%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9/"/>
      <url>/2022/10/03/%E3%80%8ACS%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="c图解教程阅读记忆点"><a class="anchor" href="#c图解教程阅读记忆点">#</a> 《C# 图解教程》阅读记忆点</h1><h2 id="一-数据类型"><a class="anchor" href="#一-数据类型">#</a> 一、数据类型</h2><h3 id="1-栈和堆"><a class="anchor" href="#1-栈和堆">#</a> 1. 栈和堆</h3><ol><li><p>栈<br /><img data-src="http://lgqimg.changzer.cn/image-20220913201351108.png" alt="image-20220913201351108" /></p></li><li><p>堆</p></li></ol><ul><li>堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象。堆中的内存能够以任意顺序存入和移除.</li><li>CLR 的自动垃圾收集器在判断出程序的代码不在访问某项数据时，会自动清除无主的堆对象.<br /><img data-src="http://lgqimg.changzer.cn/image-20220913201848664.png" alt="image-20220913201848664" /></li></ul><h3 id="2-值类型和引用类型"><a class="anchor" href="#2-值类型和引用类型">#</a> 2. 值类型和引用类型</h3><ul><li>C# 中数据分为值类型和引用类型。这两种类型的对象在内存中的存储方式不同</li><li>值类型只需要一段单独的内存，它总是位于堆中。</li><li>引用类型需要两段内存。第一段存储的实际数据总是存储在堆中。第二段的是一个引用，指向数据在堆中的从存放位置。<br /><img data-src="http://lgqimg.changzer.cn/image-20220913200717360.png" alt="image-20220913200717360" /></li><li><img data-src="http://lgqimg.changzer.cn/image-20220913205013024.png" alt="image-20220913205013024" /></li></ul><h3 id="3-嵌套快中的局部变量"><a class="anchor" href="#3-嵌套快中的局部变量">#</a> 3. 嵌套快中的局部变量</h3><ul><li>可以有任意数量的块，并且他们既可以是顺序的也可以是嵌套的。块可以嵌套到任何级别.</li><li>局部变量可以在嵌套块的内部声明，并且和所有的局部变量一样，他们的生存期和可见性仅局限与声明它们的块及其内嵌快.<br /><img data-src="http://lgqimg.changzer.cn/image-20220913204838044.png" alt="image-20220913204838044" /></li></ul><h2 id="二-方法"><a class="anchor" href="#二-方法">#</a> 二、方法</h2><h3 id="1-方法的引用参数和值参数"><a class="anchor" href="#1-方法的引用参数和值参数">#</a> 1. 方法的引用参数和值参数</h3><p>1. 值参数</p><ul><li><p>在方法使用值参数，在方法被调用时，系统在栈中为形参分配空间，并将实参的值赋值给形参。</p><pre><code class="language-c#">calss MyCalss&#123;    public int Val=20;&#125;calss Program&#123;    static void MyMethod(MyCalss f1,int f2)    &#123;        f1.Val=f1.Val+5;        f2=f2+5;        ConSole.WriteLine($&quot;f1.Val:&#123;f1.Val&#125;，f2:&#123;f2&#125;&quot;);    &#125;    static void Main()    &#123;        MyClass a1=new MyClass();        int a2 = 10;        MyMethod(a1,a2);        ConSole.WriteLine($&quot;a1.Val:&#123;a1.Val&#125;，a2:&#123;a2&#125;&quot;);    &#125;&#125;</code></pre><p>结果输出为</p><pre><code class="language-c#">f1.Val:&#123;25&#125;，f2:&#123;15&#125;a1.Val:&#123;25&#125;，a2:&#123;10&#125;</code></pre><p>结果表示：</p><ul><li>在方法被调用前，用作实参的变量 a2 已经在栈里面了。</li><li>在方法开始时，系统在栈中为形参分配空间，并从实参复制值。<ul><li>因为 a1 是引用类型的，所以引用被复制，结果实参和形参都引用堆中的同一数据。</li><li>因为 a2 是值类型的，所以值被复制，产生了一个独立的数据项。</li></ul></li><li>在方法的结尾，f2 和对象 f1 的字段都被加上了 5.<ul><li>方法执行后，形参从栈出弹出。</li><li>a2，值类型，它的值不受方法行为的影响。</li><li>a1，引用类型，但它的值被方法的行为改变了。</li></ul></li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220913213459760.png" alt="image-20220913213459760" /></p></li></ul><ol start="2"><li>引用参数</li></ol><ul><li><p>使用引用参数时，必须在方法的声明和调和中都使用<strong> ref</strong> 修饰符。</p></li><li><p>实参必须是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或<strong> null</strong>。</p></li><li><p>方法使用引用参数时，系统不会再栈上位形参分配内存，形参的参数名将作为实参变量名，指向相同的内存位置。</p></li></ul><pre><code class="language-c#">  calss MyCalss  &#123;      public int Val=20;  &#125;  calss Program  &#123;      static void MyMethod(ref MyCalss f1,ref int f2)      &#123;          f1.Val=f1.Val+5;          f2=f2+5;          ConSole.WriteLine($&quot;f1.Val:&#123;f1.Val&#125;，f2:&#123;f2&#125;&quot;);      &#125;      static void Main()      &#123;          MyClass a1=new MyClass();          int a2 = 10;          MyMethod(ref a1,ref a2);          ConSole.WriteLine($&quot;a1.Val:&#123;a1.Val&#125;，a2:&#123;a2&#125;&quot;);      &#125;  &#125;</code></pre><p>结果输出为：</p><pre><code class="language-c#">f1.Val:&#123;25&#125;，f2:&#123;15&#125;a1.Val:&#123;25&#125;，a2:&#123;15&#125;</code></pre><p>结果表示：</p><ul><li><p>在方法调用前，将要被用作实参的便改良 a1 和 a2 已经栈里了。</p></li><li><p>在方法的开始，形参名被设置位实参的别名。变量 a1 和 f1 引用相同的内存位置，a2 和 f2 引用相同的内存位置。</p></li><li><p>在方法的结束位置，f2 和 f1 的对象的字段都被加上了 5。</p></li><li><p>方法被执行后，形参的名称已经失效，但是值类型 a2 的值和引用类型 a1 所指向的对象的值都被方法内的行为改变了。</p><p><img data-src="http://lgqimg.changzer.cn/image-20220913215058035.png" alt="image-20220913215058035" /></p></li></ul><h3 id="2-引用类型作为值参数和引用参数"><a class="anchor" href="#2-引用类型作为值参数和引用参数">#</a> 2. 引用类型作为值参数和引用参数</h3><ol><li>引用类型作为值参数</li></ol><ul><li><p>将引用类型对象作为值参数传递如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且在方法调用结束后，新对象也将不复存在。</p><pre><code class="language-c#">class MyClass&#123;    public int Val = 20;&#125;class Program&#123;    static void ReFAsParameter(MyClass f1)    &#123;        f1.Val = 50;        Console.WriteLine($&quot;After member assignment：&#123;f1.Val&#125;&quot;);        f1=new MyClass();        Console.WriteLine($&quot;After new object cretion：&#123;f1.Val&#125;&quot;);    &#125;    static void Main()    &#123;        MyClass a1 = new MyClass();        Console.WriteLine($&quot;Before method call：&#123;a1.Val&#125;&quot;);        ReFAsParameter(a1);        Console.WriteLine($&quot;After method call：&#123;a1.Val&#125;&quot;);    &#125;&#125;</code></pre><p>结果为：</p><pre><code class="language-c#">Before method call：20After member assignment：50After new object cretion：20After method call：50</code></pre><p>结果表明：</p><ul><li><p>在方法开始时，实参和形参指向堆中的相同对象</p></li><li><p>在位对象成员赋值之后，他们仍指向堆中相同的对象</p></li><li><p>当方法分配新的对象并复制给形参时，方法外部的实参仍指向原时对象，而形参指向的是新对象</p></li><li><p>在方法调用之后，实参指向原时对象，形参和新对象都会消失</p><p><img data-src="http://lgqimg.changzer.cn/image-20220913221643242.png" alt="image-20220913221643242" /></p></li></ul></li></ul><ol start="2"><li>引用类型作为引用参数</li></ol><ul><li><p>将引用类型对象作为引用参数传递如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</p><pre><code class="language-c#">class MyClass&#123;    public int Val = 20;&#125;class Program&#123;    static void ReFAsParameter(ref MyClass f1)    &#123;        f1.Val = 50;        Console.WriteLine($&quot;After member assignment：&#123;f1.Val&#125;&quot;);        f1=new MyClass();        Console.WriteLine($&quot;After new object cretion：&#123;f1.Val&#125;&quot;);    &#125;    static void Main()    &#123;        MyClass a1 = new MyClass();        Console.WriteLine($&quot;Before method call：&#123;a1.Val&#125;&quot;);        ReFAsParameter(ref a1);        Console.WriteLine($&quot;After method call：&#123;a1.Val&#125;&quot;);    &#125;&#125;</code></pre><p>结果为：</p><pre><code class="language-c#">Before method call：20After member assignment：50After new object cretion：20After method call：20</code></pre><p>结果表示：</p><ul><li>在方法调用时，形参和实参指向堆中相同的对象。</li><li>对成员值的修改会同时影响到形参和实参。</li><li>当方法创建新的对象并赋值给形参时，形参和实参的引用都指向该新对象。</li><li>在方法结束后，实参指向在方法内创建的新对象<br /><img data-src="http://lgqimg.changzer.cn/image-20220913221820856.png" alt="image-20220913221820856" /></li></ul></li></ul><h3 id="3-输出参数"><a class="anchor" href="#3-输出参数">#</a> 3. 输出参数</h3><ol><li><p>输出参数用于从方法体内把数据传出到调用代码，他们的行为与引用参数类似。如同引用参数，输出参数有以下要求：</p><ul><li><p>必须声明和调用中都使用修饰符。输出参数的修饰符是<strong> out</strong>。</p></li><li><p>和引用参数相似，实参必须是变量，而不能是其他类型的表达式。因为方法需要内存位置来保存返回值。<br />例子：</p><pre><code class="language-C#">void MyMethod(out int val)&#123;&#125;...int y = 1;MyMethod(out y );</code></pre></li><li><p>输出参数的形参充当实参的别名。形参与实参都是同一块内存位置的名称。</p></li></ul></li><li><p>输出参数规则</p><ul><li>在方法内部，给输出参数赋值之后才能读取它。这意味着参数的初始值的无关的，而且没有必要再方法调用之前为实参赋值。</li><li>在方法内部，再方法返回之前，代码中每条可能的路径都必须为所有输出参数赋值。</li></ul></li></ol><h3 id="4-参数数组"><a class="anchor" href="#4-参数数组">#</a> 4. 参数数组</h3><ol><li><p>参数数组允许特定的零个或多个实参定义一个特定的形参。</p><ul><li><p>一个参数列表中只能有一个参数列表</p></li><li><p>如果有，它必须是列表中的最后一个</p></li><li><p>有参数数组表示的所有参数必须是同一个类型的</p></li><li><p>声明参数数组时，必须：</p><ul><li><p>在数据类型前使用<strong> params</strong> 修饰符</p></li><li><p>再数据后放置空的方括号</p><pre><code class="language-c#">void ListInit(params int[] inVals)&#123;&#125;;</code></pre></li></ul></li></ul></li><li><p>方法调用</p><ul><li><p><strong>可以使用一个用逗号分隔的相应数据类型的列表。<strong>被称为</strong>延伸式</strong>可在调用中使用独立的实参。</p><pre><code class="language-c#">ListInit(1,2,3,4);</code></pre><ul><li>在使用一个参数数组使用独立参数的调用时，编译器会执行：<ol><li>接受参数列表，用它们在堆中创建并初始化一个数组。</li><li>把数组的引用报存到栈中的形参里。</li><li>如果在对应形参数组的位置没有实参，编译器会创建一个有零个元素的数组使用</li></ol></li><li>如果数组参数是值类型，那么值被复制，实参在方法内部不受影响。如果数组参数是引用类型，那么引用被复制，实参引用的对象在方祛内部会受到影响。</li></ul></li><li><p><strong>一个相应数据类型的一维数组。</strong></p><pre><code class="language-c#">int[] intArrary=&#123;1,2,3,4&#125;;ListInit(intArrary);</code></pre></li></ul></li></ol><h3 id="5-ref局部变量和ref返回"><a class="anchor" href="#5-ref局部变量和ref返回">#</a> 5. <em>ref</em> 局部变量和<em> ref</em> 返回</h3><ol><li><p><strong>ref</strong> 局部变量</p><ul><li>ref 局部变量可以创建一个变量的别名，即引用的对象是值类型。</li><li>对任意一个变量的赋值都会反映到另一个变量上。因为两个的引用对象是相同的，即使是值类型也如此。</li></ul><pre><code class="language-c#">ref int y =ref x; //创建int变量x，别名为y</code></pre></li><li><p><strong>ref</strong> 返回</p><ul><li><p>使用 ref 返回，也要使用两次<strong> ref</strong> 关键字：</p><ul><li>一次是在方法的返回类型声明之前</li><li>另一次是在 return 关键字之后，被返回对象的变量名之前</li></ul><pre><code class="language-c#">private int Val;public ref int RefToVal(int val)&#123;    return ref Val;&#125;</code></pre></li></ul></li><li><p>限制</p><ul><li><p>返回值为 void 的方法无法声明为<strong> ref</strong> 返回方法</p></li><li><p><strong>ref return</strong> 表达式无法返回以下内容：</p><ul><li>空值</li><li>常量</li><li>枚举成员</li><li>类或结构体的属性</li><li>指向只读位置的指针</li></ul></li><li><p><strong>ref return</strong> 表达式只能指向原先就在调用域内的位置，或者字段。所以无法指向方法的局部变量。</p></li><li><p><strong>ref</strong> 局部变量只能被赋值一次。一旦被初始化，就无法指向不同的存储位置了。</p></li><li><p>即使将一个方法声明为<strong> ref</strong> 返回方法，如果在调用该方法时省略了<strong> ref</strong> 关键字，则返回的<br />将是值，而不是指向值的内存位置的指针。</p></li><li><p>如果将<strong> ref</strong> 局部变量作为常规的实际参数传递给其他方法，则该方法仅获取该变量的一个<br />副本。尽管<strong> ref</strong> 局部变量包含指向存储位置的指针，但是当以这种方式使用时，它会传递<br />值而不是引用。</p></li></ul></li></ol><h3 id="6-命名参数"><a class="anchor" href="#6-命名参数">#</a> 6. 命名参数</h3><ol><li><p>在调用方法时，形参的名字后面跟着冒号和实际的参数表达式或参数值。</p><pre><code class="language-c#">class MyClass&#123;    public int Calc(int a,int b,int c)&#123;return a+b+c&#125;;    static void Main()    &#123;        MyClass mc = new MyClass();        int ro mc.Calc(4,3,2 )//位置参数int r1 mc.Calc(4,b:3,c:2 )//位置参数和命名参数int r2 mc.Calc(4,c:2,b:3 )//交换了顺序int r3 mc.Calc(c:2,b:3,a:4);//所有都是命名参数int r4=mc.Calc(c:2,b:1+2,a:3+1);//命名参数表达式        Console.WriteLine(&quot;&#123;r0&#125;,&#123;r1&#125;,&#123;r2&#125;,&#123;r3&#125;,&#123;r4&#125;&quot;);    &#125;&#125;</code></pre><p>结果为</p><pre><code class="language-c#">14,14,14,14,14</code></pre><ul><li>命名参数对于自描述的程序来说很有用，因为我们可以在方法调用的时候显示哪个值赋给哪个形参。</li></ul></li></ol><h3 id="7-可选参数"><a class="anchor" href="#7-可选参数">#</a> 7. 可选参数</h3><ol><li><p>可选参数就是可以在调用方法的时候包含这个参数，也可以省略它。</p><pre><code class="language-c#">class MyClass&#123;    public int Clac(int a,int b=3)    &#123;        return a+b;    &#125;    static void Main()    &#123;        MyClass mc = new MyClass();        int r0=mc.Clac(5,6);        int r1=mc.Clac(5);        Console.WriteLine(&quot;&#123;r0&#125;,&#123;r1&#125;&quot;);    &#125;&#125;</code></pre><p>结果：</p><pre><code class="language-c#">11,8</code></pre><p>在代码中：</p><ul><li>形参 b 的默认值为 3。</li><li>如果调用方法的时候只有一个参数，方法会使用 3 作为的二个参数的初始值。</li></ul></li><li><p>可选参数的声明限制</p><ul><li>不是所有的参数类型都可以作为可选参数。<ul><li>只要值类型的默认值在编译的时候可以确定，就可以使用值类型作为可选类型</li><li>只有在默认值是 null 的时候，引用类型才可以用作可选参数<br /><img data-src="http://lgqimg.changzer.cn/image-20220915192549731.png" alt="" /></li></ul></li><li>所有必填参数必须在可选参数声明之前声明。如果有<strong> params</strong>，必须在所有可选参数之后声明。<img data-src="http://lgqimg.changzer.cn/image-20220915193352286.png" alt="image-20220915193352286" /></li></ul></li><li><p>可选参数省略：</p><ul><li>必须从可选参数列表的最后开始省略，一直到列表开头。</li><li>可以省略最后一个可选参数，或是最后 n 个可选参数，但是不饿能随意选择省略任意的可选参数，省略必须从最后开始。</li></ul></li></ol><h3 id="8-栈帧"><a class="anchor" href="#8-栈帧">#</a> 8. 栈帧</h3><ol><li>在调用方法的时候，内存从栈的顶部开始分配，保存和方法关联的一些数据项。这块内存叫作方法的栈帧 (stack frame)。<ul><li>栈帧保存内容：<ul><li>返回地址，也就是在方法退出的时候继续执行的位置。</li><li>分配内存的的参数，也就是方法的值参数，还可能是参数数组 (如果有的话)。</li><li>和方法调用相关的其他管理数据项。</li></ul></li><li>在方法调用时，整个栈帧都会压入栈。</li><li>在方法退出时，整个栈帧都会从栈上弹出。弹出栈帧有的时候也叫作栈展开 (unwind)。</li></ul></li></ol><h2 id="三-深入理解类"><a class="anchor" href="#三-深入理解类">#</a> 三、深入理解类</h2><h3 id="1-静态字段"><a class="anchor" href="#1-静态字段">#</a> 1. 静态字段</h3><ol><li><p>静态字段被类的所有实例共享，所有实例都访问同一内存位置因此，如果该内存位置的值被一个实例改变了，这种改变对所有的实例都可见。</p></li><li><p>使用<strong> static</strong> 修饰符将字段声明为静态。</p></li><li><p>从类外访问静态不需要使用类实例前缀可以使用类型和点运算符来访问静态成员，或是在该成员所属类中包含一个 using static 声明。</p><pre><code class="language-c#">using static System.Console; //在其他成员中包含WriteLine()class D&#123;    int Mem1;    static int Mem2;&#125;class C&#123;    static void Main()    &#123;        D.Mem2=5;    &#125;&#125;</code></pre></li><li><p>静态字段的生存期</p><ul><li>即使类没有实例，静态成员也存在并且可以访问。</li><li>如果静态字段有生存周期，那么会在使用该类的任何静态成员之前初始化该字段，但不一定在程序执行的开始就初始化。</li></ul></li></ol><h3 id="2-静态函数成员"><a class="anchor" href="#2-静态函数成员">#</a> 2. 静态函数成员</h3><ol><li><p>静态成员如同静态字段，独立于任何类实例。即使没有类实例，任然可以调用静态方法。</p></li><li><p>静态函数成员不能访问实例成员，但能访问其他静态成员。</p><pre><code class="language-c#">class X&#123;    static public int A;    static public void PrintValA()    &#123;        COnsole.WriteLine(&quot;Value of A:&#123;0&#125;&quot;,A);    &#125;&#125;class Program&#123;    static void Main()    &#123;        X.A=10;        X.PrintValA();    &#125;&#125;</code></pre><p>结果：</p><pre><code class="language-c#">Value of A:10</code></pre></li><li><p>其他静态成员类型<br /><img data-src="http://lgqimg.changzer.cn/image-20220915204231609.png" alt="image-20220915204231609" /></p></li></ol><h3 id="3-成员常量"><a class="anchor" href="#3-成员常量">#</a> 3. 成员常量</h3><ol><li><p>与局部常量类似，用于初始化成员常量的值在编译时必须时可计算的，而且通常时一个预定义简单类型或由他们组成表达式。</p><pre><code class="language-c#">class MyClass&#123;    const int IntVal1=100;    const int InVal2=2*IntVal1;  //IntVal1已经初始化&#125;</code></pre><pre><code class="language-c#">class MyClass&#123;    const int IntVal1;   //错误：必须初始化    IntVal1=100;         //错误：不允许赋值&#125;</code></pre><ul><li>C# 中没有全局常量。每个常量都必须声明在类型内。</li></ul></li><li><p>常量与静态量</p><ul><li>成员常量像静态量一样，不需要使用类的实例就可以访问。</li><li>与真正的静态两不同，常量没有自己的存储位置，而是在编译器时被编译器替换。</li></ul></li></ol><h3 id="4-属性"><a class="anchor" href="#4-属性">#</a> 4. 属性</h3><ol><li><p>属性时代表类实例或类中的数据项的成员。使用属性就像写入或读取一个字段，语法相同。</p><pre><code class="language-c#">MyClass mc = new MyClass();mc.Filed = 5;          //给字段赋值mc. MyProperty = 10;   //该属性赋值</code></pre></li><li><p>属性与字段类似，属性有以下特征：</p><ul><li>是命名的类成员。</li><li>有类型。</li><li>可以被赋值和读取。</li></ul><p>和字段不相同，属性是一个成员函数</p><ul><li>它不一定为数据存储分配内存</li><li>它执行代码</li></ul></li><li><p>属性是一组 (两个) 匹配的、命名的、成为访问器的方法。</p><ul><li><p><strong>set</strong> 访问器为属性赋值</p></li><li><p><strong>get</strong> 访问器从属性获取值</p><p>int 类型名称为 MyValue 的属性展示：</p><pre><code class="language-c#">int MyValue&#123;    set    &#123;        SetAccessorCode    &#125;    get    &#123;        GetAccessorCode    &#125;&#125;</code></pre></li></ul></li><li><p>属性声明和访问器</p><ul><li><p>set 和 get 访问器有预定义的语法和语义。可以把 set 访问器想象成一个方法，带有单一的参数，它 “设置” 属性的值。get 访问器没有参数并从属性返回一个值。</p></li><li><p><strong>set</strong> 访问器总是：</p><ul><li>拥有一个单独的、隐式的值参，名称为 Value，与属性的类型相同。</li><li>拥有一个返回类型 void。</li></ul></li><li><p><strong>get</strong> 访问器总是：</p><ul><li>没有参数。</li><li>拥有一个与属性类型相同的返回类型。</li></ul></li><li><p>属性结构声明 (访问器声明既没有显式的参数，也没有返回类型声明，已经隐含在属性中)<br /><img data-src="http://lgqimg.changzer.cn/image-20220915213845985.png" alt="image-20220915213845985" /></p><p>set 访问器中的隐式参数 value 是一个普通的值参。和其他值参一样，可以用它发送数据到方法体或访问器块。在块的内部，可以像普通变量那样使用 value, 包括对它赋值。</p></li><li><p>访问器的其他要点：</p><ul><li><strong>get</strong> 访问器的所有执行路径必须包含一条<strong> return</strong> 语句，它返回一个属性类型的值。</li><li>访问器<strong> set</strong> 和<strong> get</strong> 可以以任何顺序声明，并且，除了这两个访问器外，属性上不允许有其他方法。</li></ul></li></ul></li><li><p>属性示例</p><ul><li><p>属性本身没有任何存储。取而代之，访问器决定如何处理发送进来的数据。以及将什么数据发送出去。在这种情况下，属性使用一个名为 TheRealValue 的字段作为存储。</p></li><li><p><strong>set</strong> 访问器接受它的输入参数 value，并把它的值赋给字段 TheRealValue。</p></li><li><p><strong>get</strong> 访问器只是返回字段 TheRealValue 的值。</p><pre><code class="language-c#">class C1&#123;    private int theRealValue;       //字段：发配内存     public int MyValue    &#123;        set&#123;theRealValue=value;&#125;    //属性：未分配内存        get&#123;return theRealValue;&#125;    &#125;&#125;</code></pre></li></ul></li><li><p>使用属性</p><ul><li><p>要写入一个属性，在赋值语句的左边使用属性的名称。</p></li><li><p>要读取一个属性，把属性的名称用在表达式中。</p><pre><code class="language-c#">int MyValue      //属性声明&#123;    set&#123;……&#125;    get&#123;……&#125;&#125; MyValue=5;       //赋值：隐式调用set方法，MyValue为属性名称z=MyValue;       //表达式：隐式调用get方法</code></pre><ul><li>不能显示地调用访问器<pre><code class="language-c#">y =Myvalue.get();  //错误！不能显式调用t访问器MyValue.set(5);   //错误！不能显式调用set访问器</code></pre></li></ul></li></ul></li><li><p>属性和字段关联</p><ul><li>一个常见的方式是在类中将字段声明为<strong> private</strong> 以封装字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段常被称为后备字段或后备存储</li><li>属性访问器并不局限于对关联的后备字段传进传出数据。访问器 get 和 set 能执行任何计算，也可以不执行任何计算。唯一必需的行为是 get 访问器要返回一个属性类型的值。</li></ul></li><li><p>只读和只写属性</p><ol><li>要想不定义属性的某个访问器，可以忽略访问器的声明。<ul><li>只有 get 访问器的属性称为只读属性。只读属性能够安全地将一个数据项从类或类的实例中传出，而不必让调用者修改属性值。</li><li>只有 set 访问器的属性称为只写属性。只写属性很少见，因为它们几乎没有实际用途。如果想在赋值时触发一个副作用，应该使用方法而不是属性。</li><li>两个访问器中至少有一个必须定义，否则编译器会产生一条错误消息。</li></ul></li></ol></li><li><p>属性和共有字段</p><p>属性比共有字段更好</p><ul><li>属性是函数成员而不是数据成员，允许处理输入和输出，而共有字段不行。</li><li>属性可以只读或只写，而字段不行。</li><li>编译后的变量和编译后的属性语义不同。</li></ul></li><li><p>自动实现属性</p></li></ol><ul><li><p>因为属性经常被关联到后备字段，所以 C# 提供了自动实现属性 (automatically implemented property 或 auto-implemented property, 常简称为 “自动属性”，auto-property), 允许只声明属性而不声明后备字段。编译器会为你创建隐藏的后备字段，并且自动挂接到 gt 和 st 访问器上。</p></li><li><p>自动实现属性有以下要点：</p><ul><li>不声明后备字段 —— 编译器根据属性的类型分配存储。</li><li>不能提供访问器的方法体一它们必须被简单地声明为分号。get 担当简单的内存读，set 担当简单的写。但是，因为无法访问自动属性的方法体，所以在使用自动属性时调试代码通常会更加困难。</li></ul><pre><code class="language-c#">class C1&#123;    public int MyValue    &#123;        set;        get;    &#125;&#125;</code></pre></li></ul><ol start="11"><li><p>静态属性</p><ol><li>属性也可以声明为<strong> static</strong>。静态属性的访问器和所有静态成员一样，具有以下特点 “<ul><li>不能访问类的实例成员，但能被实例成员访问。</li><li>不管类是否有实例，他们都是存在的。</li><li>在类的内部，可以仅使用名称来引用静态属性。</li><li>在类的外部，可以通过类型或者使用<strong> using static</strong> 结构来引用静态属性。</li></ul></li></ol></li></ol><h3 id="5静态构造函数"><a class="anchor" href="#5静态构造函数">#</a> 5. 静态构造函数</h3><ol><li>构造函数也可以声明为 static。实例构造函数初始化类的每个新实例，而 static 构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。<ul><li>初始化类级别的项。<ul><li>在引用任何静态成员之前。</li><li>在创建类的任何实例之前。</li></ul></li><li>静态构造函数在以下方面与实例构造函数类似。<ul><li>静态构造函数的名称必须和类名相同。</li><li>构造函数不能返回值。</li></ul></li><li>静态构造函数在以下方面和实例构造函数不同。<ul><li>静态构造函数声明中使用<strong> static</strong> 关键字。</li><li>类只能由一个静态构造函数，而且不能带参数。</li><li>静态构造函数不能有修饰符。</li></ul></li></ul></li></ol><h3 id="6-对象初始化和析构函数"><a class="anchor" href="#6-对象初始化和析构函数">#</a> 6. 对象初始化和析构函数</h3><ol><li><p>对象初始化</p><ul><li>对象化初始化语法有两种。一种形式包括构造函数的参数列表，另一种不包括。</li><li>对象初始化内容：<ul><li>创建对象的代码能够访问要初始化的字段和属性。</li><li>初始化发生在构造方法执行之后，因此在构造方法中设置的值可能会在之后对象初始化中重置为相同或不同的值。</li></ul></li></ul><pre><code class="language-c#">public class Point&#123;    public int X=1;    public int y=2;    class Program    &#123;        static void Main()        &#123;            Point pt1=new Point();            Point pt2=new Point &#123;X=5,y=6&#125;;        &#125;    &#125;&#125;</code></pre></li><li><p>析构函数</p><p>析构函数 (destructor) 执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源是指通过 Win32API 获得的文件句柄，或非托管内存块。使用 NET 资源是无法得到它们的，因此如果坚持使用正 T 类，就不需要为类编写析构函数。</p></li></ol><h3 id="7-readonly修饰符"><a class="anchor" href="#7-readonly修饰符">#</a> 7. <strong>readonly</strong> 修饰符</h3><ol><li>字段使用<strong> readonly</strong> 修饰符声明，其作用类似于将字段声明为 const，一旦被设定就不能在改变。<ul><li>const 字段只能在字段的声明语句中初始化，而 readonly 字段可以在下列任意位置设置它的值。<ul><li>字段声明语句，类似于 const。</li><li>类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成。</li></ul></li><li>const 字段的值必须可在编译时决定，而 readonly 字段的值可以在运行时决定。这种自由性允许你在不同的环境或不同的构造函数中设置不同的值。</li><li>const 的行为总是静态的，而对于 readonly 字段以下两点是正确的。<ul><li>它可以是实例字段，也可以是静态字段。</li><li>它在内存中有存储位置。</li></ul></li></ul></li></ol><h3 id="8-索引器"><a class="anchor" href="#8-索引器">#</a> 8. 索引器</h3><ol><li><p>假设我们要定义一个类 Employee, 它带有 3 个 string 型字段，那么可以使用字段的名称方间们加 Main 中的代码所示</p><pre><code class="language-c#">class Employee&#123;    public string LastName;public string FirstName;public string CityofBirth;&#125;class Program&#123;    static void Main()    &#123;        Employee empl new Employee();empl.LastName=&quot;Doe&quot;;empl.FirstName:&quot;Jane&quot;;empi:cityofBirth &quot;Dallas&quot;;Console.WriteLine(&quot;(0)&quot;.empl:LastName);Console.WriteLine(&quot;(0)&quot;,empl.FirstName);Console.WriteLine(&quot;(0]&quot;.empl.CityofBirth);    &#125;&#125;</code></pre><p>然而有的时候，如果能使用索引访问它们将会很方便，好像该实例是字段的数组一样。这正是索引器能做的事。如果为类 Employee 写一个索引器。请注意没有使用点运算符，相反，索引器使用索引运算符，它由一对方括号和中间的索引组成。</p><pre><code class="language-c#">class Employee&#123;    public string LastName;public string FirstName;public string CityofBirth;&#125;class Program&#123;    static void Main()    &#123;        Employee empl new Employee();empl.LastName=&quot;Doe&quot;;empl.FirstName=&quot;Jane&quot;;empi:cityofBirth=&quot;Dallas&quot;;Console.WriteLine(&quot;(0)&quot;.empl[0]);Console.WriteLine(&quot;(0)&quot;,empl[1]);Console.WriteLine(&quot;(0]&quot;.empl[2]);    &#125;&#125;</code></pre></li><li><p>索引器是一组 get 和 set 访问器，与属性类似。</p><pre><code class="language-c#">string this [int index]&#123;    set    &#123;        SetAccessorCode    &#125;    get    &#123;        GetAccessorCode    &#125;&#125;</code></pre></li><li><p>索引器和属性</p><ul><li>和属性一样，索引器不用分配内存来存储</li><li>索引器和属性都主要被用来访问其他数据成员，它们与这些成员关联，并为他们提供获取和设置访问。<ul><li>属性同常表示单个数据成员。</li><li>索引器通常表示多个数据成员。</li></ul></li></ul><p>索引器属意事项</p><ul><li>和属性一样，索引器可以只有一个访问器，也可以两个都有。</li><li>索引器总是实例成员，因此不能被声明为 static。</li><li>和属性一样，实现 get 和 set 访问器的代码不一定要关联到某个字段或属性。这段代码可以做任何事情也可以什么也不用做，只要 get 访问器返回某个指定类型的值即可。</li></ul></li><li><p>索引器声明</p><ul><li><p>声明索引器注意点：</p><ul><li>索引器没有名称。在名称的位置是关键字 this</li><li>参数列表在方括号中间</li><li>参数列表中至少声明一个参数</li></ul><pre><code class="language-c#">ReturnType this [Type param1,……]&#123;    get    &#123;     &#125;    set    &#123;     &#125;</code></pre></li></ul></li><li><p>索引器的 set 和 get 访问器</p><ul><li><p>set 索引器：当索引器被用于赋值时，set 访问器被调用，并接受两项数据。set 访问器中的代码必须检查索引参数，以确定数据应该存往何处，然后保存它。</p><ul><li>一个名为 value 的隐式参数，其中持有要保存的数据。</li><li>一个或更多个索引参数，表示数据应该保存到哪里。</li></ul><p>set 访问器语义：</p><ul><li>它的返回类型为 void。</li><li>它使用的参数列表和索引器声明中的相同。</li><li>它有一个名为 value 的隐式参数，值参类型和索引器类型相同。</li></ul></li><li><p>get 索引器：当使用索引器获取值时，可以通过一个或多个索引参数调用 get 访问器。get 访问器中的代码必须检查索引参数，以确定数据应该存往何处，然后保存它。</p><p>get 访问器语义</p><ul><li>它的参数列表和索引器声明中的相同。</li><li>它返回与索引类型相同的值。</li></ul></li></ul></li><li><p>索引器示例</p><ul><li><pre><code class="language-c#">class Employee&#123;    public string LastName;                //调用字段0    public string FirstName;   //调用字段1    public string CityOfBirth;   //调用字段2     public string this[int index]   //索引器声明    &#123;        set   //set访问器声明        &#123;            switch(index)            &#123;                case 0:LastName=value;                    break;                case 1:FirstName=value;                    break;                case 2:CityOfBirth=value;                    break;                defaul:                    throw new ArgumentoutofRangeException(&quot;index&quot;);            &#125;        &#125;        get   //get访问器声明        &#123;            switch(index)            &#123;                case 0:return LastName;                case 1:return FirstName;                case 2:return CityOfBirth;                 default:                    throw new ArgumentoutofRangeException(&quot;index&quot;);            &#125;        &#125;    &#125;&#125;</code></pre></li><li><pre><code class="language-c#">class Class1&#123;    int Temp0;//私有字段    int Temp1;//私有字段    public int this[int index]    &#123;        get        &#123;            return(0==index)?Temp0:Temp1;&#125;        set        &#123;            if(0==index)                Temp0=value;            else                Temp1=value;        &#125;    &#125;&#125;class Example&#123;    static void Main()    &#123;        Class1 a=new Class1();         Console.WriteLine(&quot;Value -- T0:&#123;0&#125;,T1:&#123;1&#125;,a[0],a[1]&quot;);        a[0]=15;        a[1]=20;         Console.WriteLine(&quot;Value -- T0:&#123;,a[0]&#125;,T1:&#123;,a[1]&#125;&quot;);    &#125;&#125;</code></pre><p>结果为：</p><pre><code class="language-c#">Values -T0:0,T1:0Va1ues--T0:15,T1:20</code></pre></li></ul></li><li><p>索引器重载</p><ol><li><p>只要索引器的参数列表不同，类就可以有任意多个索引器。索引器类型不同是不够的。这叫作索引器重载，因为所有的索引器都有相同的 “名称”：this 访问引用。</p><pre><code class="language-c#">class MyClass&#123;    public string this [int index]&#123;        get&#123;&#125;        set&#123;&#125;    &#125;public string this [int index1,int index2]    &#123;        get&#123;&#125;        set&#123;&#125;    &#125;public int this [float index1]    &#123;        get&#123;&#125;        set&#123;&#125;    &#125;&#125;</code></pre></li></ol></li></ol><h3 id="9-访问器的访问修饰符"><a class="anchor" href="#9-访问器的访问修饰符">#</a> 9. 访问器的访问修饰符</h3><ol><li><p>默认情况，索引器和属性的两个访问器级别跟索引器和属性自身的访问级别相同。也可以为两个访问器分配不同的访问级别。</p><pre><code class="language-c#">class Person&#123;    public string Name&#123;get;private set;&#125;    public Person(string name)&#123;Name=name;&#125;&#125;class Program    [static public void Main()    &#123;        Person p=new Person(&quot;Capt.Ernest Evans&quot;);        Console.WriteLine(&quot;Person's name is &#123;P.Name&#125;&quot;);    &#125;</code></pre><p>输出结果为：</p><pre><code class="language-c#">Person's name is Capt.Ernest Evans</code></pre><p>在上面的代码中，可以从类的外部读取属性，但是只能在类的内部设置它。</p></li><li><p>访问器的修饰符限制条件：</p><ul><li>仅当成员 (属性和索引器) 既有 get 访问器也有 set 访问器，其访问器才能访问修饰符。</li><li>虽然两个访问器都必须出现，但它们中只能有一个有访问修饰符。</li><li>访问器的访问修饰符的显示不惜比成员的访问级别更加严格。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220917195545721.png" alt="image-20220917195545721" /></p></li></ol><h3 id="10-分部类和分布类型"><a class="anchor" href="#10-分部类和分布类型">#</a> 10. 分部类和分布类型</h3><ol><li><p>类的声明可以分割成几个分布类的声明</p><ul><li>每个分部类的声明都含有一些类成员的声明。</li><li>类的分部类声明可以在同一一个文件中也可以在不同文件中。</li><li>每个分部类声明必须被标注为 partial class, 而不是单独的关键字 class。分部类声明看起来和普通类声明相同，只是增加了类型修饰符 partial。</li></ul><pre><code class="language-c#">partial clas5 MyPartClass//类名称与下面的相同&#123;memberi declaration;member2 declaration;&#125;类型修饰符partial class MyPartClass//类名称与上西的相同&#123;    member3 declaration;member4 declaration;&#125;</code></pre></li><li><p>类型修饰符 partial 不是关键字，所以在其他上下文中，可以在程序中把它用作标识符。但直接用在关键字 class、struct 或 interface 之前时，它表示分部类型。</p></li><li><p>分部类型还有局部结构和局部接口。</p></li></ol><h3 id="11-分部方法"><a class="anchor" href="#11-分部方法">#</a> 11. 分部方法</h3><ol><li>分部方法是声明在分部类中不同部分的方法。分部方法的不同部分可以声明在分部类的不同<br />部分中，也可以声明在同一个部分中。分部方法的两个部分如下。<ul><li>定义分部方法声明。<ul><li>给出签名和返回类型。</li><li>声明的实现部分只是一个分号。</li></ul></li><li>实现分部方法声明。<ul><li>给出签名和返回类型。</li><li>以普通的语句块形式实现。</li></ul></li></ul></li><li>分部方法需要了解的内容<ul><li>定义声明和实现声明的签名和返回类型必须匹配。签名和返回类型有如下特征：<ul><li>返回类型必须是 void。</li><li>签名不能包括访问修饰符，这使分部方法是隐式私有的。</li><li>参数列表不能包含 out 参数。</li><li>在定义声明和实现声明中都必须包含上下文关键字 partial, 并且直接放在关键字 void 之前。</li></ul></li><li>可以有定义部分而没有实现部分。在这种情况下，编译器把方法的声明以及方法内部任何对方法的调用都移除。不能只有分部方法的实现部分而没有定义部分</li></ul></li></ol><h2 id="四-类的继承"><a class="anchor" href="#四-类的继承">#</a> 四、类的继承</h2><h3 id="1-屏蔽基类的成员"><a class="anchor" href="#1-屏蔽基类的成员">#</a> 1. 屏蔽基类的成员</h3><ol><li>虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏薇 (mask) 基类成员。这是继承的主要功能之一，非常实用。<ul><li>要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称。</li><li>通过在派生类中声明新的带有相同签名的函数成员，可以屏蔽继承的函数成员。请记住，签名由名称和参数列表组成，不包括返回类型。</li><li>要让编译器知道你在故意屏蔽继承的成员，可使用 new 修饰符。否则，程序可以成功编译，但编译器会警告你隐藏了一个继承的成员。</li><li>也可以屏蔽静态成员。</li></ul></li></ol><h3 id="2-虚方法和覆写方法"><a class="anchor" href="#2-虚方法和覆写方法">#</a> 2. 虚方法和覆写方法</h3><ol><li>虚方法可以使基类的引用访问 “升至” 派生类内。可以使用基类引用调用派上类的方法，只需满足下面的条件。<ul><li>派生类的方法和基类的方法有相同的签名和返回类型。</li><li>基类的方法使用 virtual 标注。</li><li>派生类的方法使用 override 标注。</li></ul></li><li>其他关于 virtual 和 override 修饰符的重要信息如下。<ul><li>覆写和被覆写的方法必须有相同的可访问性。例如，这种情况是不可以的：被覆写的方<br />法是 private 的，而覆写方法是 public 的。</li><li>不能覆写 static 方法或非虚方法。</li><li>方法、属性和索引器，以及另一种成员类型一事件，都可以被声明为 virtual 和 override.</li></ul></li></ol><h3 id="3-构造函数的执行"><a class="anchor" href="#3-构造函数的执行">#</a> 3. 构造函数的执行</h3><ol><li><p>要创建对象的基类部分，需要隐式调用基类的某个构造函数。继承层次链中的每个类在执行它自己的构造函数体之前执行它的基类构造函数。<br /><img data-src="http://lgqimg.changzer.cn/image-20220917205056606.png" alt="image-20220917205056606" /></p></li><li><p>默认情况下，在构造对象时，将调用基类的无参数构造函数。但构造函数可以重载，所以基类可能有一个以上的构造函数。如果希望派生类使用一个指定的基类构造函数而不是无参数构造函数，必须在构造函数初始化语句中指定它。<br />有两种形式的构造函数初始化语句。</p><ul><li>第一种形式使用关键字 base 并指明使用哪一个基类构造函数。</li><li>第二种形式使用关键字 this 并指明应该使用当前类的哪一个构造函数。</li></ul><p>基类构造函数初始化语句放在冒号后面，跟在类的构造函数声明的参数列表后面。构造函数始化语句由关键字 base 和要调用的基类构造函数的参数列表组成。</p></li></ol><h3 id="4-类访问修饰符"><a class="anchor" href="#4-类访问修饰符">#</a> 4. 类访问修饰符</h3><p>可访问（accessible) 有时也称为可见（visible), 它们可以互换使用。类的可访问性有两个级别：public 和 internal。</p><ul><li><p>标记为 pub1ic 的类可以被系统内任何程序集中的代码访问。要使一个类对其他程序集可见，使用 pub1ic 访问修饰符，如下所示：</p><pre><code class="language-c#">public class MyBaseClass&#123;    ……&#125;</code></pre></li><li><p>标记为 internal 的类只能被它自已所在的程序集内的类看到。</p><ul><li>这是默认的可访问级别，所以，. 除非在类的声明中显式地指定修饰符 pub1ic, 否则程<br />序集外部的代码不能访问该类。</li><li>可以使用 internal 访问修饰符显式地声明一个类为内部的。</li></ul><pre><code class="language-c#">internal class MyBaseClass&#123;    ……&#125;</code></pre></li></ul><h3 id="5-修饰符的可访问性"><a class="anchor" href="#5-修饰符的可访问性">#</a> 5. 修饰符的可访问性</h3><ol><li>public 访问级别是限制最少的。所有的类，包括程序集内部的类和外部的类都可以自由地访问成员。</li><li>private 访问级别是限制最严格的。private 类成员只能被它自己的类的成员访问。它不能被其他的类访问，包括继承它的类。然而，private 成员能被嵌套在它的类中的类成员访问。</li><li>protected 访问级别如同 private 访问级别，但它允许派生自该类的类访问该成员。注意，即使程序集外部继承该类的类也能访问该成员。</li><li>标记为 internal 的成员对程序集内部的所有类可见，但对程序集外部的类不可见。</li><li>标记为 protected internal 的成员对所有继承该类的类以及程序集内部的所有类可见。注意，允许访问的集合是 protected 修饰符允许访问的类的集合加上 internal 修饰符允许访问的类的集合。注意，这是 protected 和 internal 的并集，不是交集。</li></ol><p><img data-src="http://lgqimg.changzer.cn/image-20220917210313358.png" alt="image-20220917210313358" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20220917210349590.png" alt="image-20220917210349590" /></p><h3 id="6-抽象成员"><a class="anchor" href="#6-抽象成员">#</a> 6. 抽象成员</h3><ol><li><p>抽象成员是指设计为被覆写的函数成员。抽象成员有以下特征。</p><ul><li>必须是一个函数成员。也就是说，字段和常量不能为抽象成员。</li><li>必须用 abstract 修饰符标记。</li><li>不能有实现代码块。抽象成员的代码用分号表示。</li></ul></li><li><p>抽象成员只可以在抽象类中声明，下一节中会讨论。一共有 4 种类型的成员可以声明为抽象的：</p><ul><li>方法；</li><li>属性；</li><li>事件；</li><li>索引器。</li></ul><p>关于抽象成员的其他重要事项如下。</p><ul><li>尽管抽象成员必须在派生类中用相应的成员覆写，但不能把 virtual 修饰符附加到 abstract 修饰符。</li><li>类似于虚成员，派生类中抽象成员的实现必须指定 override 修饰符。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220917210712470.png" alt="image-20220917210712470" /></p></li></ol><h3 id="7-静态类"><a class="anchor" href="#7-静态类">#</a> 7. 静态类</h3><ol><li>静态类中所有成员都是静态的。静态类用于存放不受实例数据影响的数据和函数。静态类的一个常见用途可能是创建一个包含一组数学方法和值的数学库。<ul><li>类本身必须标记为 static。</li><li>类的所有成员必须是静态的。</li><li>类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例。</li><li>静态类是隐式密封的，也就是说，不能继承静态类。</li></ul></li></ol><h2 id="五-运算符"><a class="anchor" href="#五-运算符">#</a> 五、运算符</h2><h3 id="1-运算符重载"><a class="anchor" href="#1-运算符重载">#</a> 1. 运算符重载</h3><ol><li><p>运算符重载允许你定义 C# 运算符应该如何操作自定义类型的操作数。</p><ul><li>运算符重载只能用于类和结构</li><li>为类或结构重载一个运算符 x, 可以声明一个名称为 operator× 的方法并实现它的行为<ul><li>一元运算符的重载方法带一个单独的 class 或 struct 类型的参数。</li><li>二元运算符的重载方法带两个参数，其中至少有一个必须是 class 或 struct 类型。</li></ul></li><li>声明必须同时使用 static 和 public 的修饰符；</li><li>运算符必须是要操作的类或结构的成员。</li></ul></li><li><p>运算符重载限制</p><p><img data-src="http://lgqimg.changzer.cn/image-20220917212812990.png" alt="image-20220917212812990" /></p><ul><li>运算符重载不能：<ul><li>创建新运算符；</li><li>改变运算符的语法；</li><li>重新定义运算符如何处理预定义类型；</li><li>改变运算符的优先级或结合性。</li></ul></li></ul></li></ol><h3 id="2-typeof运算符和-nameof-运算符"><a class="anchor" href="#2-typeof运算符和-nameof-运算符">#</a> 2. <strong>typeof</strong> 运算符和 nameof 运算符</h3><ol><li><p>typeof 运算符返回作为其参数的任何类型的 System.Type 对象。通过这个对象，可以了解类型的特征。</p><p>typeof 运算符是一元运算符。</p></li><li><p>nameof 运算符返回一个表示传人参数的字符串。</p></li></ol><h2 id="六-委托"><a class="anchor" href="#六-委托">#</a> 六、委托</h2><h3 id="1委托概述"><a class="anchor" href="#1委托概述">#</a> 1. 委托概述</h3><p>委托和类一样，是一种用户用户自定义类型。但类表示的是数据和方法的集合，而委托则持有一个或多个方法，以及一系列预定义操作。</p><ul><li>声明一个委托类型。委托声明看上去和方法声明类似，只是没有实现块。</li><li>使用该委托类型声明一个委托变量。</li><li>创建一个委托类型的对象，并把它赋值给委托变量。新的委托对象包含指向某个方法的引用，这个方法的签名和返回类型必须跟第一步中定义的委托类型一致。</li><li>可以选择为委托对象添加其他方法。这些方法的签名和返回类型必须与第一部中定义的委托类型相同。</li><li>可以像调用方法一样调用委托。在调用委托的时候，其包含的每一个方法都会被执行。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220921194159165.png" alt="image-20220921194159165" /></p><ul><li><p>方法的列表称为调用列表</p></li><li><p>委托持有的方法可以来自任何类或结构，只要它们在下面两方面匹配：</p><ul><li>委托的返回类型；</li><li>委托的签名 (包括 ref 和 out 修饰符)</li></ul></li><li><p>在调用列表中的方法可以是实例方法也可以是静态方法。</p></li><li><p>在调用委托的时候，会执行其调用列表中的所有方法。</p><p><img data-src="http://lgqimg.changzer.cn/image-20220921195045455.png" alt="image-20220921195045455" /></p></li></ul><h3 id="2-声明委托类型"><a class="anchor" href="#2-声明委托类型">#</a> 2. 声明委托类型</h3><ol><li><p>委托类型必须在创建变量以及类型的对象之前声明。</p><pre><code class="language-c#">delegate void MyDel(int x);</code></pre><p>委托类型声明在两个方面与方法不同。委托类型声明：</p><ul><li>以 delegate 关键字开头；</li><li>没有方法主体</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220921195755345.png" alt="image-20220921195755345" /></p></li><li><p>委托是引用类型，因此有引用和对象。委托类型的变量声明：</p><pre><code class="language-c#">MyDel delVar;</code></pre></li><li><p>创建委托对象的方式有两种。</p><ul><li><p>第一种是使用 new 运算符的对象创建表达式。new 运算符的操作数组成如下。</p><ul><li>委托类型名。</li><li>一组圆括号，其中包含作为调用列表中第一个成员方法的名称。该方法可以是实例方法或静态方法。</li></ul><pre><code class="language-c#">delVar=new MyDel(myInsObj.MyM1);dVar=new MyDel(SClass.OtherM2);</code></pre></li><li><p>还可以使用快捷语法，它仅由方法说明符构成。这种快捷语法能够工作是因为方法名称和其相应的委托类型之间存在隐式转换。</p><pre><code class="language-c#">delVar =MyInsObj.MyM1;dVar =SClass.OtherM2;</code></pre><p>除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表。</p></li></ul></li><li><p>由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的引用。旧的委托对象会被垃圾回收器回收。</p></li><li><p>委托可以使用额外的运算符来 “组合”。这个运算会创建一个新的委托，并调用列表连接了作为操作数的两个委托的调用列表副本。</p><pre><code class="language-c#">MyDel delA=myInstObj.MyM1;MyDel delB=SClass.OtherM2;MyDel delC=delA + delB;</code></pre><p><strong>委托是恒定的。委托对象被创建后不能在被改变。</strong></p></li></ol><h3 id="3-委托的添加方法和移除方法"><a class="anchor" href="#3-委托的添加方法和移除方法">#</a> 3. 委托的添加方法和移除方法</h3><ol><li><ol><li>C# 可以为委托添加和移除方法，即使用 **+=<strong> 和</strong> -=** 运算符。</li></ol><ul><li><p>添加方法</p><pre><code class="language-C#">MyDel delVar =new inst.MyM1;decVar +=SCL.m3;delVar +=X.Act;</code></pre><p><img data-src="http://lgqimg.changzer.cn/image-20220921204834993.png" alt="image-20220921204834993" /></p><p>在使用 += 运算符时，实际发生的是创建了一个新的委托，其调用列表是左边的委托加上右边的方法的组合。然后将这个新的委托赋值给 delVar。每次添加都会在调用列表创建一个新的元素。</p></li><li><p>移除方法</p><pre><code class="language-c#">decVar -=SCL.m3;</code></pre><p><img data-src="http://lgqimg.changzer.cn/image-20220921205038288.png" alt="image-20220921205038288" /></p><p>与为委托添加方法一样，其实是创建了一个新的委托。新的委托是旧的委托的副本 — 只是没有被有了已经被移除的方法。</p><p>移除委托需要记住的一些事项，</p><ul><li>如果在调用列表中的方法有多个实例，**-=** 运算符将从列表的最后开始索引，并且移除第一个与方法匹配的实例。</li><li>试图删除委托中不存在的方法将无效。</li><li>试图调用空委托会抛出异常。可以通过将委托和 null 进行比较来判断委托的调用列表是否为空。如果调用列表为空，则委托是 null。</li></ul></li></ul></li></ol><h3 id="4-委托的调用"><a class="anchor" href="#4-委托的调用">#</a> 4. 委托的调用</h3><ol><li><p>委托调用的重要事项。</p><ul><li>可以通过两种方式调用委托。一种是调用方法一样调用委托，另一种是使用委托的 Invoke 方法。</li><li>可以将参数放在调用的圆括号内。用于调用委托的参数作用于调用列表中的每个方法 (除非其中一个参数是输出参数)。</li><li>调用时委托不能为空 (null), 否则将引发异常。可以使用 if 语句进行检查，也可以使用空条件运算符和 Invoke 方法。</li></ul><pre><code class="language-c#">MyDel delVar inst.MyM1;delvar+=SC1.m3;delvar+=X.Act;if (delVar !=null)&#123;    de1var(55);//调用委托&#125;delVar?.Invoke(65);//使用Invoke和空条件运算符</code></pre><p><img data-src="http://lgqimg.changzer.cn/image-20220921211205874.png" alt="image-20220921211205874" /></p></li><li><p>调用带返回值的委托<br />如果委托有返回值并且在调用列表中有一个以上的方法，会放生下面的 qingkuang</p><ul><li>调用列表中最后一个方法返回的值就是委托调用返回的值。</li><li>调用列表中所有其他方法的返回值都会被忽略。</li></ul><pre><code class="language-c#">delegate int MyDel();//声明有返回位的方法class MyClass&#123;    int IntValue 5;public int Add2()&#123;IntValue +2;return IntValue;&#125;public int Add3()&#123;IntValue +3;return IntValue;&#125;&#125;class Program&#123;     MyClass mc new Myclass();MyDel mDel mc.Add2;//创建并初始化委托mDel +mc.Add3;//增加方法mDel +mc.Add2;//增加方法Console.WriteLine($&quot;Value:mDel()&#125;&quot;);//调用委托并使用返回值    &#125;&#125;</code></pre><p>输出结果为：</p><pre><code class="language-c#">12</code></pre><p><img data-src="http://lgqimg.changzer.cn/image-20220927194547963.png" alt="image-20220927194547963" /></p></li><li><p>调用带引用参数的委托<br />如果委托带有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变。</p><pre><code class="language-C#">delegate int MyDel(ref int x);//声明有返回位的方法class MyClass&#123;    int IntValue 5;    public int Add2(ref int x)&#123;x += 2;&#125;public int Add3(ref int x)&#123;x += 3;&#125;static void Main()    &#123;        MyClass mc new Myclass();MyDel mDel mc.Add2;mDel +mc.Add3;mDel +mc.Add2;    int x = 5;    mDel(ref x);Console.WriteLine($&quot;Value:&#123;x&#125;&quot;);    &#125;&#125;</code></pre><p>输出结果为:</p><pre><code class="language-c#">12</code></pre><p><img data-src="F:%5C%E7%AC%94%E8%AE%B0%5Cimage-20220927195618833.png" alt="image-20220927195618833" /></p></li></ol><h3 id="5-匿名方法"><a class="anchor" href="#5-匿名方法">#</a> 5. 匿名方法</h3><ol><li><p>匿名方法让我们无须使用独立的具名方法。匿名方法 (anonymous method) 是在实例化委托时内联 (inline) 声明的方法。例如，图 14-l2<br /> 演示了同一个类的两个版本。左边的版本声明并使用了一个名为 Add20 的方法。右边的版本使用匿名方法。没有底色的代码部分对于两个版本是一样的。<br /><img data-src="http://lgqimg.changzer.cn/image-20220927200005598.png" alt="image-20220927200005598" /><br /> 输出结果为：</p><pre><code class="language-c#">2526</code></pre><ul><li><p>使用匿名方法</p><ul><li>声明委托变量作为初始化表达方法。</li><li>组合委托时在赋值语句的右边。</li><li>为委托增加事件时在赋值语句的右边。</li></ul><p>匿名方法表达式的语法</p><ul><li>delegate 类型关键字</li><li>参数列表，如果语句块没有使用任何参数列表则可以省略</li><li>语句块，它包含了匿名方法的代码</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220927200408061.png" alt="image-20220927200408061" /></p><ol><li><p>返回类型<br />匿名方法不会显式声明返回值。然而，实现代码本身的行为必须通过返回一个与委托的返回类型相同的值来匹配委托的返回类型。如果委托有 Void 类型的返回值，匿名方法就不能返回值。</p></li><li><p>参数<br />除了数组参数，匿名方法的参数列表必须在如下 3 方面与委托匹配：・</p><ul><li>参数数量；</li><li>参数类型及位置；</li><li>修饰符。</li></ul><p>可以通过使圆括号为空或省略圆括号来简化匿名方法的参数列表，但必须满足以下两个条件：</p><ul><li>委托的参数列表不包含任何 out 参数；</li><li>匿名方法不使用任何参数。</li></ul></li><li><p>params 参数</p><p>如果委托声明的参数列表包含了 params 参数，那么匿名方法的参数列表将忽略 params 关键字。</p><ul><li>委托类型声明指定最后一个参数为 params 类型的参数；</li><li>然而，匿名方法参数列表必须省略 params 关键字。</li></ul></li></ol></li></ul></li><li><p>变量和参数的作用域<br />参数以及声明在匿名方法内部的局部变量的作用域限制在实现代码的主题之内。<br /><img data-src="http://lgqimg.changzer.cn/image-20220927202320950.png" alt="image-20220927202320950" /></p><ul><li><p>外部变量<br />与委托的具名方法不同，匿名方法可以访问它们外围作用域的局部变量和环境。</p><ul><li>外围作用域的变量叫做外部变量 (outer variable)。</li><li>用在匿名方法实现代码中的外部变量称为方法捕获。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220927211036778.png" alt="image-20220927211036778" /></p></li><li><p>捕获变量的生命周期的拓展<br />只要捕获方法是委托的一部分，即使变量已经离开了作用域，捕获的外部变量也会一直有效。</p></li></ul></li></ol><h3 id="6-lambda-表达式"><a class="anchor" href="#6-lambda-表达式">#</a> 6. Lambda 表达式</h3><p>使用 Lambda 表达式来代替匿名方法。<br />匿名方法转换为 Lambda 表达式：</p><ul><li>删除 delegate 关键字；</li><li>在参数列表和匿名方法主体之间放置 Lambda 运算符 =&gt;。Lamnda 运算符读作 “goes to”。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220927212306117.png" alt="image-20220927212306117" /></p><p>编译器可以从 lambda 表达式中推断更多信息。</p><ul><li>编译器还可以从委托的声明中知道委托的参数的类型，因此 lambda 表达式允许省略类型参数。<ul><li>带有类型的参数列表被称为显式类型。</li><li>省略类型的参数列表被称为隐式类型。</li><li>如果只有一个隐式类型参数，我们可以省略两端的圆括号。</li><li>最后，Lambda 表达式允许表达式的主体是语句块或表达式。如果语句块包含了一个返回语句，我们可以将语句替换为 return 关键字后的表达式。</li></ul></li></ul><p>Lambda 表达式的参数列表要点：</p><ul><li>Lambda 表达式参数列表中的参数必须要在参数数量、类型和位置上与委托相同。</li><li>表达式的参数列表中的参数不一定需要包含类型 (隐式类型)，除非委托有 ref 或 out 参数 — 此时必须注明类型 (显式类型)。</li><li>如果只有一个参数，并且是隐式类型的，则两端的圆括号可以省略，否则必须有括号。</li><li>如果没有参数，必须使用一组空的圆括号。</li></ul><h2 id="七-事件"><a class="anchor" href="#七-事件">#</a> 七、事件</h2><h3 id="1-发布者和订阅者"><a class="anchor" href="#1-发布者和订阅者">#</a> 1. 发布者和订阅者</h3><ol><li><p>发布者 / 订阅者模式（publisher/subscriber pattern) 可以满足这种需求。在这种模式中，发布者类定义了一系列程序的其他部分可能感兴趣的事件。其他类可以 “注册”，以便在这些事件发生时收到发布者的通知。这些订阅者类通过向发布者提供一个方法来 “注册” 以获取通知。当事件发生时，发布者 “触发事件”，然后执行订阅者提交的所有事件。</p><p>由订阅者提供的方法称为回调方法，因为发布者通过执行这些方法来 “往回调用订阅者的方法”。还可以将它们称为事件处理程序，因为它们是为处理事件而调用的代码。<br /><img data-src="http://lgqimg.changzer.cn/image-20220928193604069.png" alt="image-20220928193604069" /></p></li><li><p>关于事件的重要事项。</p><ul><li><strong>发布者</strong> 发布某个事件的类或结构，其他类可以在该事件发生时得到通知</li><li><strong>订阅者</strong> 注册并在事件发生时得到通知的类或结构</li><li><strong>事件处理程序</strong> 由订阅者注册事件的方法，在发布者 出发事件时执行。事件处理程序方法可以定义在事件所在的类或结构中，也可以定义在不同的类或结构中。</li><li><strong>触发事件</strong> 调用或触发事件的术语。当事件被触发时，所有注册到它的方法都会被一次调用。</li></ul></li><li><p>事件包含了一个私有的委托。<br />事件的私有委托注意事项：</p><ul><li>事件提供了对它的私有控制委托的结构化访问。也就是说，你无法直接访问委托。</li><li>事件中可用的操作比委托要少，对于事件我们只能添加、删除或调用事件处理程序。</li><li>事件被触发时，它调用委托来依次调用调用列表中的方法。</li></ul></li></ol><h3 id="2-源代码组件概览"><a class="anchor" href="#2-源代码组件概览">#</a> 2. 源代码组件概览</h3><ol><li><p>事件中使用的代码有 5 部分</p><ul><li><strong>委托类型声明</strong> 事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。</li><li><strong>事件处理程序声明</strong> 订阅者类中会在事件触发时执行的方法声明。它们不一定是显式命名的方法，还可以是匿名方法或 Lambda 表达式。</li><li><strong>事件声明</strong> 发布者类必须声明一个订阅者类可以注册的事件成员。当类声明的事件为 public 时，称为发布了事件。</li><li><strong>事件注册</strong> 订阅者必须注册事件才能在事件被触发时得到通知。这是将事件处理程序与事件相连的代码。</li><li><strong>触发事件的代码</strong> 发布者类中 “触发” 事件并导致调用注册的所有事件处理程序的代码。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20220928195921778.png" alt="image-20220928195921778" /></p></li></ol><h3 id="3-声明事件"><a class="anchor" href="#3-声明事件">#</a> 3. 声明事件</h3><ol><li><p>声明事件的语法<br /><img data-src="http://lgqimg.changzer.cn/image-20220928200248183.png" alt="image-20220928200248183" /><br /> 关于事件声明的内容：</p><ul><li>事件声明在一个类中。</li><li>它需要委托类型的名称，任何附加到事件 (如注册) 的处理程序都必须与委托类型的签名和返回类型匹配。</li><li>它声明为 public，这样其他类和结构可以在它上面注册事件处理程序。</li><li>不能使用对象创建表达式 (new 表达式) 创建它的对象。</li></ul><p>使用使用逗号分隔创建多个事件：<br /><img data-src="http://lgqimg.changzer.cn/image-20220928200724245.png" alt="image-20220928200724245" /></p><p>也可以可以使用 static 关键字让事件变为静态：<br /><img data-src="http://lgqimg.changzer.cn/image-20220928200800904.png" alt="image-20220928200800904" /></p></li><li><p>事件是成员<br />事件的特性</p><ul><li>由于事件的成员：<ul><li>我们不能在一段可执行代码中声明事件；</li><li>它必须声明在类或者结构中，和其他成员一样。</li></ul></li><li>事件成员被隐式自动初始化为 null；</li></ul></li></ol><h3 id="4-订阅事件"><a class="anchor" href="#4-订阅事件">#</a> 4. 订阅事件</h3><ol><li>订阅者向事件添加事件处理程序。对于一个要添加到事件的事件处理程序来说，它必须具有与事件的委托相同的返回类型和签名。<ul><li>使用 += 运算符来为事件添加事件处理程序。事件处理程序位于该运算符的右边。</li><li>事件处理程序的规范可以是以下任意的一种：<ul><li>实例方法的名称；</li><li>静态方法的名称；</li><li>匿名方法；</li><li>Lambda 表达式。</li></ul></li></ul></li></ol><h3 id="5-触发事件"><a class="anchor" href="#5-触发事件">#</a> 5. 触发事件</h3><ol><li><p>事件成员本身只是保存了需要被调用的事件处理程序。如果事件没有被触发，什么都不会发生。我们需要确保有代码在合适的时候做这件事情。</p><ul><li>在触发事件之前和 null 进行比较，从而查看事件是否包含事件处理程序。如果事件是 nu11, 则表示没有事件处理程序，不能执行。</li><li>触发 l 事件的语法和调用方法一样：<ul><li>使用事件名称，后面跟着参数列表（包含在圆括号中)：</li><li>参数列表必须与事件的委托类型相匹配。</li></ul></li></ul></li><li><p>标准事件的用法</p><p>事件的使用，NET 框架提供了一个标准模式。该标准模式的基础就是 System 命名空间中声明的 EventHandler 委托类型。EventHandler 委托类型的声明如以下代码所示。关于该声明需要注意以下几点。</p><ul><li><p>第一个参数用来保存触发事件的对象的引用。由于它是 object 类型的，所以可以匹配任何类型的实例。</p></li><li><p>第二个参数用来保存状态信息，指明什么类型适用于该应用程序。</p></li><li><p>返回类型是 void。</p></li></ul><pre><code class="language-c#">public delegate void EventHandler(object sender,EventArgs e);</code></pre><p>EventHandler 委托类型的第二个参数是 EventArgs 类的对象，它声明在 System 命名空间中。</p><ul><li>EventArgs 不能传递任何数据，它用于不需要传递数据的事件处理程序 - 通常会被忽略。</li><li>如果你希望传递数据，必须声明一个派生自 EventArgs 的类，并使用合适的字段来保存需要传递的数据。</li></ul></li><li><p>拓展 EventArgs 来传递数据<br />声明一个派生自 EventArgs 的自定义类，它可以保存我们需要传入的数据。类的名称应以 EventArgs 结尾。</p><pre><code class="language-c#">public class IncrementerEvenrArgs:EventArgs&#123;    public int IterationCount&#123;get:set;&#125;  //存储一个整数&#125;</code></pre><p>可以使用泛型委托： <code>EventHandler&lt;&gt;</code></p><ul><li>将自定义类的名称放在尖括号内。</li><li>在需要使用自定义委托类型的地方使用整个字符串。</li></ul><pre><code class="language-c#">public event EventHandler&lt;IncreamentEventArgs&gt; CountedADozen;</code></pre></li><li><p>移除事件处理程序</p><p>在用完事件处理程序之后，可以从事件中把它移除。可以利用 -= 运算符把事件处理程序从事件中移除，如下所示：</p><pre><code class="language-c#">p.SimpleEvent -= s.MethdB;    //移除事件处理程序MethodB</code></pre><p>如果一个处理程序向事件注册了多次，那么当执行命令移除处理程序时，将只移除列表中该处理程序的最后一个实例。</p></li></ol><h3 id="6-事件访问器"><a class="anchor" href="#6-事件访问器">#</a> 6. 事件访问器</h3><ol><li><p>事件只允许 += 和 -= 运算符。我们可以修改这两个运算符的行为，在使用时让事件执行任何我们希望的自定义代码。<br />要改变这两个运算符的操作，必须为事件定义事件访问器：</p><ul><li>有两个访问器：<strong>add</strong> 和<strong> remove</strong>。</li><li>声明事件的访问器看上去和声明属性差不多。</li></ul><p>两个访问器都有叫作 value 的隐式值参数，它连受实例或静态方法的引用。</p><pre><code class="language-c#">public event EventHandler CountedADozen&#123;    add    &#123;        ...//执行+=运算符的代码    &#125;    remove    &#123;        ...//执行-=运算符的代码    &#125;&#125;</code></pre><p>声明了事件访问器之后，事件不包含任何内嵌委托对象。我们必须实现自己的机制来存储和移除事件注册的方法。<br />事件访问器表现为 void 方法，也就是不能使用返回值的 return 语句。</p></li></ol><h2 id="八-泛型"><a class="anchor" href="#八-泛型">#</a> 八、泛型</h2><h3 id="1-c中的泛型"><a class="anchor" href="#1-c中的泛型">#</a> 1. C# 中的泛型</h3><ol><li><p>泛型 (generic) 提供了一种更优雅的方式，可以让多个类共享一组代码。泛型允许我们声明<strong>类型参数化</strong>的代码，用不同类进行实例化。<br /><img data-src="http://lgqimg.changzer.cn/image-20221005192917301.png" alt="image-20221005192917301" /></p><p>C# 提供了 5 种泛型：类、结构、接口、委托和方法。前 4 种是类型，最后一种是方法。</p></li><li><p>示例</p><pre><code class="language-c#">class MyStack&lt;T&gt;&#123;    int StackPointer=0;    T []StackArray;        public void Push(T x)&#123;……&#125;        public T Pop() &#123;……&#125;&#125;</code></pre><p>在类的示例中，使用占位符<strong> T</strong> 而不是 float 来替换 int。</p></li></ol><h3 id="2-泛型类"><a class="anchor" href="#2-泛型类">#</a> 2. 泛型类</h3><ol><li><p>声明泛型类<br />声明一个简单的泛型类和声明普通类差不多。区别如下：</p><ul><li>在类名之后放置一组尖括号。</li><li>在尖括号中用逗号分隔的占位符字符串来表示需要提供的类型。这叫作类型参数 (type parameter)。</li><li>在泛型类声明的主体中使用类型参数来表示替代类型。</li></ul><pre><code class="language-c#">class SomeClass &lt;T1,T2&gt;&#123;    public T1 SomeVar;    public T2 OtherVar;&#125;</code></pre></li><li><p>比较泛型和非泛型栈<br /><img data-src="http://lgqimg.changzer.cn/image-20221005194905583.png" alt="image-20221005194905583" /></p></li><li><p>类型参数的约束</p><p>​在泛型栈的示例中，栈除了保存和弹出它包含的一些项之外没有做任何事情。它不会尝试添加、比较项，也不会做其他任何需要用到项本身的运算符的事情。这是有原因的。由于泛型栈不知道它们保存的项的类型是什么，所以也就不会知道这些类型实现的成员。</p><p>​所有的 C# 对象最终都从 object 类继承，因此，栈可以确认的是，这些保存的项都是实现了 object 类的成员，包括 ToString、Equals 以及 GetType 方法。除此以外，他不知道还有哪些成员可以使用。</p><p>​只要我们的代码不访问它处理的一些类型的对象（或者只要它始终是 object 类型的成员），泛型类就可以处理任何类型。符合约束的类型参数叫作未绑定的类型参数 (unbounded type parameter)。然而，如果代码尝试使用其他成员，编译器会产生一个错误消息。</p><p>​例如，如下代码声明了一个叫作 Simple 的类，它有一个叫作 LessThan 的方法，接受了同 - 一泛型类型的两个变量。LessThan 尝试用小于运算符返回结果。但是由于不是所有的类都实现了小于运算符，也就不能用任何类来代替 T, 所以编译器会产生一个错误消息。</p><pre><code class="language-C#">class Simple&lt;T&gt;&#123;    static public bool LessThan(T i1, T i2)    &#123;        return i1&lt;i2;//错误    &#125;&#125;</code></pre><p>要让泛型变得更有用，我们需要提供额外的信息让编译器知道参数可以接受哪些类型。这些额外的信息叫作约束 (constraint)。只有符合约束的类型才能替代给定的类型参数来产生构造类型。</p><ul><li><p>where 子句<br />约束使用 where 子句列出。</p><ul><li><p>每一个有约束的类型参数都有自己的 where 子句。</p></li><li><p>如果形参有多个约束，它们在 where 子句中用逗号隔开。</p></li><li><p>where 子句语法如下：</p><pre><code class="language-c#">where TypeParam : constraint, constraint.……</code></pre></li></ul><p>有关 where 子句要点如下。</p><ul><li>它们在类型参数列表的关闭尖括号之后列出。</li><li>它们不使用逗号或其他符号分隔。</li><li>它们可以以任何次序列出。</li><li>where 是上下文关键字，所以可以在其他上下文中使用。</li></ul></li><li><p>约束类型和次序<br /><img data-src="http://lgqimg.changzer.cn/image-20221005201242408.png" alt="image-20221005201242408" /></p><p>where 子句可以以任何次序列出。但是 where 子句中的约束必须有特定的顺序。</p><p><img data-src="http://lgqimg.changzer.cn/image-20221005201938496.png" alt="" /></p><ul><li>最多只能有一个主约束，而且必须放在第一位。</li><li>可以有任意多的接口名称约束。</li><li>如果存在构造函数约束，则必须放在后面。</li></ul></li></ul></li></ol><h3 id="3-泛型方法"><a class="anchor" href="#3-泛型方法">#</a> 3. 泛型方法</h3><p>与其他泛型不一样，方法是成员，不是类型。泛型方法额可以在泛型和非泛型以及结构和接口中声明。</p><p><img data-src="http://lgqimg.changzer.cn/image-20221005202405807.png" alt="image-20221005202405807" /></p><ol><li><p>声明泛型方法<br />泛型方法具有类型参数列表和可选的约束。</p><ul><li>泛型方法有两个参数列表<ul><li>封闭在圆括号内的方法参数列表。</li><li>封闭在尖括号内的类型参数列表。</li></ul></li><li>要声明泛型方法，需要：<ul><li>在方法之后和方法参数列表之前放置类型参数列表。</li><li>在方法参数列表后放置可选的约束子句。</li></ul></li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20221005203042377.png" alt="image-20221005203042377" /></p></li><li><p>调用泛型方法<br />要调用泛型方法，应该在方法调用时提供类型实参。<br /><img data-src="http://lgqimg.changzer.cn/image-20221005203230378.png" alt="image-20221005203230378" /></p><ul><li><p>推断类型</p><p>如果我们为方法传入参数，编译器有时可以从方法参数的类型中推断出应用作泛型方法的类型参数的类型。这样就可以使方法调用更简单，可读性更强。</p></li></ul></li></ol><h3 id="4-拓展方法和泛型类"><a class="anchor" href="#4-拓展方法和泛型类">#</a> 4. 拓展方法和泛型类</h3><p>可以将类中的静态方法关联到不同的泛型类上，且允许像调用类构造实例的实例方法一样来调用方法。</p><p>和非泛型类一样，泛型类的拓展方法：</p><ul><li>必须声明位 static；</li><li>必须是静态成员；</li><li>第一个参数类型中必须有关键字 this，后面是拓展的泛型类的名字。</li></ul><h3 id="5-泛型结构"><a class="anchor" href="#5-泛型结构">#</a> 5. 泛型结构</h3><p>与泛型类相似，泛型结构可以有类型参数和约束。泛型结构的规则和条件与泛型类是一样的。</p><h3 id="6-泛型委托"><a class="anchor" href="#6-泛型委托">#</a> 6. 泛型委托</h3><p>泛型委托和非泛型委托非常相似，不过类型参数决定了能接受什么样的方法。</p><ul><li>要声明泛型委托，在委托名称之后、委托参数列表之前的尖括号中放置类型参数列表。<br /><img data-src="http://lgqimg.changzer.cn/image-20221005205322633.png" alt="image-20221005205322633" /></li><li>注意，有两个参数列表：委托形参列表和类型参数列表。</li><li>类型参数的范围包括：<ul><li>返回类型</li><li>形参列表</li><li>约束子句</li></ul></li></ul><h3 id="7-泛型接口"><a class="anchor" href="#7-泛型接口">#</a> 7. 泛型接口</h3><p>泛型接口允许我们编写形参和接口成员返回类型是泛型类型参数的接口。泛型接口的声明和非泛型接口的声明差不多，但是需要在接口名称之后的尖括号中放置类型参数。</p><p><strong>实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。</strong></p><h3 id="8-协变和逆变"><a class="anchor" href="#8-协变和逆变">#</a> 8. 协变和逆变</h3><ol><li><p>协变<br />每一个类型都有一种类型，可以将派生类的对象赋值给基类型的变量，叫作赋值兼容性。</p><pre><code class="language-c#">class Animal &#123;public int Legs=4;&#125;//基类class Dog:Animal &#123;&#125;//派生类delegate T Factory&lt;T&gt;();//Factory委托class Program&#123;    static Dog MakeDog()//匹配Factory委托的方法    &#123;        return new Dog();    &#125;  static void Main()    &#123;        Factory&lt;Dog&gt;dogMaker =MakeDog;//创建委托对象Factory&lt;.Animal&gt;animalMaker=dogMaker;//尝试赋值委托对象里文本.编译错误！            Console.WriteLine(animalMaker().Legs.ToString());    &#125;&#125;</code></pre><p>这个原则成立，但是对于这种情况不适用！问题在于尽管 Dog 是 Animal 的派生类，但是委托 Factory&lt;Dog&gt; 没有从委托 Factory&lt;Animal &gt; 派生。相反，两个委托对象是同级的，它们都从 delegate 类型派生，后者又派生自 object 类型，如下图所示。两者之间没有派生关系，因此赋值兼容性不适用。<br /><img data-src="http://lgqimg.changzer.cn/image-20221005210713287.png" alt="" /></p><p>仅将派生类型用作输出值与构造委托有效性之间的常数关系叫作协变。为了让编译器知道这是我们的期望，必须使用 out 关键字标记委托声明中的类型参数。<br /><img data-src="http://lgqimg.changzer.cn/image-20221005211019289.png" alt="image-20221005211019289" /></p><p><img data-src="http://lgqimg.changzer.cn/image-20221005211259289.png" alt="image-20221005211259289" /></p><ul><li>图左边栈中的变量是 T Factory&lt;outT&gt;() 类型的委托，其中类型变量 T 是 Animal 类。</li><li>图右边堆上实际构造的委托是使用 Dog 类的类型变量进行声明的，Dog 派生自 Animal。</li><li>这是可行的，因为在调用委托的时候，调用代码接受 Dog 类型的对象，而不是期望的 Animal 类型的对象。调用代码可以自由地操作对象的 Animal 部分。</li></ul></li><li><p>逆变</p><p>​和之前的情况相似，默认情况下不可以赋值两种不兼容的类型。但是和之前情况也相似的是，有一些情况可以让这种赋值生效。</p><p>其实，如果类型参数只用作委托中方法的输入参数的话就可以了。这是因为即使调用代码传入了一个程度更高的派生类的引用，委托中的方法也只期望一个程度低一些的派生类的引用一当然，它仍然接收并知道如何操作。<br />这种在期望传入基类时允许传人派生对象的特性叫作逆变。可以通过在类型参数中显式使用 in 关键字来使用逆变。</p><p><img data-src="http://lgqimg.changzer.cn/image-20221005211659573.png" alt="image-20221005211659573" /></p><ul><li>图左边栈上的变量是 void Action1&lt;inT&gt;(Tp) 类型的委托，其类型变量是 Dog 类。</li><li>图右边实际构建的委托使用 Animal 类的类型变量来声明，它是 Dog 类的基类。</li><li>这样可以工作，因为在调用委托的时候，调用代码为方法 ActOnAnimal 传人 Dog 类型的变<br />量，而它期望的是 Animal 类型的对象。方法当然可以像期望的那样自由操作对象的 Animal<br /> 部分。</li></ul></li><li><p>协变和逆变的不同<br /><img data-src="http://lgqimg.changzer.cn/image-20221005211755664.png" alt="image-20221005211755664" /></p><ul><li>左边栈上的变量是 F (outT)() 类型的委托，类型参数是 Base 类。</li><li>在右边实际构建的委托使用 Derived 类的类型变量进行声明，这个类派生自 Base 类。</li><li>这样可以工作，因为在调用委托的时候，方法返回指向派生类型的对象的引用，这也是指向基类的引用，即调用代码所期望的。</li></ul><p><img data-src="http://lgqimg.changzer.cn/image-20221005211806392.png" alt="image-20221005211806392" /></p><ul><li>左边栈上的变量是 F&lt;intT&gt;(Tp) 类型的委托，类型参数是 Derived 类。</li><li>在右边实际构建委托的时候，使用 Base 类的类型变量进行声明，这个类是 Derived 类的基类。</li><li>这样可以工作，因为在调用委托的时候，调用代码向方法传入了派生类型的对象，方法期望的只是基类型的对象。方法完全可以自由操作对象的基类部分。</li></ul></li><li><p>接口的协变和逆变</p><p>注意几点：</p><ul><li>代码使用类型参数 T 声明了泛型接口。out 关键字指定了类型参数是协变的。</li><li>泛型类 SimpleReturn 实现了泛型接口。</li><li>方法 DoSomething 演示了方法如何接受一个接口作为参数。这个方法接受由 Animal 类型构建的泛型接口 IMyIfc 作为参数。</li></ul></li><li><p>编译器可以自动识别某个已构建的委托是协变还是逆变并且自动进行类型强制转换。这通常发生在没有为对象的类型赋值的时候</p></li></ol><h2 id="九-反射"><a class="anchor" href="#九-反射">#</a> 九、反射</h2><h3 id="1-元数据与反射"><a class="anchor" href="#1-元数据与反射">#</a> 1. 元数据与反射</h3><ul><li>有关程序以及类型的数据被称为元数据。被保存在程序的程序集中。</li><li>程序在运行时，可以查看其他程序集或其本身的元数据。运行中程序查看本身的元数据或其他程序元数据的行为被称为反射。</li><li>要使用反射，必须使用 System.Reflection 命名空间。</li></ul><h3 id="2-type类"><a class="anchor" href="#2-type类">#</a> 2. Type 类</h3><p>BCL 声明了一个叫作 Type 的抽象类，被设计用来包含类的特征。使用这个类能够获取程序的类型和信息。</p><ol><li><p>有关 type 的重要事项。</p><ul><li>对于程序中用到的每一个类型，CLR 都会从创建一个包含这个类型信息的 Type 类型的对象。</li><li>不管创建的类型有多少个实例，只有一个 Type 对象会关联到所有这些实例。</li></ul><p>type 类的成员：<br /><img data-src="http://lgqimg.changzer.cn/img/image-20221007194923321.png" alt="image-20221007194923321" /></p></li><li><p>获取 type 对象</p><p>object 类型包含了一个叫作 GetType 的方法，它返回对实例的 Type 对象的引用。由于每一个类型最终<br />都是从 object 派生的，所以我们可以在任何类型的对象上使用 GetType 方法来获取它的 Type 对<br />象。</p><p>还可以使用 typeof 运算符来获取对象。只需要提供类型名作为操作数，就会返回 type 对象的引用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机语言学习 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
