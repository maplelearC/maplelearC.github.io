{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"第二章\" category",
    "description": "Maple的编程学习",
    "home_page_url": "https://maplelearc.github.io",
    "items": [
        {
            "id": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/",
            "url": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B/",
            "title": "CSAPP:第二章",
            "date_published": "2022-10-05T07:50:37.000Z",
            "content_html": "<h1 id=\"csapp第二章\"><a class=\"markdownIt-Anchor\" href=\"#csapp第二章\">#</a> CSAPP: 第二章</h1>\n<h2 id=\"2-信息的表示和处理\"><a class=\"markdownIt-Anchor\" href=\"#2-信息的表示和处理\">#</a> <strong>2、信息的表示和处理</strong></h2>\n<p>计算机使用二值信号存储和表示信息</p>\n<p>当计算结果太大以至于不能表示时，就会产生<strong>溢出</strong>。</p>\n<p>浮点数表示的精度有限，因而浮点运算是不可结合的。</p>\n<p>整数的表示范围小但是精确，浮点数表示的范围大但是是近似的。</p>\n<p>许多安全漏洞是由算术运算的微妙细节导致的。</p>\n<h2 id=\"21-信息存储\"><a class=\"markdownIt-Anchor\" href=\"#21-信息存储\">#</a> <strong>2.1 信息存储</strong></h2>\n<p>计算机一般使用字节作为最小的可寻址的内存单位。</p>\n<p>在机器级程序中不包含关于数据类型的信息。</p>\n<p>指针的值是某个存储块的第一个字节的<strong>虚拟地址</strong>。</p>\n<p><strong>每个程序对象可以视为一个字节块。</strong></p>\n<h3 id=\"211-十六进制表示法\"><a class=\"markdownIt-Anchor\" href=\"#211-十六进制表示法\">#</a> <strong>2.1.1 十六进制表示法</strong></h3>\n<p>十六进制以 0x 开头。</p>\n<p>A：10；C:12；F：15</p>\n<h3 id=\"212-字数据大小\"><a class=\"markdownIt-Anchor\" href=\"#212-字数据大小\">#</a> <strong>2.1.2 字数据大小</strong></h3>\n<p>每个计算机有对应的字长，虚拟地址用一个字来编码，所以<strong>字长决定了虚拟地址空间的大小</strong>。<strong>64 位机器的指针类型长度为 8 字节</strong></p>\n<p>32 位机器的虚拟地址空间为 <strong>4GB</strong>，64 位字长的虚拟地址空间位 16 EB。</p>\n<p><strong>int32_t</strong> 和 <strong>int64_t</strong> 类型分别为 4 字节和 8 字节，不受机器影响。使用确定大小的整数类型很有用。</p>\n<p>对 32 位和 64 位机器而言，char、short、int、long long 长度都是一样的，为  1，2，4，8。long 的长度不一样。</p>\n<p>float 和 double 的长度一样，分别为 4，8</p>\n<p>程序对 char 有无符号一般不敏感。</p>\n<h3 id=\"213-寻址和字节顺序\"><a class=\"markdownIt-Anchor\" href=\"#213-寻址和字节顺序\">#</a> <strong>2.1.3 寻址和字节顺序</strong></h3>\n<p>对于跨越多字节的对象，它的地址是它所用字节中的<strong>最小地址</strong>。</p>\n<p><strong>两种字节存储法：</strong></p>\n<ul>\n<li><strong>小端法</strong>：数字的低位在前（前就是最小地址）</li>\n<li><strong>大端法</strong>：数字的高位在前</li>\n</ul>\n<p>大多数 Intel 都是小端法，不是所有。</p>\n<h3 id=\"214-表示字符串\"><a class=\"markdownIt-Anchor\" href=\"#214-表示字符串\">#</a> <strong>2.1.4 表示字符串</strong></h3>\n<p>C 语言字符串是以 null 字符结尾的字符数组，即 ‘\\0’</p>\n<p>ASCII 字符适合编码英文文档。</p>\n<p>Unicode（UTF-8）使用 <strong>4 字节</strong>表示字符，一些常用的字符只需要 1 或 2 个字节。所有 ASCII 字符在 UTF-8 中是一样的。</p>\n<p>JAVA 使用 UTF-8 来编码字符串。</p>\n<h3 id=\"215-表示代码\"><a class=\"markdownIt-Anchor\" href=\"#215-表示代码\">#</a> <strong>2.1.5 表示代码</strong></h3>\n<p>二进制代码是<strong>不兼容</strong>的，一般无法在不同机器间移植。</p>\n<p>从机器的角度看，<strong>程序就是一个字节序列</strong>。</p>\n<h3 id=\"216-布尔代数\"><a class=\"markdownIt-Anchor\" href=\"#216-布尔代数\">#</a> <strong>2.1.6 布尔代数</strong></h3>\n<p><strong>布尔代数</strong>是在 0 和 1 基础上的定义</p>\n<p>可以把字节看作是一个长为 8 的<strong>位向量</strong>。</p>\n<p>位向量的一个应用是表示有限集合。如位向量 [0110 1001] 表示集合 A = {0,3,5,6}。</p>\n<h3 id=\"217-c-语言中的位级运算\"><a class=\"markdownIt-Anchor\" href=\"#217-c-语言中的位级运算\">#</a> <strong>2.1.7 C 语言中的位级运算</strong></h3>\n<p>位运算的常见应用是实现<strong>掩码</strong>。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8 位。</p>\n<p>表达式 <strong>~0</strong> 可以生成一个全 1 的掩码，不管机器的字大小是多少。</p>\n<h3 id=\"218-c-语言中的逻辑运算\"><a class=\"markdownIt-Anchor\" href=\"#218-c-语言中的逻辑运算\">#</a> <strong>2.1.8 C 语言中的逻辑运算</strong></h3>\n<p>逻辑运算符 &amp;&amp; 和 || 如果第一个参数就能确定结果，就不再计算第二个参数</p>\n<h3 id=\"219-c-语言中的移位运算\"><a class=\"markdownIt-Anchor\" href=\"#219-c-语言中的移位运算\">#</a> <strong>2.1.9 C 语言中的移位运算</strong></h3>\n<p>左移 k 位丢掉最高的 k 位，并在右端补 k 个 0。</p>\n<p>右移分为<strong>逻辑右移</strong>和<strong>算术右移</strong>。<strong>逻辑右移左端补 0，算术右移左端补最高有效位的值。</strong></p>\n<p>一般都对有符号数使用算术右移，即补符号位的值。无符号数，<strong>只能是逻辑右移</strong>，即补 0</p>\n<h2 id=\"22-整数表示\"><a class=\"markdownIt-Anchor\" href=\"#22-整数表示\">#</a> <strong>2.2 整数表示</strong></h2>\n<p>无符号表示与补码表示</p>\n<p>有符号数到无符号数的转换会产生漏洞，<strong>避免错误的方法之一是绝不使用无符号数</strong>。</p>\n<p>除了 C 以外<strong>很少有语言支持无符号整数</strong>，Java 就只支持有符号数</p>\n<h3 id=\"221-整数数据类型\"><a class=\"markdownIt-Anchor\" href=\"#221-整数数据类型\">#</a> <strong>2.2.1 整数数据类型</strong></h3>\n<p>在 64 位系统上</p>\n<ul>\n<li>i<strong>nt</strong>：4 字节，可表示十进制数字位数：<strong>10 位（-20~20 亿以内）</strong></li>\n<li><strong>long long</strong>：8 字节，可表示十进制数字位数：<strong>19 位（千亿亿级）</strong></li>\n<li>long：8 字节</li>\n<li><strong>double</strong>：8 字节，<strong>精度 15 位</strong>，可表示十进制数字位数<strong> 308 位</strong></li>\n<li><strong>float</strong>：4 字节，<strong>精度 6 位</strong>，可表示十进制数字<strong> 38 位</strong></li>\n<li><strong>char</strong>：<strong>-128~127</strong></li>\n</ul>\n<p>java 只支持有符号数。</p>\n<h3 id=\"222-无符号数的编码\"><a class=\"markdownIt-Anchor\" href=\"#222-无符号数的编码\">#</a> <strong>2.2.2 无符号数的编码</strong></h3>\n<p>无符号表示、补码表示与数据的映射都是双射，即一一对应。</p>\n<h3 id=\"223-补码编码\"><a class=\"markdownIt-Anchor\" href=\"#223-补码编码\">#</a> <strong>2.2.3 补码编码</strong></h3>\n<p>补码的定义实际就是<strong>将符号位解释为负权</strong>。</p>\n<p>C 库头文件  定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、UINT_MAX</p>\n<p>C 库头文件 中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数。</p>\n<p><strong>### 2.2.4 有符号数和无符号数之间的转换</strong></p>\n<p>在有符号数与无符号数之间进行强制类型转换的结果是<strong>保持位值不变，只改变解释位的方式。</strong></p>\n<p><strong>补码 x 转无符号数</strong></p>\n<ul>\n<li>x &gt;= 0，值不变</li>\n<li>x &lt; 0，转换后的值为 2^w + x</li>\n</ul>\n<p><strong>无符号数 x 转补码</strong></p>\n<ul>\n<li>x &lt;2^(w-1)，值不变</li>\n<li>x &gt;= 2^(w-1)，转换后的值为 x - 2^w</li>\n</ul>\n<h3 id=\"225-c-语言中的有符号数和无符号数\"><a class=\"markdownIt-Anchor\" href=\"#225-c-语言中的有符号数和无符号数\">#</a> <strong>2.2.5 C 语言中的有符号数和无符号数</strong></h3>\n<p>C 语言中有符号数和无符号数相加减，有符号被转换成无符号。</p>\n<p><strong>### 2.2.6 扩展一个数字的位表示</strong></p>\n<p>扩展无符号数使用零扩展，即在最高位前加 0</p>\n<p>扩展有符号数使用符号扩展，即在最高位前加最高有效位的值</p>\n<p><strong>### 2.2.7 截断数字</strong></p>\n<p>对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。</p>\n<p>对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。</p>\n<h2 id=\"23-整数运算\"><a class=\"markdownIt-Anchor\" href=\"#23-整数运算\">#</a> <strong>2.3 整数运算</strong></h2>\n<h3 id=\"231-无符号加法\"><a class=\"markdownIt-Anchor\" href=\"#231-无符号加法\">#</a> <strong>2.3.1 无符号加法</strong></h3>\n<p>考虑溢出，C 语言不会将溢出作为错误发出信号</p>\n<p>当 x+y &gt;= 2^w，实际结果为 s = x+y-2^w</p>\n<p>对任意的 x+y，<strong>s = (x+y) % 2^w</strong></p>\n<p>** 溢出的结果：** 和小于两个加数</p>\n<p>** 检验溢出的方式：** 如果 <strong>s，说明溢出</strong></p>\n<p><strong>无符号数的非</strong>：~x = 2^w - x (x&gt;0)</p>\n<p><strong>### 2.3.2 补码加法</strong></p>\n<p>当 x+y &gt;= 2^(w-1)， s = x+y-2^w</p>\n<p>当 x+y &lt;-2^(w-1)，s = x+y+2^w</p>\n<p><strong>正溢出的结果是负数，负溢出的结果是正数。</strong></p>\n<p>** 检验溢出的方式：** 当 x,y&gt;0 而 s&lt;=0 是正溢出；当 x,y&lt;0 而 s&gt;=0 是负溢出</p>\n<p><strong>### 2.3.3 补码的非</strong></p>\n<p>当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x</p>\n<p>** 补码非的位级表示：**<strong> 对每一位求补，结果再加 1</strong></p>\n<p>** 计算补码非的第二种方法：** 假设 k 是最右边的 1 的位置，对 k 左边的所有位取反</p>\n<p><strong>### 2.3.4 无符号乘法</strong></p>\n<p><strong>无符号乘法的积</strong> <strong>m = (x*y) % 2^w</strong></p>\n<h3 id=\"235-补码乘法\"><a class=\"markdownIt-Anchor\" href=\"#235-补码乘法\">#</a> <strong>2.3.5 补码乘法</strong></h3>\n<p>可以认为补码乘法和无符号乘法的<strong>位级表示</strong>是一样的</p>\n<p>C 语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释</p>\n<p><strong>补码乘法的积</strong> <strong>m = (x*y) % 2^w</strong></p>\n<p><strong>### 2.3.6 乘以常数</strong></p>\n<p>大多数机器上，整数乘法需要 <strong>10 个或更多</strong>的时钟周期，而加法、减法、位级运算和移位只需要 1 个时钟周期</p>\n<p><strong>编译器对整数乘法进行优化的方式</strong>：用<strong>移位和加法或减法</strong>运算的组合来代替常数因子的乘法。</p>\n<p>左移 k 位等于乘以 2^k</p>\n<p>如 x * 14  =  (x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)   =   (x&lt;&lt;4)-(x&lt;&lt;2)</p>\n<p><strong>判断如何移动的方式</strong>很简单：14 的位级表示为 1110，所以分别左移 3，2，1</p>\n<p><strong>### 2.3.7 除以 2 的幂</strong></p>\n<p>大多数机器上，整数除法更慢，需要 <strong>30 个或更多</strong>的始终周期。</p>\n<p>（只有）除以 2 的幂可以用移位运算来代替，<strong>无符号采用<strong><strong>逻辑右移</strong></strong>，补码采用 **** 算术右移</strong></p>\n<p>对于有符号数而言，算术右移的结果相当于进行除法运算后<strong>向下舍入</strong></p>\n<p>使用 <strong>(x+(1&lt;&gt;k</strong> 的结果相当于进行除法运算然后<strong>向零舍入</strong></p>\n<p>代码实现</p>\n<p>​                (x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k;</p>\n<h3 id=\"238-关于整数运算的最后思考\"><a class=\"markdownIt-Anchor\" href=\"#238-关于整数运算的最后思考\">#</a> <strong>2.3.8 关于整数运算的最后思考</strong></h3>\n<p><strong>补码使用了与无符号算术运算相同的位级实现</strong>，包括加法、减法、乘法甚至除法。都有完全一样或非常类似的位级行为。</p>\n<h2 id=\"24-浮点数\"><a class=\"markdownIt-Anchor\" href=\"#24-浮点数\">#</a> <strong>2.4 浮点数</strong></h2>\n<p>浮点数对于非常大，非常接近零，近似值计算都很有用</p>\n<h3 id=\"241-二进制小数\"><a class=\"markdownIt-Anchor\" href=\"#241-二进制小数\">#</a> <strong>2.4.1 二进制小数</strong></h3>\n<p>小数的二进制表示法只能表示那些能够写为 <strong>x * 2^w</strong> 的数，<strong>其他的数都是近似表示。x 必须可以由形如 2^i + 2^j + … + 2^n 的多项式表示</strong></p>\n<p>浮点运算的不精确性可能产生严重后果</p>\n<p><strong>### 2.4.2 IEEE 浮点表示</strong></p>\n<p><strong>IEEE 浮点标准</strong>的表示形式为：<strong>V = (-1)^S * M * 2^E</strong>，它分为三部分：</p>\n<ol>\n<li><strong>符号</strong>：<strong>S</strong> 决定是负数还是正数</li>\n<li><strong>阶码</strong>：<strong>E</strong> 的作用是对浮点数加权</li>\n<li><strong>尾数</strong>：<strong>M</strong> 是一个二进制小数，范围是 1~2-ε 或 0~1-ε</li>\n</ol>\n<p><strong>在对浮点数的位编码</strong>时：</p>\n<ol>\n<li>一个单独的符号位编码直接编码 S</li>\n<li>k 位的<strong>阶码字段 e</strong> 编码 E；float 中 k=8，double 中 <strong>k=11</strong></li>\n<li>n 位的<strong>小数字段 f</strong> 编码 M；float 中 n=23，double 中 <strong>n=52</strong></li>\n</ol>\n<p>E 和 M 的编码方式分为<strong>三种情况</strong>：</p>\n<ol>\n<li>\n<p>** 规格化的值：** 阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）</p>\n</li>\n<li>\n<ol>\n<li>阶码字段解释方式：<strong>E = e - (2^(k-1)-1)</strong>；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127</li>\n<li>小数字段解释方式：<strong>M = 1 + f</strong></li>\n</ol>\n</li>\n<li>\n<p><strong>非规格化的值</strong>：阶码字段全为 0 时属于非规格化形式</p>\n</li>\n<li>\n<ol>\n<li>阶码字段解释方式：<strong>E = 1 - (2^(k-1)-1)</strong>；<strong>与规格化值中 e = 1 时的 E 相同</strong></li>\n<li>小数字段解释方式：<strong>M = f</strong></li>\n</ol>\n</li>\n<li>\n<p>** 特殊值：** 阶码字段全为 1 时，分两种情况：</p>\n</li>\n<li>\n<ol>\n<li><strong>小数字段全为 0：表示无穷</strong></li>\n<li>** 小数字段非零：表示 NaN。** 比如 ∞-∞ 的结果就返回 NaN</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"243-数字示例\"><a class=\"markdownIt-Anchor\" href=\"#243-数字示例\">#</a> <strong>2.4.3 数字示例</strong></h3>\n<p>0 有 +0.0 和 -0.0 两种表示方式</p>\n<p>最大非规格化数到最小规格化数的过渡是平滑的。</p>\n<p>浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升序负数降序）。</p>\n<p>浮点数可表示的数的分布是不均匀的，越接近零时越稠密</p>\n<p><strong>几个特殊的值的位级表示：</strong></p>\n<ol>\n<li>+0.0 全为 0</li>\n<li>** 最小的正非规格化值：** 最低有效位为 1，其他为 0</li>\n<li>** 最大的非规格化值：** 小数字段全为 1，其他为 0</li>\n<li>** 最小的正规格化值：** 阶码字段最低位为 1，其他为 0</li>\n<li>** 最大的规格化值：** 阶码字段最低位为 0，符号位为 0，其他为 1</li>\n</ol>\n<h3 id=\"244-舍入\"><a class=\"markdownIt-Anchor\" href=\"#244-舍入\">#</a> <strong>2.4.4 舍入</strong></h3>\n<p>因为范围和精度有限，浮点运算只能近似表示实数运算。</p>\n<p>在浮点数的近似匹配上，IEEE 浮点格式定义了<strong>四种舍入方式（默认第一种）：</strong></p>\n<ol>\n<li><strong>向偶数舍入（向最接近的值舍入）</strong>：非中间值 (0.5) 四舍五入，中间值向偶数舍入。</li>\n<li>向零舍入</li>\n<li>向下舍入</li>\n<li>向上舍入</li>\n</ol>\n<p>向偶数舍入可以计算一组数的平均数时避免统计偏差。</p>\n<p>实际上这种舍入是发生在二进制小数上的。</p>\n<h3 id=\"245-浮点运算\"><a class=\"markdownIt-Anchor\" href=\"#245-浮点运算\">#</a> <strong>2.4.5 浮点运算</strong></h3>\n<p>IEEE 标准定义 1/-0 = -∞，1/+0 = +∞</p>\n<p>浮点运算是<strong>可交换不可结合也不可分配</strong>的。</p>\n<p>浮点加法满足<strong>加法和乘法上的单调性</strong>。如果 a&gt;=b，则 x+a &gt;= x+b</p>\n<p>缺乏结合性和分配性会使一些简单问题变得很复杂</p>\n<h3 id=\"246-c-语言中的浮点数\"><a class=\"markdownIt-Anchor\" href=\"#246-c-语言中的浮点数\">#</a> <strong>2.4.6 C 语言中的浮点数</strong></h3>\n<p>在 int、float、double 间进行<strong>强制类型转换时的几种情况：</strong></p>\n<ol>\n<li>int 到 float：不会溢出，可能舍入</li>\n<li>int 或 float 到 double：不会溢出也不会舍入</li>\n<li>double 到 float：可能溢出和舍入</li>\n<li>**float 或 double 到 int：** 向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，转变结果都为 [1000]，因此一个正浮点可能得到一个负整数</li>\n</ol>\n<p><strong>把大的浮点数转换为整数是一种常见的错误。</strong></p>\n<p><strong>要小心地使用浮点运算。</strong></p>\n",
            "tags": [
                "深入理解计算机系统",
                "CSAPP"
            ]
        }
    ]
}