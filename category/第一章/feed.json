{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"第一章\" category",
    "description": "Maple的编程学习",
    "home_page_url": "https://maplelearc.github.io",
    "items": [
        {
            "id": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/",
            "url": "https://maplelearc.github.io/2022/10/05/CSAPP/%E3%80%8ACSAPP%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/",
            "title": "CSAPP:第一章",
            "date_published": "2022-10-05T07:50:37.000Z",
            "content_html": "<h1 id=\"csapp第一章\"><a class=\"markdownIt-Anchor\" href=\"#csapp第一章\">#</a> 《CSAPP：第一章》</h1>\n<h2 id=\"11-信息就是位上下文\"><a class=\"markdownIt-Anchor\" href=\"#11-信息就是位上下文\">#</a> 1.1 信息就是位 + 上下文</h2>\n<p>程序的生命周期从源程序 (源文件) 开始。源程序实际上就是由 0 和 1 组成的位序列。</p>\n<p>一般 ASCII 标准来表示文本字符，实际上是用一个字节的整数值来表示一种字符。</p>\n<p>源文件中每个文本行都是以看不见的 ‘\\n’ 结束的。</p>\n<p>只由 ASCII 字符组成的文件成为<strong>文本文件</strong>，其他都是<strong>二进制文件</strong>。.cpp 文件就是文本文件。</p>\n<p>系统中的所有信息都是由一串比特（bit：位）表示的，区分不同数据对象的<strong>唯一方法</strong>就是根据上下文。</p>\n<p><strong>C 语言的特点</strong></p>\n<ol>\n<li>C 语言小而简单</li>\n<li>C 语言是为了实现 unix 而设计的</li>\n<li>C 语言与 unix 关系密切</li>\n</ol>\n<p>C 语言是系统级编程的首选，也非常适用于应用级程序。</p>\n<h2 id=\"12-程序被其他程序翻译成不同的格式\"><a class=\"markdownIt-Anchor\" href=\"#12-程序被其他程序翻译成不同的格式\">#</a> <strong>1.2</strong> 程序被其他程序翻译成不同的格式</h2>\n<p>从源程序到目标程序要经历<strong>四个步骤：</strong></p>\n<ol>\n<li>源程序被<strong>预处理器</strong>处理得到<strong>修改了的源程序</strong>（文本文件，hello.i）</li>\n<li>再由<strong>编译器</strong>处理得到<strong>汇编程序</strong>（文本文件，hello.s）</li>\n<li>汇编程序由<strong>汇编器</strong>处理得到<strong>可重定位目标程序</strong>（二进制文件，hello.o）</li>\n<li>最后由<strong>链接器</strong>链接得到<strong>可执行目标程序</strong>（二进制文件，hello）</li>\n</ol>\n<p><strong>预处理阶段</strong></p>\n<p>预处理器根据 # 开头的命令修改原始的 c 程序。比如根据 #include 命令把头文件 stdio.h 的内容直接插入到程序文件中</p>\n<p><strong>编译阶段</strong></p>\n<p><strong>汇编阶段</strong></p>\n<p><strong>链接阶段</strong></p>\n<p>比如 printf 函数是一个标准 C 库函数，存在于 printf.o 中，这是一个单独的预编译好了的目标文件。链接器将其与汇编得到的二进制文件合并得到可执行目标文件。</p>\n<h2 id=\"13-了解编译系统如何工作是大有用处的\"><a class=\"markdownIt-Anchor\" href=\"#13-了解编译系统如何工作是大有用处的\">#</a> 1.3 了解编译系统如何工作是大有用处的</h2>\n<p>用处：</p>\n<ol>\n<li>优化程序性能</li>\n<li>理解链接时出现的错误</li>\n<li>避免安全漏洞</li>\n</ol>\n<h2 id=\"14-处理器读并解释储存在内存中的指令\"><a class=\"markdownIt-Anchor\" href=\"#14-处理器读并解释储存在内存中的指令\">#</a> 1.4 处理器读并解释储存在内存中的指令</h2>\n<p>shell 是一个命令行解释器，它输出一个提示符（&gt;&gt;），等待输入一个命令行，然后执行命令。如果输入的是可执行文件的名字，就运行该文件。</p>\n<h3 id=\"141-系统的硬件组成\"><a class=\"markdownIt-Anchor\" href=\"#141-系统的硬件组成\">#</a> 1.4.1 系统的硬件组成</h3>\n<p>主要包括<strong>总线、I/O 设备、处理器、主存储器 **** 四个部分</strong></p>\n<ol>\n<li>\n<p><strong>总线</strong></p>\n<p>总线一次可以传输一个定长的字节块，称为字。64 位系统即总线一次可以传输 64 位（8 字节），这里一个字就是 8 字节</p>\n</li>\n<li>\n<p><strong>I/O 设备</strong></p>\n<p>每个 I/O 设备通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I/O 总线相连。</p>\n<p><strong>控制器</strong>是 I/O 设备本身或主板上的芯片组，<strong>适配器</strong>则是一块插在主板上的卡。</p>\n</li>\n<li>\n<p><strong>主存</strong></p>\n<p>主存是由一组 ** 动态随机存取内存（DRAM）** 组成的。</p>\n<p>从逻辑上看，存储器是一个线性的字节数组，每个字节都有唯一的地址。</p>\n</li>\n<li>\n<p><strong>处理器</strong></p>\n<p>处理器是<strong>解释存储在主存中指令</strong>的引擎。</p>\n<p>处理器的<strong>核心</strong>是一个<strong>程序计数器（PC)</strong></p>\n<p>程序计数器是一个大小为<strong>一个字</strong>的存储设备，存储 CPU 即将执行的<strong>下一条指令的地址</strong>。</p>\n<p>处理器就是在不断执行程序计数器指向的指令。每执行一条，程序计数器更新一次，指向下一条指令。</p>\n<p>处理器会按照 ** 指令执行模型（指令集架构）** 解释指令中的位并执行相应操作。</p>\n<p>每条指令的操作是围绕 ** 主存、寄存器文件、算数 / 逻辑单元（ALU）** 进行的。</p>\n</li>\n<li>\n<p><strong>寄存器文件</strong>：单个字长，有唯一的名字。</p>\n</li>\n<li>\n<p>**ALU：** 计算新的数据和地址值。</p>\n</li>\n<li>\n<p>几个简单指令的操作：</p>\n<ul>\n<li><em>加载</em> *：从主存复制一个字或字节到寄存器，覆盖原来内容 **</li>\n<li>存储 **：从寄存器复制一个字或字节到主存，覆盖原来内容 **</li>\n<li>操作 **：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并把结果存到一个寄存器中 **</li>\n<li>跳转 **：从指令中抽取一个字复制到程序计数器中，覆盖原来内容。</li>\n</ul>\n</li>\n</ol>\n<p>区分处理器指令集架构和微体系架构：</p>\n<ul>\n<li>** 指令集架构：** 每条机器指令的效果</li>\n<li>** 微体系架构：** 处理器实际上是如何实现的</li>\n</ul>\n<h3 id=\"142-运行-hello-程序\"><a class=\"markdownIt-Anchor\" href=\"#142-运行-hello-程序\">#</a> <strong>1.4.2 运行 hello 程序</strong></h3>\n<p>执行目标文件时，shell 程序将位于磁盘目标文件中的字符逐个读入寄存器，然后放到主存中。之后处理器就开始执行目标文件的机器语言指令，从 main 程序开始。</p>\n<p>利用 ** 直接存储器存取（DMA）** 可以不通过寄存器，直接将数据从磁盘到达内存。</p>\n<p>以输出打印 hello world 为例，处理器将 hello world 的字节复制到寄存器，然后再复制到显示器，最后显示在屏幕上。</p>\n<p>** 整个流程：**<strong> 读取文件字符到寄存器 → 存储到主存  → 执行指令</strong>  →  <strong>加载 helloworld 到寄存器 → 复制到显示器 → 显示</strong></p>\n<h2 id=\"15-高速缓存至关重要\"><a class=\"markdownIt-Anchor\" href=\"#15-高速缓存至关重要\">#</a> <strong>1.5 高速缓存至关重要</strong></h2>\n<p>从主存读取一个字比磁盘快 <strong>1000 万</strong>倍。</p>\n<p>从寄存器文件读取比主存块 <strong>100 倍</strong>，并且差距还在加大。</p>\n<p>高速缓存（cache）用来解决处理器与主存间的差异。</p>\n<p><strong>L1 高速缓存</strong>位于 <strong>CPU</strong> 上，容量为数万字节（<strong>几十 MB</strong>）。L1 比 L2 快 <strong>5</strong> 倍。</p>\n<p><strong>L2 高速缓存</strong>通过<strong>一条特殊的总线</strong>与 CPU 连接，容量为数十万到数百万字节（<strong>几百 MB 到 几 GB</strong>）。L2 比 主存快 <strong>5~10</strong> 倍</p>\n<p>新的系统还有 L3。</p>\n<p>通过让高速缓存里存放可能经常访问的数据，让大部分的内存操作都在高速缓存中完成。</p>\n<h2 id=\"16-存储设备形成层次结构\"><a class=\"markdownIt-Anchor\" href=\"#16-存储设备形成层次结构\">#</a> <strong>1.6 存储设备形成层次结构</strong></h2>\n<p>存储器层次结构共 7 层，<strong>主要思想</strong>是上一层的存储器作为低一层的高速缓存。</p>\n<p>从上到下，容量更大，运行更慢，每字节价格更便宜。</p>\n<ul>\n<li>0 层：寄存器</li>\n<li>1 层：L1 高速缓存 (SRAM)</li>\n<li>2 层：L2 高速缓存 (SRAM)</li>\n<li>3 层：L3 高速缓存（SRAM）</li>\n<li>4 层：主存（DRAM）</li>\n<li>5 层：本地二级存储（本地磁盘）</li>\n<li>6 层：远程二级存储（分布式文件系统，Web 服务器）</li>\n</ul>\n<h2 id=\"17-操作系统管理硬件\"><a class=\"markdownIt-Anchor\" href=\"#17-操作系统管理硬件\">#</a> <strong>1.7 操作系统管理硬件</strong></h2>\n<p>操作系统的<strong>两个基本功能：</strong></p>\n<ol>\n<li>防止硬件被失控的应用程序滥用</li>\n<li>向应用程序提供简单一致的机制来控制复杂的低级硬件设备</li>\n</ol>\n<p>操作系统所应用的<strong>三个基本的抽象概念：</strong></p>\n<ol>\n<li><strong>进程</strong>：对处理器、主存和 I/O 设备的抽象表示</li>\n<li><strong>虚拟内存</strong>：对主存和磁盘的抽象表示</li>\n<li><strong>文件</strong>：对 I/O 设备的抽象表示</li>\n</ol>\n<h3 id=\"171-进程\"><a class=\"markdownIt-Anchor\" href=\"#171-进程\">#</a> <strong>1.7.1 进程</strong></h3>\n<p>** 进程：** 对操作系统正在运行的程序的一种抽象。</p>\n<p>** 并发运行：** 一个进程的指令和另一个进程的指令是交错执行的。</p>\n<p>一个系统可以同时运行多个进程，实际上这些进程是并发运行的。</p>\n<p>操作系统通过<strong>上下文切换</strong>来实现并发运行。上下文是跟踪进程运行所需的所有<strong>状态信息</strong>，可能存在于 PC、寄存器文件、主存等地方。</p>\n<p><strong>任何时刻，单处理器只能执行一个进程的代码。</strong></p>\n<p>操作系统<strong>内核</strong>是操作系统代码常驻主存的部分，从一个进程到另一个进程的转换是由内核管理的。</p>\n<p>内核不是一个独立的进程，是一系列代码和数据结构的集合。</p>\n<p>当应用程序需要操作系统的某些操作时，就把控制权传递给内核，内核执行完操作后返回应用程序。</p>\n<h3 id=\"172-线程\"><a class=\"markdownIt-Anchor\" href=\"#172-线程\">#</a> <strong>1.7.2 线程</strong></h3>\n<p><strong>一个进程由多个线程组成</strong>，每个线程都运行在进程的上下文中，共享同样的代码和全局数据。</p>\n<p>多线程之间比多进程之间更容易共享数据，且线程一般来说比进程更高效。</p>\n<h3 id=\"173-虚拟内存\"><a class=\"markdownIt-Anchor\" href=\"#173-虚拟内存\">#</a> <strong>1.7.3 虚拟内存</strong></h3>\n<p>机器级程序将内存视为一个庞大的字节数组，称为<strong>虚拟内存</strong>。</p>\n<p>内存的每个字节由地址来标识，所有可能地址的集合就是<strong>虚拟地址空间。</strong></p>\n<p>虚拟内存使每个进程都以为自己独占了主存。每个进程看到的内存都是<strong>一致的</strong>，即<strong>虚拟地址空间</strong>。</p>\n<p>在 linux 中，每个进程看到的虚拟地址空间由以下几个部分组成：</p>\n<ol>\n<li><strong>程序代码和数据</strong></li>\n<li><strong>堆（运行时堆）</strong></li>\n<li><strong>共享库</strong></li>\n<li><strong>栈（用户栈）</strong></li>\n<li><strong>内核虚拟内存</strong></li>\n</ol>\n<p>地址从低到高，最高层的<strong>内核虚拟内存</strong>保存的是操作系统中的代码和数据，这部分每个进程都一样。</p>\n<p><em>程序代码和数据</em> *</p>\n<p>对所有进程来说，代码都是从同一个固定地址开始，紧接着是与全局变量对应的数据区。代码和数据区都是按照可执行文件的内容初始化的。代码和数据区在进程开始运行时就被指定了大小。</p>\n<p><strong>堆</strong></p>\n<p>而运行时堆是根据 malloc 和 free 函数的调用在运行时<strong>动态地</strong>扩展和收缩的。</p>\n<p><strong>共享库</strong></p>\n<p>地址空间的中间部分用来存放共享库的代码和数据。如 C 标准库、数学库等都属于共享库</p>\n<p><strong>栈</strong></p>\n<p>用户栈和堆一样，在程序执行期间可以<strong>动态的扩展和收缩</strong>，编译器用它来<strong>实现函数调用</strong>。当调用函数时，栈增长，从函数返回时，栈收缩</p>\n<h3 id=\"174-文件\"><a class=\"markdownIt-Anchor\" href=\"#174-文件\">#</a> <strong>1.7.4 文件</strong></h3>\n<p>文件就是<strong>字节序列</strong>，仅此而已。</p>\n<p>每个 I/O 设备，包括磁盘、键盘、显示器、网络，都可以看成是文件。</p>\n<h2 id=\"18-系统之间利用网络通信\"><a class=\"markdownIt-Anchor\" href=\"#18-系统之间利用网络通信\">#</a> <strong>1.8 系统之间利用网络通信</strong></h2>\n<p>从一个单独的系统而言，网络可以视为一个 I/O 设备。</p>\n<p>以在一个远端服务器运行程序为例，在本地输入，在远端执行，执行结果发送回本地输出。</p>\n<h2 id=\"19-重要主题\"><a class=\"markdownIt-Anchor\" href=\"#19-重要主题\">#</a> <strong>1.9 重要主题</strong></h2>\n<h3 id=\"191-amdahl-定律\"><a class=\"markdownIt-Anchor\" href=\"#191-amdahl-定律\">#</a> <strong>1.9.1 Amdahl 定律</strong></h3>\n<p>Amdahl 定律的主要观点：要加速整个系统，必须提升全系统中相当大的部分。</p>\n<h3 id=\"192-并发和并行\"><a class=\"markdownIt-Anchor\" href=\"#192-并发和并行\">#</a> <strong>1.9.2 并发和并行</strong></h3>\n<p>区分并发与并行：</p>\n<ul>\n<li>** 并发：** 一个通用的概念，指一个同时具有多个活动的系统</li>\n<li>** 并行：** 用并发来使系统运行得更快</li>\n</ul>\n<p>并行可以在多个抽象层次上运用。从高到低有以下三个层次</p>\n<p><strong>1. 线程级并行</strong></p>\n<p>传统意义上的并发执行是通过单处理器在进程间快速切换<strong>模拟</strong>出来的。</p>\n<p>多处理器系统由一个操作系统控制多个 CPU。结构如下</p>\n<p>​    <img data-src=\"http://lgqimg.changzer.cn/image-20221005160155790.png\" alt=\"image-20221005160155790\"></p>\n<p>L1 高速缓存被分为两个部分：一个保存最近取到的指令，一个存放数据。</p>\n<p><strong>超线程</strong>又称<strong>同时多线程</strong>，它允许一个 CPU 执行多个控制流。 CPU 有的硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件只有一份，比如浮点算术运算单元。常规 CPU 需要约 <strong>20000</strong> 个时钟周期来切换线程，超线程 CPU 可以在<strong>单个周期</strong>的基础上切换线程，比如一个线程在等待数据装在到高速缓存，CPU 就可以去执行另一个线程。</p>\n<p>i7 处理器每个核执行两个线程，所以是 <strong>4 核 8 线程</strong>，8 个线程都并行执行。</p>\n<p><strong>2. 指令级并行</strong></p>\n<p>每条指令从开始到结束一般需要 20 个或更多的时钟周期，通过指令级并行，可以实现每个周期 2~4 条指令的执行速率。</p>\n<p>如果比一个周期一条指令更快，就称为<strong>超标量处理器</strong>，现在一般都是超标量。</p>\n<p><strong>3. 单指令、多数据并行</strong></p>\n<p>在最低层次上，现代处理器允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行，即 SIMD 并行。</p>\n<h3 id=\"193-计算机系统中抽象的重要性\"><a class=\"markdownIt-Anchor\" href=\"#193-计算机系统中抽象的重要性\">#</a> <strong>1.9.3 计算机系统中抽象的重要性</strong></h3>\n<p>​    <img data-src=\"http://lgqimg.changzer.cn/image-20221005160217657.png\" alt=\"image-20221005160217657\"></p>\n<p><strong>指令集架构</strong>是对 CPU 硬件的抽象，使用这个抽象，CPU 看起来好像一次只执行机器代码程序的一条指令，实际上底层硬件并行地执行多条指令。</p>\n<p><strong>虚拟机</strong>是对整个计算机系统的抽象，包括操作系统、处理器和程序。<strong>1.4.1 系统的硬件组成</strong></p>\n<p>主要包括<strong>总线、I/O 设备、处理器、主存储器 **** 四个部分</strong></p>\n",
            "tags": [
                "深入理解计算机系统",
                "CSAPP"
            ]
        }
    ]
}